<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Using Property Graphs in a Big Data Environment</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="dcterms.created" content="2016-05-03T13:10:54Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Big Data Spatial and Graph User's Guide and Reference" />
<meta name="dcterms.identifier" content="E67958-03" />
<meta name="dcterms.isVersionOf" content="BDSPA" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2015, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="config-pg-support.htm" title="Previous" type="text/html" />
<link rel="Next" href="using-inmem-analytics.htm" title="Next" type="text/html" />
<link rel="alternate" href="E67958-03.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-FF0B76C5-0626-441B-A750-102C02A0C7AA"></a> <span id="PAGE" style="display:none;">10/15</span> <!-- End Header --><a id="BDSPA191"></a>
<h1 id="BDSPA-GUID-FF0B76C5-0626-441B-A750-102C02A0C7AA" class="sect1"><span class="enumeration_chapter">4</span> Using Property Graphs in a Big Data Environment</h1>
<div>
<p>This chapter provides conceptual and usage information about creating, storing, and working with property graph data in a Big Data environment.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-2ECE6EAB-383A-44D6-8C25-25F5FCB5A26D">About Property Graphs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-349A3705-6A70-4A35-A71B-7E3D65AB42CA">About Property Graph Data Formats</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-C621157E-AB7C-4B98-86C5-02D22FA7A20E">Getting Started with Property Graphs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B">Using Java APIs for Property Graph Data</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-727847CA-F6C9-40BD-B9BA-7FA48AF7D804">Managing Text Indexing for Property Graph Data</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-25432BC8-B8EA-494E-8A6A-5C19ECD6760F">Querying Property Graph Data</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-924E8670-F550-41F9-884A-1998409A7544">Support for Secure Oracle NoSQL Database</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-71095D2A-E20F-4FD2-9571-A36031995D8C">Implementing Security on Graphs Stored in Apache HBase</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A">Using the Groovy Shell with Property Graph Data</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C">Exploring the Sample Programs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5">Oracle Flat File Format Definition</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-F363808E-6416-4B2D-AFE6-49B9C91B9EED">Example Python User Interface</a></p>
</li>
</ul>
</div>
<a id="BDSPA192"></a>
<div class="props_rev_3"><a id="GUID-2ECE6EAB-383A-44D6-8C25-25F5FCB5A26D"></a>
<h2 id="BDSPA-GUID-2ECE6EAB-383A-44D6-8C25-25F5FCB5A26D" class="sect2"><span class="enumeration_section">4.1</span> About Property Graphs</h2>
<div>
<p>Property graphs allow an easy association of properties (key-value pairs) with graph vertices and edges, and they enable analytical operations based on relationships across a massive set of data.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD">What Are Property Graphs?</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A">What Is Big Data Support for Property Graphs?</a></p>
</li>
</ul>
</div>
<a id="BDSPA194"></a><a id="BDSPA193"></a>
<div class="props_rev_3"><a id="GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD"></a>
<h3 id="BDSPA-GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD" class="sect3"><span class="enumeration_section">4.1.1</span> What Are Property Graphs?</h3>
<div>
<p>A property graph consists of a set of objects or <span class="bold">vertices</span>, and a set of arrows or <span class="bold">edges</span> connecting the objects. Vertices and edges can have multiple properties, which are represented as key-value pairs.</p>
<p>Each vertex has a unique identifier and can have:</p>
<ul style="list-style-type: disc;">
<li>
<p>A set of outgoing edges</p>
</li>
<li>
<p>A set of incoming edges</p>
</li>
<li>
<p>A collection of properties</p>
</li>
</ul>
<p>Each edge has a unique identifier and can have:</p>
<ul style="list-style-type: disc;">
<li>
<p>An outgoing vertex</p>
</li>
<li>
<p>An incoming vertex</p>
</li>
<li>
<p>A text label that describes the relationship between the two vertices</p>
</li>
<li>
<p>A collection of properties</p>
</li>
</ul>
<p><a href="using-pgs-bigdata.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 4-1</a> illustrates a very simple property graph with two vertices and one edge. The two vertices have identifiers 1 and 2. Both vertices have properties <code>name</code> and <code>age</code>. The edge is from the outgoing vertex 1 to the incoming vertex 2. The edge has a text label <code>knows</code> and a property <code>type</code> identifying the type of relationship between vertices 1 and 2.</p>
<div class="figure" id="GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">
<p class="titleinfigure">Figure 4-1 Simple Property Graph Example</p>
<img width="265" height="113" src="img/GUID-CBE7DF5E-2A8D-4108-A0E5-31A15A5766B0-default.png" alt="Description of Figure 4-1 follows" title="Description of Figure 4-1 follows" /><br />
<a href="img_text/GUID-161BEA27-CD92-47E9-BC07-34F1F76C666A.htm">Description of "Figure 4-1 Simple Property Graph Example"</a></div>
<!-- class="figure" -->
<p>Standards are not available for Big Data Spatial and Graph property graph data model, but it is similar to the W3C standards-based Resource Description Framework (RDF) graph data model. The property graph data model is simpler and much less precise than RDF. These differences make it a good candidate for use cases such as these:</p>
<ul style="list-style-type: disc;">
<li>
<p>Identifying influencers in a social network</p>
</li>
<li>
<p>Predicting trends and customer behavior</p>
</li>
<li>
<p>Discovering relationships based on pattern matching</p>
</li>
<li>
<p>Identifying clusters to customize campaigns</p>
</li>
</ul>
</div>
</div>
<a id="BDSPA196"></a><a id="BDSPA195"></a>
<div class="props_rev_3"><a id="GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A"></a>
<h3 id="BDSPA-GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A" class="sect3"><span class="enumeration_section">4.1.2</span> What Is Big Data Support for Property Graphs?</h3>
<div>
<p>Property graphs are supported for Big Data in Hadoop and in Oracle NoSQL Database. This support consists of a data access layer and an analytics layer. A choice of databases in Hadoop provides scalable and persistent storage management.</p>
<p><a href="using-pgs-bigdata.htm#GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A__BHBDDCAI">Figure 4-2</a> provides an overview of the Oracle property graph architecture.</p>
<div class="figure" id="GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A__BHBDDCAI">
<p class="titleinfigure">Figure 4-2 Oracle Property Graph Architecture</p>
<img width="413" height="363" src="img/GUID-48E81E9D-68F5-4769-9DD8-69BAAF81EADC-default.jpg" alt="Description of Figure 4-2 follows" title="Description of Figure 4-2 follows" /><br />
<a href="img_text/GUID-0DAA9B49-C64E-451D-8BD1-98C7745955B2.htm">Description of "Figure 4-2 Oracle Property Graph Architecture"</a></div>
<!-- class="figure" --></div>
<a id="BDSPA197"></a>
<div class="props_rev_3"><a id="GUID-67CA6CE9-4726-42F0-BEE9-A119E54CD7D8"></a>
<h4 id="BDSPA-GUID-67CA6CE9-4726-42F0-BEE9-A119E54CD7D8" class="sect4"><span class="enumeration_section">4.1.2.1</span> In-Memory Analyst</h4>
<div>
<p>The in-memory analyst layer enables you to analyze property graphs using parallel in-memory execution. It provides over 35 analytic functions, including path calculation, ranking, community detection, and recommendations.</p>
</div>
</div>
<a id="BDSPA198"></a>
<div class="props_rev_3"><a id="GUID-B6C6C3FC-864B-4E1F-B3FA-7AD05A8F4C33"></a>
<h4 id="BDSPA-GUID-B6C6C3FC-864B-4E1F-B3FA-7AD05A8F4C33" class="sect4"><span class="enumeration_section">4.1.2.2</span> Data Access Layer</h4>
<div>
<p>The data access layer provides a set of Java APIs that you can use to create and drop property graphs, add and remove vertices and edges, search for vertices and edges using key-value pairs, create text indexes, and perform other manipulations. The Java APIs include an implementation of TinkerPop Blueprints graph interfaces for the property graph data model. The APIs also integrate with the Apache Lucene and Apache SolrCloud, which are widely-adopted open-source text indexing and search engines.</p>
</div>
</div>
<a id="BDSPA199"></a>
<div class="props_rev_3"><a id="GUID-F5588AE8-918D-417C-A33E-5BF0730F2106"></a>
<h4 id="BDSPA-GUID-F5588AE8-918D-417C-A33E-5BF0730F2106" class="sect4"><span class="enumeration_section">4.1.2.3</span> Storage Management</h4>
<div>
<p>You can store your property graphs in either Oracle NoSQL Database or Apache HBase. Both databases are mature and scalable, and support efficient navigation, querying, and analytics. Both use tables to model the vertices and edges of property graphs.</p>
</div>
</div>
<a id="BDSPA200"></a>
<div class="props_rev_3"><a id="GUID-1D8C99DB-8C8B-45B2-995D-E5DD2BA68505"></a>
<h4 id="BDSPA-GUID-1D8C99DB-8C8B-45B2-995D-E5DD2BA68505" class="sect4"><span class="enumeration_section">4.1.2.4</span> RESTful Web Services</h4>
<div>
<p>You can also use RESTful web services to access the graph data and perform graph operations. For example, you can use the Linux <code>curl</code> command to obtain vertices and edges, and to add and remove graph elements.</p>
</div>
</div>
</div>
</div>
<a id="BDSPA202"></a>
<div class="props_rev_3"><a id="GUID-349A3705-6A70-4A35-A71B-7E3D65AB42CA"></a>
<h2 id="BDSPA-GUID-349A3705-6A70-4A35-A71B-7E3D65AB42CA" class="sect2"><span class="enumeration_section">4.2</span> About Property Graph Data Formats</h2>
<div>
<p>The following graph formats are supported:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-B31C005F-0234-405C-837C-F12C11C0E941">GraphML Data Format</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734">GraphSON Data Format</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-DCC9B9AF-9714-4D03-A307-93DC10751453">GML Data Format</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A">Oracle Flat File Format</a></p>
</li>
</ul>
</div>
<a id="BDSPA204"></a><a id="BDSPA203"></a>
<div class="props_rev_3"><a id="GUID-B31C005F-0234-405C-837C-F12C11C0E941"></a>
<h3 id="BDSPA-GUID-B31C005F-0234-405C-837C-F12C11C0E941" class="sect3"><span class="enumeration_section">4.2.1</span> GraphML Data Format</h3>
<div>
<p>The GraphML file format uses XML to describe graphs. <a href="using-pgs-bigdata.htm#GUID-B31C005F-0234-405C-837C-F12C11C0E941__BHBJAHIE">Example 4-1</a> shows a GraphML description of the property graph shown in <a href="using-pgs-bigdata.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 4-1</a>.</p>
<div class="infoboxnotealso" id="GUID-B31C005F-0234-405C-837C-F12C11C0E941__GUID-55C13F67-3B82-4EF3-B89D-FCE9530E8DCC">
<p class="notep1">See Also:</p>
<p>"The GraphML File Format" at</p>
<p><a href="http://graphml.graphdrawing.org/" target="_blank"><code>http://graphml.graphdrawing.org/</code></a></p>
</div>
<div class="example" id="GUID-B31C005F-0234-405C-837C-F12C11C0E941__BHBJAHIE">
<p class="titleinexample">Example 4-1 GraphML Description of a Simple Property Graph</p>
<pre dir="ltr">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns"&gt;
    &lt;key id="name" for="node" attr.name="name" attr.type="string"/&gt;
    &lt;key id="age" for="node" attr.name="age" attr.type="int"/&gt;
    &lt;key id="type" for="edge" attr.name="type" attr.type="string"/&gt;
    &lt;graph id="PG" edgedefault="directed"&gt;
        &lt;node id="1"&gt;
            &lt;data key="name"&gt;Alice&lt;/data&gt;
            &lt;data key="age"&gt;31&lt;/data&gt;
        &lt;/node&gt;
        &lt;node id="2"&gt;
            &lt;data key="name"&gt;Bob&lt;/data&gt;
            &lt;data key="age"&gt;27&lt;/data&gt;
        &lt;/node&gt;
        &lt;edge id="3" source="1" target="2" label="knows"&gt;
            &lt;data key="type"&gt;friends&lt;/data&gt;
        &lt;/edge&gt;
    &lt;/graph&gt;
&lt;/graphml&gt;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA206"></a><a id="BDSPA205"></a>
<div class="props_rev_3"><a id="GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734"></a>
<h3 id="BDSPA-GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734" class="sect3"><span class="enumeration_section">4.2.2</span> GraphSON Data Format</h3>
<div>
<p>The GraphSON file format is based on JavaScript Object Notation (JSON) for describing graphs. <a href="using-pgs-bigdata.htm#GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734__BHBHABBB">Example 4-2</a> shows a GraphSON description of the property graph shown in <a href="using-pgs-bigdata.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 4-1</a>.</p>
<div class="infoboxnotealso" id="GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734__GUID-64AF1AC3-E709-4F3E-890F-2D336C5CE7AB">
<p class="notep1">See Also:</p>
<p>"GraphSON Reader and Writer Library" at</p>
<p><a href="https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library" target="_blank"><code>https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library</code></a></p>
</div>
<div class="example" id="GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734__BHBHABBB">
<p class="titleinexample">Example 4-2 GraphSON Description of a Simple Property Graph</p>
<pre dir="ltr">
{
    "graph": {
        "mode":"NORMAL",
        "vertices": [
            {
                "name": "Alice",
                "age": 31,
                "_id": "1",
                "_type": "vertex"
            },
            {
                "name": "Bob",
                "age": 27,
                "_id": "2",
                "_type": "vertex"
            }       
        ],
        "edges": [
            {
                "type": "friends",
                "_id": "3",
                "_type": "edge",
                "_outV": "1",
                "_inV": "2",
                "_label": "knows"
            }
        ]
    }
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA208"></a><a id="BDSPA207"></a>
<div class="props_rev_3"><a id="GUID-DCC9B9AF-9714-4D03-A307-93DC10751453"></a>
<h3 id="BDSPA-GUID-DCC9B9AF-9714-4D03-A307-93DC10751453" class="sect3"><span class="enumeration_section">4.2.3</span> GML Data Format</h3>
<div>
<p>The Graph Modeling Language (GML) file format uses ASCII to describe graphs. <a href="using-pgs-bigdata.htm#GUID-DCC9B9AF-9714-4D03-A307-93DC10751453__BHBDFBBB">Example 4-3</a> shows a GML description of the property graph shown in <a href="using-pgs-bigdata.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 4-1</a>.</p>
<div class="infoboxnotealso" id="GUID-DCC9B9AF-9714-4D03-A307-93DC10751453__GUID-52203D16-4D87-44B7-9023-60A80C067EAE">
<p class="notep1">See Also:</p>
<p>"GML: A Portable Graph File Format" by Michael Himsolt at</p>
<p><a href="http://www.fim.uni-passau.de/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf" target="_blank"><code>http://www.fim.uni-passau.de/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf</code></a></p>
</div>
<div class="example" id="GUID-DCC9B9AF-9714-4D03-A307-93DC10751453__BHBDFBBB">
<p class="titleinexample">Example 4-3 GML Description of a Simple Property Graph</p>
<pre dir="ltr">
graph [
   comment "Simple property graph"
   directed 1
   IsPlanar 1
   node [
      id 1
      label "1"
      name "Alice"
      age 31
        ]
   node [
      id 2
      label "2"
      name "Bob"
      age 27
        ]
   edge [
      source 1
      target 2
      label "knows"
      type "friends"
        ]
      ]
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA210"></a><a id="BDSPA209"></a>
<div class="props_rev_3"><a id="GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A"></a>
<h3 id="BDSPA-GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A" class="sect3"><span class="enumeration_section">4.2.4</span> Oracle Flat File Format</h3>
<div>
<p>The Oracle flat file format exclusively describes property graphs. It is more concise and provides better data type support than the other file formats. The Oracle flat file format uses two files for a graph description, one for the vertices and one for edges. Commas separate the fields of the records.</p>
<p><a href="using-pgs-bigdata.htm#GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A__BHBJGIJJ">Example 4-4</a> shows the Oracle flat files that describe the property graph shown in <a href="using-pgs-bigdata.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 4-1</a>.</p>
<div class="infoboxnotealso" id="GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A__GUID-BA266589-1929-420E-BF61-8AE0D4697573">
<p class="notep1">See Also:</p>
<p><span class="q">"<a href="using-pgs-bigdata.htm#GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5">Oracle Flat File Format Definition</a>"</span></p>
</div>
<div class="example" id="GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A__BHBJGIJJ">
<p class="titleinexample">Example 4-4 Oracle Flat File Description of a Simple Property Graph</p>
<p><span class="bold">Vertex file:</span></p>
<pre dir="ltr">
1,name,1,Alice,,
1,age,2,,31,
2,name,1,Bob,,
2,age,2,,27,
</pre>
<p><span class="bold">Edge file:</span></p>
<pre dir="ltr">
1,1,2,knows,type,1,friends,, 
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="BDSPA201"></a>
<div class="props_rev_3"><a id="GUID-C621157E-AB7C-4B98-86C5-02D22FA7A20E"></a>
<h2 id="BDSPA-GUID-C621157E-AB7C-4B98-86C5-02D22FA7A20E" class="sect2"><span class="enumeration_section">4.3</span> Getting Started with Property Graphs</h2>
<div>
<div class="section">
<p>To get started with property graphs:</p>
</div>
<!-- class="section" -->
<ol>
<li class="stepexpand"><span>The first time you use property graphs, ensure that the software is installed and operational.</span></li>
<li class="stepexpand"><span>Create your Java programs, using the classes provided in the Java API.</span>
<div>
<p>See <span class="q">"<a href="using-pgs-bigdata.htm#GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B">Using Java APIs for Property Grsph Data</a>"</span>.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="BDSPA211"></a>
<div class="props_rev_3"><a id="GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B"></a>
<h2 id="BDSPA-GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B" class="sect2"><span class="enumeration_section">4.4</span> Using Java APIs for Property Graph Data</h2>
<div>
<p>Creating a property graph involves using the Java APIs to create the property graph and objects in it.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-FEAADCBB-EFDD-4C3D-8759-0F84D4732836">Overview of the Java APIs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-EC851482-926D-4EB4-A922-ADEBF71C5611">Parallel Loading of Graph Data</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-A25C4F9E-E84D-4585-AF70-CE244F8AB547">Opening and Closing a Property Graph Instance</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-E0DAB9AE-5962-41AF-9B73-F390AF6189DC">Creating the Vertices</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-B29900B4-6D97-41EF-B863-0CF17196234F">Creating the Edges</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-BFD2302B-C94B-47BC-A1AE-1BE4459BBBDD">Deleting the Vertices and Edges</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-64E7B0BF-315E-45CE-ACD5-2566B33A7501">Reading a Graph from a Database into an Embedded In-Memory Analyst</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-ECB7B9A0-038B-451A-AAAB-9F8815AE2602">Building an In-Memory Graph</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-EE2C73EA-2185-4BD7-B1F8-974D455F41D3">Dropping a Property Graph</a></p>
</li>
</ul>
</div>
<a id="BDSPA212"></a>
<div class="props_rev_3"><a id="GUID-FEAADCBB-EFDD-4C3D-8759-0F84D4732836"></a>
<h3 id="BDSPA-GUID-FEAADCBB-EFDD-4C3D-8759-0F84D4732836" class="sect3"><span class="enumeration_section">4.4.1</span> Overview of the Java APIs</h3>
<div>
<p>The Java APIs that you can use for property graphs include:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC">Oracle Big Data Spatial and Graph Java APIs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C">TinkerPop Blueprints Java APIs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57">Apache Hadoop Java APIs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE">Oracle NoSQL Database Java APIs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6">Apache HBase Java APIs</a></p>
</li>
</ul>
</div>
<a id="BDSPA213"></a>
<div class="props_rev_3"><a id="GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC"></a>
<h4 id="BDSPA-GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC" class="sect4"><span class="enumeration_section">4.4.1.1</span> Oracle Big Data Spatial and Graph Java APIs</h4>
<div>
<p>Oracle Big Data Spatial and Graph property graph support provides database-specific APIs for Apache HBase and Oracle NoSQL Database. The data access layer API (<code>oracle.pg.*</code>) implements TinkerPop Blueprints APIs, text search, and indexing for property graphs stored in Oracle NoSQL Database and Apache HBase.</p>
<p>To use the Oracle Big Data Spatial and Graph API, import the classes into your Java program:</p>
<pre dir="ltr">
import oracle.pg.nosql.*; // <span class="italic">or</span> oracle.pg.hbase.*
import oracle.pgx.config.*;
import oracle.pgx.common.types.*;
</pre>
<p>Also include <a href="using-pgs-bigdata.htm#GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C">TinkerPop Blueprints Java APIs</a>.</p>
<div class="infoboxnotealso" id="GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC__GUID-B72E4169-2009-49EC-9323-134FBD04D734">
<p class="notep1">See Also:</p>
<p>Oracle Big Data Spatial and Graph Java API Reference</p>
</div>
</div>
</div>
<a id="BDSPA214"></a>
<div class="props_rev_3"><a id="GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C"></a>
<h4 id="BDSPA-GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C" class="sect4"><span class="enumeration_section">4.4.1.2</span> TinkerPop Blueprints Java APIs</h4>
<div>
<p>TinkerPop Blueprints supports the property graph data model. The API provides utilities for manipulating graphs, which you use primarily through the Big Data Spatial and Graph data access layer Java APIs.</p>
<p>To use the Blueprints APIs, import the classes into your Java program:</p>
<pre dir="ltr">
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.Edge;
</pre>
<div class="infoboxnotealso" id="GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C__GUID-28679CB5-6802-4307-B590-E358E554C4B9">
<p class="notep1">See Also:</p>
<p>"Blueprints: A Property Graph Model Interface API" at</p>
<p><a href="http://www.tinkerpop.com/docs/javadocs/blueprints/2.3.0/index.html" target="_blank"><code>http://www.tinkerpop.com/docs/javadocs/blueprints/2.3.0/index.html</code></a></p>
</div>
</div>
</div>
<a id="BDSPA215"></a>
<div class="props_rev_3"><a id="GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57"></a>
<h4 id="BDSPA-GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57" class="sect4"><span class="enumeration_section">4.4.1.3</span> Apache Hadoop Java APIs</h4>
<div>
<p>The Apache Hadoop Java APIs enable you to write your Java code as a MapReduce program that runs within the Hadoop distributed framework.</p>
<p>To use the Hadoop Java APIs, import the classes into your Java program. For example:</p>
<pre dir="ltr">
import org.apache.hadoop.conf.Configuration;
</pre>
<div class="infoboxnotealso" id="GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57__GUID-68EAC838-16C3-432C-A7D8-61F54C9E0AC8">
<p class="notep1">See Also:</p>
<p>"Apache Hadoop Main 2.5.0-cdh5.3.2 API" at</p>
<p><a href="http://archive.cloudera.com/cdh5/cdh/5/hadoop/api/" target="_blank"><code>http://archive.cloudera.com/cdh5/cdh/5/hadoop/api/</code></a></p>
</div>
</div>
</div>
<a id="BDSPA216"></a>
<div class="props_rev_3"><a id="GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE"></a>
<h4 id="BDSPA-GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE" class="sect4"><span class="enumeration_section">4.4.1.4</span> Oracle NoSQL Database Java APIs</h4>
<div>
<p>The Oracle NoSQL Database APIs enable you to create and populate a key-value (KV) store, and provide interfaces to Hadoop, Hive, and Oracle NoSQL Database.</p>
<p>To use Oracle NoSQL Database as the graph data store, import the classes into your Java program. For example:</p>
<pre dir="ltr">
import oracle.kv.*; 
import oracle.kv.table.TableOperation;
</pre>
<div class="infoboxnotealso" id="GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE__GUID-9CD7E0FB-EA89-46F9-B645-01DA9C2D74E7">
<p class="notep1">See Also:</p>
<p>"Oracle NoSQL Database Java API Reference" at</p>
<p><a href="http://docs.oracle.com/cd/NOSQL/html/javadoc/" target="_blank"><code>http://docs.oracle.com/cd/NOSQL/html/javadoc/</code></a></p>
</div>
</div>
</div>
<a id="BDSPA217"></a>
<div class="props_rev_3"><a id="GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6"></a>
<h4 id="BDSPA-GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6" class="sect4"><span class="enumeration_section">4.4.1.5</span> Apache HBase Java APIs</h4>
<div>
<p>The Apache HBase APIs enable you to create and manipulate key-value pairs.</p>
<p>To use HBase as the graph data store, import the classes into your Java program. For example:</p>
<pre dir="ltr">
import org.apache.hadoop.hbase.*; 
import org.apache.hadoop.hbase.client.*;
import org.apache.hadoop.hbase.filter.*; 
import org.apache.hadoop.hbase.util.Bytes; 
import org.apache.hadoop.conf.Configuration; 
</pre>
<div class="infoboxnotealso" id="GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6__GUID-925DDFA4-97FF-4A9F-8C3E-AC17BBBA2FDE">
<p class="notep1">See Also:</p>
<p>"HBase 0.98.6-cdh5.3.2 API" at</p>
<p><a href="http://archive.cloudera.com/cdh5/cdh/5/hbase/apidocs/index.html?overview-summary.html" target="_blank"><code>http://archive.cloudera.com/cdh5/cdh/5/hbase/apidocs/index.html?overview-summary.html</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-EC851482-926D-4EB4-A922-ADEBF71C5611"></a>
<h3 id="BDSPA-GUID-EC851482-926D-4EB4-A922-ADEBF71C5611" class="sect3"><span class="enumeration_section">4.4.2</span> Parallel Loading of Graph Data</h3>
<div>
<p>A Java API is provided for performing parallel loading of graph data.</p>
<p>Given a set of vertex files (or input streams) and a set of edge files (or input streams), they can be split into multiple chunks and loaded into database in parallel. The number of chunks is determined by the degree of parallelism (DOP) specified by the user.</p>
<p>Parallelism is achieved with Splitter threads that split vertex and edge flat files into multiple chunks and Loader threads that load each chunk into the database using separate database connections. Java pipes are used to connect Splitter and Loader threads -- Splitter: <code>PipedOutputStream</code> and Loader: <code>PipedInputStream</code>.</p>
<p>The simplest usage of data loading API is specifying a property graph instance, one vertex file, one edge file, and a DOP.</p>
<p>The following example of the load process loads graph data stored in a vertices file and an edges file of the optimized Oracle flat file format, and executes the load with 48 degrees of parallelism.</p>
<pre dir="ltr">
opgdl = OraclePropertyGraphDataLoader.getInstance();
vfile = "../../data/connections.opv";
efile = "../../data/connections.ope";
opgdl.loadData(opg, vfile, efile, 48);
</pre></div>
<div class="props_rev_3"><a id="GUID-614C3D33-7CA0-488E-A78E-B18E78D4B272"></a>
<h4 id="BDSPA-GUID-614C3D33-7CA0-488E-A78E-B18E78D4B272" class="sect4"><span class="enumeration_section">4.4.2.1</span> Parallel Data Loading Using Partitions</h4>
<div>
<p>The data loading API allows loading the data into database using multiple partitions. This API requires the property graph, the vertex file, the edge file, the DOP, the total number of partitions, and the partition offset (from 0 to total number of partitions - 1). For example, to load the data using two partitions, the partition offsets should be 0 and 1. That is, there should be two data loading API calls to fully load the graph, and the only difference between the two API calls is the partition offset (0 and 1).</p>
<p>The following code fragment loads the graph data using 4 partitions. Each call to the data loader can be processed using a separate Java client, on a single system or from multiple systems.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

int totalPartitions = 4;
int dop= 32; // degree of parallelism for each client.

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
SimpleLogBasedDataLoaderListenerImpl dll = SimpleLogBasedDataLoaderListenerImpl.getInstance(100 /* frequency */,
                                       true /* Continue on error */);

// Run the data loading using 4 partitions (Each call can be run from a
// separate Java Client)

// Partition 1
OraclePropertyGraphDataLoader opgdlP1 = OraclePropertyGraphDataLoader.getInstance();
opgdlP1.<span class="bold">loadData(opg, szOPVFile, szOPEFile, dop,  
   4 /* Total number of partitions, default 1 */,
   0 /* Partition to load (from 0 to totalPartitions - 1, default 0 */,
   dll);
</span>
// Partition 2
OraclePropertyGraphDataLoader opgdlP2 = OraclePropertyGraphDataLoader.getInstance();
opgdlP2.loadData(opg, szOPVFile, szOPEFile, dop,  4 /* Total number of partitions, default 1 */,
 1 /* Partition to load (from 0 to totalPartitions - 1, default 0 */, dll);


// Partition 3
OraclePropertyGraphDataLoader opgdlP3 = OraclePropertyGraphDataLoader.getInstance();
opgdlP3.loadData(opg, szOPVFile, szOPEFile, dop,  4 /* Total number of partitions, default 1 */,
 2 /* Partition to load (from 0 to totalPartitions - 1, default 0 */, dll);

// Partition 4
OraclePropertyGraphDataLoader opgdlP4 = OraclePropertyGraphDataLoader.getInstance();
opgdlP4.loadData(opg, szOPVFile, szOPEFile, dop,  4 /* Total number of partitions, default 1 */,
 3 /* Partition to load (from 0 to totalPartitions - 1, default 0 */, dll);
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-45FA9E93-3E67-490D-ABDC-FB5B12BD0535"></a>
<h4 id="BDSPA-GUID-45FA9E93-3E67-490D-ABDC-FB5B12BD0535" class="sect4"><span class="enumeration_section">4.4.2.2</span> Parallel Data Loading Using Fine-Tuning</h4>
<div>
<p>Data loading APIs also support fine-tuning those lines in the source vertex and edges files that are to be loaded. You can specify the vertex (or edge) offset line number and vertex (or edge) maximum line number. Data will be loaded from the offset line number until the maximum line number. If the maximum line number is -1, the loading process will scan the data until reaching the end of file.</p>
<p>The following code fragment loads the graph data using fine-tuning.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

int totalPartitions = 4;
int dop= 32; // degree of parallelism for each client.

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
SimpleLogBasedDataLoaderListenerImpl dll = SimpleLogBasedDataLoaderListenerImpl.getInstance(100 /* frequency */,
                                       true /* Continue on error */);

// Run the data loading using fine tuning
long lVertexOffsetlines = 0;
long lEdgeOffsetLines = 0;
long lVertexMaxlines = 100;
long lEdgeMaxlines = 100;
int totalPartitions = 1;
int idPartition = 0;

OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
<span class="bold">opgdl.loadData(m_opg, szOPVFile, szOPEFile,
 lVertexOffsetlines /* offset of lines to start loading 
 from partition, default 0*/,
 lEdgeOffsetlines /* offset of lines to start loading 
 from partition, default 0*/,
 lVertexMaxlines /* maximum number of lines to start loading 
 from partition, default -1 (all lines in partition)*/,
 lEdgeMaxlines /* maximun number of lines to start loading 
 from partition, default -1 (all lines in partition)*/,
 dop,
 totalPartitions /* Total number of partitions, default 1 */,
 idPartition /* Partition to load (from 0 to totalPartitions - 1, 
 default 0 */,
 dll);
</span>
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-85A51A8F-2471-4D73-B256-2D28FFF57F05"></a>
<h4 id="BDSPA-GUID-85A51A8F-2471-4D73-B256-2D28FFF57F05" class="sect4"><span class="enumeration_section">4.4.2.3</span> Parallel Data Loading Using Multiple Files</h4>
<div>
<p>Oracle Big Data Spatial and Graph also support loading multiple vertex files and multiple edges files into database. The given multiple vertex files will be split into DOP chunks and loaded into database in parallel using DOP threads. Similarly, the multiple edge files will also be split and loaded in parallel.</p>
<p>The following code fragment loads multiple vertex fan and edge files using the parallel data loading APIs. In the example, two string arrays szOPVFiles and szOPEFiles are used to hold the input files; Although only one vertex file and one edge file is used in this example, you can supply multiple vertex files and multiple edge files in these two arrays.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

String[] szOPVFiles = new String[] {"../../data/connections.opv"};
String[] szOPEFiles = new String[] {"../../data/connections.ope"};

// Clear existing vertices/edges in the property graph 
opg.clearRepository();
opg.setQueueSize(100); // 100 elements

// This object will handle parallel data loading over the property graph
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();

<span class="bold">opgdl.loadData(opg, szOPVFiles, szOPEFiles, dop);
</span>
System.out.println("Total vertices: " + opg.countVertices());
System.out.println("Total edges: " + opg.countEdges());
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-A3BEAED2-37E2-47AC-B79F-ED327C8F0D20"></a>
<h4 id="BDSPA-GUID-A3BEAED2-37E2-47AC-B79F-ED327C8F0D20" class="sect4"><span class="enumeration_section">4.4.2.4</span> Parallel Retrieval of Graph Data</h4>
<div>
<p>The parallel property graph query provides a simple Java API to perform parallel scans on vertices (or edges). Parallel retrieval is an optimized solution taking advantage of the distribution of the data among splits with the back-end database, so each split is queried using separate database connections.</p>
<p>Parallel retrieval will produce an array where each element holds all the vertices (or edges) from a specific split. The subset of shards queried will be separated by the given start split ID and the size of the connections array provided. This way, the subset will consider splits in the range of [start, start - 1 + size of connections array]. Note that an integer ID (in the range of [0, N - 1]) is assigned to all the splits in the vertex table with N splits.</p>
<p>The following code loads a property graph using Apache HBase, opens an array of connections, and executes a parallel query to retrieve all vertices and edges using the opened connections. The number of calls to the <code>getVerticesPartitioned (getEdgesPartitioned)</code> method is controlled by the total number of splits and the number of connections used.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create connections used in parallel query
HConnection hConns= new HConnection[dop];
for (int i = 0; i &lt; dop; i++) { 
Configuration conf_new = 
HBaseConfiguration.create(opg.getConfiguration());
hConns[i] = HConnectionManager.createConnection(conf_new); 
}


long lCountV = 0;
// Iterate over all the vertices&rsquo; splits to count all the vertices
for (int split = 0; split &lt; opg.getVertexTableSplits(); 
 split += dop) { 
Iterable&lt;Vertex&gt;[] iterables 
 = <span class="bold">opg.getVerticesPartitioned(hConns /* Connection array */, 
 true /* skip store to cache */, 
 split /* starting split */);</span> 
lCountV += consumeIterables(iterables); /* consume iterables using 
 threads */
}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCountV);

long lCountE = 0;
// Iterate over all the edges&rsquo; splits to count all the edges
for (int split = 0; split &lt; opg.getEdgeTableSplits(); 
 split += dop) { 
Iterable&lt;Edge&gt;[] iterables 
 = <span class="bold">opg.getEdgesPartitioned(hConns /* Connection array */, 
 true /* skip store to cache */, 
 split /* starting split */);</span> 
lCountE += consumeIterables(iterables); /* consume iterables using 
 threads */
}

// Count all edges
System.out.println("Edges found using parallel query: " + lCountE);

// Close the connections to the database after completed
for (int idx = 0; idx &lt; hConns.length; idx++) { 
hConns[idx].close();
}
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-5141A57A-0BF5-4DAD-9645-C943DE11B55A"></a>
<h4 id="BDSPA-GUID-5141A57A-0BF5-4DAD-9645-C943DE11B55A" class="sect4"><span class="enumeration_section">4.4.2.5</span> Using an Element Filter Callback for Subgraph Extraction</h4>
<div>
<p>Oracle Big Data Spatial and Graph provides support for an easy subgraph extraction using user-defined element filter callbacks. An element filter callback defines a set of conditions that a vertex (or an edge) must meet in order to keep it in the subgraph. Users can define their own element filtering by implementing the <code>VertexFilterCallback</code> and <code>EdgeFilterCallback</code> API interfaces.</p>
<p>The following code fragment implements a <code>VertexFilterCallback</code> that validates if a vertex does not have a political role and its origin is the United States.</p>
<pre dir="ltr">
/**
* VertexFilterCallback to retrieve a vertex from the United States 
* that does not have a political role 
*/
private static class NonPoliticianFilterCallback 
implements VertexFilterCallback
{
@Override
public boolean keepVertex(OracleVertexBase vertex) 
{
String country = vertex.getProperty("country");
String role = vertex.getProperty("role");

if (country != null &amp;&amp; country.equals("United States")) {
if (role == null || !role.toLowerCase().contains("political")) {
return true;
}
}

return false;
}

public static NonPoliticianFilterCallback getInstance()
{
return new NonPoliticianFilterCallback();
}
}
</pre>
<p>The following code fragment implements an <code>EdgeFilterCallback</code> that uses the <code>VertexFilterCallback</code> to keep only edges connected to the given input vertex, and whose connections are not politicians and come from the United States.</p>
<pre dir="ltr">
/**
 * EdgeFilterCallback to retrieve all edges connected to an input 
 * vertex with "collaborates" label, and whose vertex is from the 
 * United States with a role different than political
*/
private static class CollaboratorsFilterCallback 
implements EdgeFilterCallback
{
private VertexFilterCallback m_vfc;
private Vertex m_startV;

public CollaboratorsFilterCallback(VertexFilterCallback vfc, 
 Vertex v) 
{
m_vfc = vfc;
m_startV = v; 
}

@Override
public boolean keepEdge(OracleEdgeBase edge) 
{
if ("collaborates".equals(edge.getLabel())) {
if (edge.getVertex(Direction.IN).equals(m_startV) &amp;&amp; 
m_vfc.keepVertex((OracleVertex) 
edge.getVertex(Direction.OUT))) {
return true;
}
else if (edge.getVertex(Direction.OUT).equals(m_startV) &amp;&amp; 
 m_vfc.keepVertex((OracleVertex) 
edge.getVertex(Direction.IN))) {
return true;
}
}

return false;
}

public static CollaboratorsFilterCallback
getInstance(VertexFilterCallback vfc, Vertex v)
{
return new CollaboratorsFilterCallback(vfc, v);
}

}
</pre>
<p>Using the filter callbacks previously defined, the following code fragment loads a property graph, creates an instance of the filter callbacks and later gets all of Barack Obama&rsquo;s collaborators who are not politicians and come from the United States.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// VertexFilterCallback to retrieve all people from the United States // who are not politicians
<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance();
</span>
// Initial vertex: Barack Obama
Vertex v = opg.getVertices("name", "Barack Obama").iterator().next();

// EdgeFilterCallback to retrieve all collaborators of Barack Obama 
// from the United States who are not politicians
<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance(npvfc, v);
</span>
Iterable&lt;&lt;Edge&gt; obamaCollabs = <span class="bold">opg.getEdges((String[])null /* Match any 
of the properties */,
cefc /* Match the 
EdgeFilterCallback */
);</span>
Iterator&lt;&lt;Edge&gt; iter = obamaCollabs.iterator();

System.out.println("\n\n--------Collaborators of Barack Obama from " +
 " the US and non-politician\n\n");
long countV = 0;
while (iter.hasNext()) {
Edge edge = iter.next(); // get the edge
// check if obama is the IN vertex
if (edge.getVertex(Direction.IN).equals(v)) {
 System.out.println(edge.getVertex(Direction.OUT) + "(Edge ID: " + 
 edge.getId() + ")"); // get out vertex
}
else {
System.out.println(edge.getVertex(Direction.IN)+ "(Edge ID: " + 
 edge.getId() + ")"); // get in vertex
}

countV++;
}
</pre>
<p>By default, all reading operations such as get all vertices, get all edges (and parallel approaches) will use the filter callbacks associated with the property graph using the methods <code>opg.setVertexFilterCallback(vfc)</code> and <code>opg.setEdgeFilterCallback(efc)</code>. If there is no filter callback set, then all the vertices (or edges) and edges will be retrieved.</p>
<p>The following code fragment uses the default edge filter callback set on the property graph to retrieve the edges.</p>
<pre dir="ltr">
// VertexFilterCallback to retrieve all people from the United States // who are not politicians
<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance();
</span>
// Initial vertex: Barack Obama
Vertex v = opg.getVertices("name", "Barack Obama").iterator().next();

// EdgeFilterCallback to retrieve all collaborators of Barack Obama 
// from the United States who are not politicians
<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance(npvfc, v);

opg.setEdgeFilterCallback(cefc);
</span>
Iterable&lt;Edge&gt; obamaCollabs = <span class="bold">opg.getEdges()</span>;
Iterator&lt;Edge&gt; iter = obamaCollabs.iterator();

System.out.println("\n\n--------Collaborators of Barack Obama from " +
 " the US and non-politician\n\n");
long countV = 0;
while (iter.hasNext()) {
Edge edge = iter.next(); // get the edge
// check if obama is the IN vertex
if (edge.getVertex(Direction.IN).equals(v)) {
 System.out.println(edge.getVertex(Direction.OUT) + "(Edge ID: " + 
 edge.getId() + ")"); // get out vertex
}
else {
System.out.println(edge.getVertex(Direction.IN)+ "(Edge ID: " + 
 edge.getId() + ")"); // get in vertex
}

countV++;
}
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-ABB127C9-72BB-47FD-879C-907E481BA9E9"></a>
<h4 id="BDSPA-GUID-ABB127C9-72BB-47FD-879C-907E481BA9E9" class="sect4"><span class="enumeration_section">4.4.2.6</span> Using Optimization Flags on Reads over Property Graph Data</h4>
<div>
<p>Oracle Big Data Spatial and Graph provides support for optimization flags to improve graph iteration performance. Optimization flags allow processing vertices (or edges) as objects with none or minimal information, such as ID, label, and/or incoming/outgoing vertices. This way, the time required to process each vertex (or edge) during iteration is reduced.</p>
<p>The following table shows the optimization flags available when processing vertices (or edges) in a property graph.</p>
<div class="tblformal" id="GUID-ABB127C9-72BB-47FD-879C-907E481BA9E9__GUID-8179E09D-40E2-4274-9640-83A20BD52781">
<table class="cellalignment342" summary="Optimization flags and descriptions for processing vertices (or edges) in a property graph">
<tbody>
<tr>
<td class="cellalignment343" id="d17953e1912">Optimization Flag</td>
<td class="cellalignment343" headers="d17953e1912">Description</td>
</tr>
<tr>
<td class="cellalignment343" id="d17953e1917">DO_NOT_CREATE_OBJECT</td>
<td class="cellalignment343" headers="d17953e1917">Use a predefined constant object when processing vertices or edges.</td>
</tr>
<tr>
<td class="cellalignment343" id="d17953e1922">JUST_EDGE_ID</td>
<td class="cellalignment343" headers="d17953e1922">Construct edge objects with ID only when processing edges.</td>
</tr>
<tr>
<td class="cellalignment343" id="d17953e1927">JUST_LABEL_EDGE_ID</td>
<td class="cellalignment343" headers="d17953e1927">Construct edge objects with ID and label only when processing edges.</td>
</tr>
<tr>
<td class="cellalignment343" id="d17953e1932">JUST_LABEL_VERTEX_EDGE_ID</td>
<td class="cellalignment343" headers="d17953e1932">Construct edge objects with ID, label, and in/out vertex IDs only when processing edges</td>
</tr>
<tr>
<td class="cellalignment343" id="d17953e1937">JUST_VERTEX_EDGE_ID</td>
<td class="cellalignment343" headers="d17953e1937">Construct edge objects with just ID and in/out vertex IDs when processing edges.</td>
</tr>
<tr>
<td class="cellalignment343" id="d17953e1942">JUST_VERTEX_ID</td>
<td class="cellalignment343" headers="d17953e1942">Construct vertex objects with ID only when processing vertices.</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The following code fragment uses a set of optimization flags to retrieve only all the IDs from the vertices and edges in the property graph. The objects retrieved by reading all vertices and edges will include only the IDs and no Key/Value properties or additional information.</p>
<pre dir="ltr">
import oracle.pg.common.OraclePropertyGraphBase.OptimizationFlag;
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 


// Optimization flag to retrieve only vertices IDs
<span class="bold">OptimizationFlag optFlagVertex = OptimizationFlag.JUST_VERTEX_ID;
</span>
// Optimization flag to retrieve only edges IDs
<span class="bold">OptimizationFlag optFlagEdge = OptimizationFlag.JUST_EDGE_ID;
</span>
// Print all vertices
Iterator&lt;Vertex&gt; vertices = 
<span class="bold">opg.getVertices((String[])null /* Match any of the 
properties */,
null /* Match the VertexFilterCallback */, 
optFlagVertex /* optimization flag */ 
).iterator();
</span>
System.out.println("----- Vertices IDs----");
long vCount = 0;
while (vertices.hasNext()) {
OracleVertex v = vertices.next();
System.out.println((Long) v.getId());
vCount++;
}
System.out.println("Vertices found: " + vCount);


// Print all edges
Iterator&lt;Edge&gt; edges =
<span class="bold">opg.getEdges((String[])null /* Match any of the properties */,
null /* Match the EdgeFilterCallback */, 
optFlagEdge /* optimization flag */ 
).iterator();
</span>
System.out.println("----- Edges ----");
long eCount = 0;
while (edges.hasNext()) {
Edge e = edges.next();
System.out.println((Long) e.getId());
eCount++;
}
System.out.println("Edges found: " + eCount);
</pre>
<p>By default, all reading operations such as get all vertices, get all edges (and parallel approaches) will use the optimization flag associated with the property graph using the method <code>opg.setDefaultVertexOptFlag(optFlagVertex)</code> and <code>opg.setDefaultEdgeOptFlag(optFlagEdge)</code>. If the optimization flags for processing vertices and edges are not defined, then all the information about the vertices and edges will be retrieved.</p>
<p>The following code fragment uses the default optimization flags set on the property graph to retrieve only all the IDs from its vertices and edges.</p>
<pre dir="ltr">
import oracle.pg.common.OraclePropertyGraphBase.OptimizationFlag;

// Optimization flag to retrieve only vertices IDs
OptimizationFlag optFlagVertex = OptimizationFlag.JUST_VERTEX_ID;

// Optimization flag to retrieve only edges IDs
OptimizationFlag optFlagEdge = OptimizationFlag.JUST_EDGE_ID;

<span class="bold">opg.setDefaultVertexOptFlag(optFlagVertex);
opg.setDefaultEdgeOptFlag(optFlagEdge);
</span>
Iterator&lt;Vertex&gt; vertices = <span class="bold">opg.getVertices().iterator();</span>
System.out.println("----- Vertices IDs----");
long vCount = 0;
while (vertices.hasNext()) {
OracleVertex v = vertices.next();
System.out.println((Long) v.getId());
vCount++;
}
System.out.println("Vertices found: " + vCount);


// Print all edges
Iterator&lt;Edge&gt; edges = <span class="bold">opg.getEdges().iterator();
</span>System.out.println("----- Edges ----");
long eCount = 0;
while (edges.hasNext()) {
Edge e = edges.next();
System.out.println((Long) e.getId());
eCount++;
}
System.out.println("Edges found: " + eCount);
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-1DF4100F-F4D4-480A-8DDD-1454645857E3"></a>
<h4 id="BDSPA-GUID-1DF4100F-F4D4-480A-8DDD-1454645857E3" class="sect4"><span class="enumeration_section">4.4.2.7</span> Adding and Removing Attributes of a Property Graph Subgraph</h4>
<div>
<p>Oracle Big Data Spatial and Graph supports updating attributes (key/value pairs) to a subgraph of vertices and/or edges by using a user-customized operation callback. An operation callback defines a set of conditions that a vertex (or an edge) must meet in order to update it (either add or remove the given attribute and value).</p>
<p>You can define your own attribute operations by implementing the <code>VertexOpCallback</code> and <code>EdgeOpCallback</code> API interfaces. You must override the <code>needOp</code> method, which defines the conditions to be satisfied by the vertices (or edges) to be included in the update operation, as well as the <code>getAttributeKeyName</code> and <code>getAttributeKeyValue</code> methods, which return the key name and value, respectively, to be used when updating the elements.</p>
<p>The following code fragment implements a <code>VertexOpCallback</code> that operates over the <code>obamaCollaborator</code> attribute associated only with Barack Obama collaborators. The value of this property is specified based on the role of the collaborators.</p>
<pre dir="ltr">
private static class CollaboratorsVertexOpCallback 
<span class="bold">implements VertexOpCallback</span>
{
private OracleVertexBase m_obama;
private List&lt;Vertex&gt; m_obamaCollaborators;

public CollaboratorsVertexOpCallback(OraclePropertyGraph opg)
{
// Get a list of Barack Obama'sCollaborators
m_obama = (OracleVertexBase) opg.getVertices("name", 
 "Barack Obama")
.iterator().next();

Iterable&lt;Vertex&gt; iter = m_obama.getVertices(Direction.BOTH, 
"collaborates");
m_obamaCollaborators = OraclePropertyGraphUtils.listify(iter);
}

public static CollaboratorsVertexOpCallback 
getInstance(OraclePropertyGraph opg)
{
return new CollaboratorsVertexOpCallback(opg);
}

/**
 * Add attribute if and only if the vertex is a collaborator of Barack 
 * Obama
*/
@Override
public boolean <span class="bold">needOp(OracleVertexBase v)</span>
{
return m_obamaCollaborators != null &amp;&amp; 
 m_obamaCollaborators.contains(v);
}

@Override
public String <span class="bold">getAttributeKeyName(OracleVertexBase v)</span>
{
return "obamaCollaborator";
}

/**
 * Define the property's value based on the vertex role
 */
@Override
public Object <span class="bold">getAttributeKeyValue(OracleVertexBase v)</span>
{
String role = v.getProperty("role");
role = role.toLowerCase();
if (role.contains("political")) {
return "political";
}
else if (role.contains("actor") || role.contains("singer") ||
 role.contains("actress") || role.contains("writer") ||
 role.contains("producer") || role.contains("director")) {
return "arts";
}
else if (role.contains("player")) {
return "sports";
}
else if (role.contains("journalist")) {
return "journalism";
}
else if (role.contains("business") || role.contains("economist")) {
return "business";
}
else if (role.contains("philanthropist")) {
return "philanthropy";
}
return " ";
}
}
</pre>
<p>The following code fragment implements an <code>EdgeOpCallback</code> that operates over the <code>obamaFeud</code> attribute associated only with Barack Obama feuds. The value of this property is specified based on the role of the collaborators.</p>
<pre dir="ltr">
private static class FeudsEdgeOpCallback 
<span class="bold">implements EdgeOpCallback</span>
{
private OracleVertexBase m_obama;
private List&lt;Edge&gt; m_obamaFeuds;

public FeudsEdgeOpCallback(OraclePropertyGraph opg)
{
// Get a list of Barack Obama's feuds
m_obama = (OracleVertexBase) opg.getVertices("name", 
 "Barack Obama")
.iterator().next();

Iterable&lt;Vertex&gt; iter = m_obama.getVertices(Direction.BOTH, 
"feuds");
m_obamaFeuds = OraclePropertyGraphUtils.listify(iter);
}

public static FeudsEdgeOpCallback getInstance(OraclePropertyGraph opg)
{
return new FeudsEdgeOpCallback(opg);
}

/**
 * Add attribute if and only if the edge is in the list of Barack Obama's 
 * feuds
*/
@Override
public boolean <span class="bold">needOp(OracleEdgeBase e)</span>
{
return m_obamaFeuds != null &amp;&amp; m_obamaFeuds.contains(e);
}

@Override
public String <span class="bold">getAttributeKeyName(OracleEdgeBase e)</span>
{
return "obamaFeud";
}

/**
 * Define the property's value based on the in/out vertex role
 */
@Override
public Object <span class="bold">getAttributeKeyValue(OracleEdgeBase e)</span>
{
OracleVertexBase v = (OracleVertexBase) e.getVertex(Direction.IN);
if (m_obama.equals(v)) {
v = (OracleVertexBase) e.getVertex(Direction.OUT);
}
String role = v.getProperty("role");
role = role.toLowerCase();

if (role.contains("political")) {
return "political";
}
else if (role.contains("actor") || role.contains("singer") ||
 role.contains("actress") || role.contains("writer") ||
 role.contains("producer") || role.contains("director")) {
return "arts";
}
else if (role.contains("journalist")) {
return "journalism";
}
else if (role.contains("player")) {
return "sports";
}
else if (role.contains("business") || role.contains("economist")) {
return "business";
}
else if (role.contains("philanthropist")) {
return "philanthropy";
}
return " ";
}
}
</pre>
<p>Using the operations callbacks defined previously, the following code fragment loads a property graph, creates an instance of the operation callbacks, and later adds the attributes into the pertinent vertices and edges using the <code>addAttributeToAllVertices</code> and <code>addAttributeToAllEdges</code> methods in <code>OraclePropertyGraph</code>.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create the vertex operation callback
<span class="bold">CollaboratorsVertexOpCallback cvoc = CollaboratorsVertexOpCallback.getInstance(opg);</span>

// Add attribute to all people collaborating with Obama based on their role
<span class="bold">opg.addAttributeToAllVertices(cvoc, true /** Skip store to Cache */, dop);</span>

// Look up for all collaborators of Obama
Iterable&lt;Vertex&gt; collaborators = opg.getVertices("obamaCollaborator", "political");
System.out.println("Political collaborators of Barack Obama " + getVerticesAsString(collaborators));

collaborators = opg.getVertices("obamaCollaborator", "business");
System.out.println("Business collaborators of Barack Obama " + 
getVerticesAsString(collaborators));

// Add an attribute to all people having a feud with Barack Obama to set
// the type of relation they have
<span class="bold">FeudsEdgeOpCallback feoc = FeudsEdgeOpCallback.getInstance(opg);
opg.addAttributeToAllEdges(feoc, true /** Skip store to Cache */, dop);</span>

// Look up for all feuds of Obama
Iterable&lt;Edge&gt; feuds = opg.getEdges("obamaFeud", "political");
System.out.println("\n\nPolitical feuds of Barack Obama " + getEdgesAsString(feuds));

feuds = opg.getEdges("obamaFeud", "business");
System.out.println("Business feuds of Barack Obama " + 
getEdgesAsString(feuds));
</pre>
<p>The following code fragment defines an implementation of <code>VertexOpCallback</code> that can be used to remove vertices having value philanthropy for attribute <code>obamaCollaborator</code>, then call the API <code>removeAttributeFromAllVertices</code>; It also defines an implementation of <code>EdgeOpCallback</code> that can be used to remove edges having value business for attribute <code>obamaFeud</code>, then call the API <code>removeAttributeFromAllEdges</code>.</p>
<pre dir="ltr">
System.out.println("\n\nRemove 'obamaCollaborator' property from all the" + 
 "philanthropy collaborators");
PhilanthropyCollaboratorsVertexOpCallback pvoc = PhilanthropyCollaboratorsVertexOpCallback.getInstance();

<span class="bold">opg.removeAttributeFromAllVertices(pvoc);</span>

System.out.println("\n\nRemove 'obamaFeud' property from all the" + "business feuds");
BusinessFeudsEdgeOpCallback beoc = BusinessFeudsEdgeOpCallback.getInstance();

<span class="bold">opg.removeAttributeFromAllEdges(beoc);</span>

/**
 * Implementation of a EdgeOpCallback to remove the "obamaCollaborators" 
 * property from all people collaborating with Barack Obama that have a 
 * philanthropy role
 */
private static class PhilanthropyCollaboratorsVertexOpCallback implements VertexOpCallback
{
  public static PhilanthropyCollaboratorsVertexOpCallback getInstance()
  {
     return new PhilanthropyCollaboratorsVertexOpCallback();
  }
  
  /**
   * Remove attribute if and only if the property value for   
   * obamaCollaborator is Philanthropy
   */
  @Override
  public boolean needOp(OracleVertexBase v)
  {
    String type = v.getProperty("obamaCollaborator");
    return type != null &amp;&amp; type.equals("philanthropy");
  }

  @Override
  public String getAttributeKeyName(OracleVertexBase v)
  {
    return "obamaCollaborator";
  }

  /**
   * Define the property's value. In this case can be empty
   */
  @Override
  public Object getAttributeKeyValue(OracleVertexBase v)
  {
    return " ";
  }
}

/**
 * Implementation of a EdgeOpCallback to remove the "obamaFeud" property
 * from all connections in a feud with Barack Obama that have a business role
 */
private static class BusinessFeudsEdgeOpCallback implements EdgeOpCallback
{
  public static BusinessFeudsEdgeOpCallback getInstance()
  {
    return new BusinessFeudsEdgeOpCallback();
  }

  /**
   * Remove attribute if and only if the property value for obamaFeud is       
   * business
   */
  @Override
  public boolean needOp(OracleEdgeBase e)
  {
    String type = e.getProperty("obamaFeud");
    return type != null &amp;&amp; type.equals("business");
  }

 @Override
 public String getAttributeKeyName(OracleEdgeBase e)
 {
   return "obamaFeud";
 }

 /**
  * Define the property's value. In this case can be empty
  */
  @Override
  public Object getAttributeKeyValue(OracleEdgeBase e)
  {
    return " ";
  }
}
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-DE1C0716-45F4-4396-BE5E-A23AC8104296"></a>
<h4 id="BDSPA-GUID-DE1C0716-45F4-4396-BE5E-A23AC8104296" class="sect4"><span class="enumeration_section">4.4.2.8</span> Getting Property Graph Metadata</h4>
<div>
<p>You can get graph metadata and statistics, such as all graph names in the database; for each graph, getting the minimum/maximum vertex ID, the minimum/maximum edge ID, vertex property names, edge property names, number of splits in graph vertex, and the edge table that supports parallel table scans.</p>
<p>The following code fragment gets the metadata and statistics of the existing property graphs stored in the back-end database (either Oracle NoSQL Database or Apache HBase). The arguments required vary for each database.</p>
<pre dir="ltr">
// Get all graph names in the database
List&lt;String&gt; graphNames = OraclePropertyGraphUtils.getGraphNames(dbArgs);

for (String graphName : graphNames) {
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args, 
graphName);

System.err.println("\n Graph name: " + graphName);
System.err.println(" Total vertices: " + 
 <span class="bold">opg.countVertices(dop)</span>);
 
System.err.println(" Minimum Vertex ID: " + 
 <span class="bold">opg.getMinVertexID(dop)</span>);
System.err.println(" Maximum Vertex ID: " + 
 <span class="bold">opg.getMaxVertexID(dop)</span>);

Set&lt;String&gt; propertyNamesV = new HashSet&lt;String&gt;();
<span class="bold">opg.getVertexPropertyNames(dop, 0 /* timeout,0 no timeout */,
 propertyNamesV);</span>

System.err.println(" Vertices property names: " + 
getPropertyNamesAsString(propertyNamesV));

System.err.println("\n\n Total edges: " + <span class="bold">opg.countEdges(dop)</span>);
System.err.println(" Minimum Edge ID: " + <span class="bold">opg.getMinEdgeID(dop)</span>);
System.err.println(" Maximum Edge ID: " + <span class="bold">opg.getMaxEdgeID(dop)</span>);

Set&lt;String&gt; propertyNamesE = new HashSet&lt;String&gt;();
<span class="bold">opg.getEdgePropertyNames(dop, 0 /* timeout,0 no timeout */, 
 propertyNamesE);</span>

System.err.println(" Edge property names: " +
getPropertyNamesAsString(propertyNamesE));

System.err.println("\n\n Table Information: ");
System.err.println("Vertex table number of splits: " + 
 (<span class="bold">opg.getVertexTableSplits()</span>));
System.err.println("Edge table number of splits: " + 
 (<span class="bold">opg.getEdgeTableSplits()</span>));
}
</pre></div>
</div>
</div>
<a id="BDSPA218"></a>
<div class="props_rev_3"><a id="GUID-A25C4F9E-E84D-4585-AF70-CE244F8AB547"></a>
<h3 id="BDSPA-GUID-A25C4F9E-E84D-4585-AF70-CE244F8AB547" class="sect3"><span class="enumeration_section">4.4.3</span> Opening and Closing a Property Graph Instance</h3>
<div>
<p>When describing a property graph, use these Oracle Property Graph classes to open and close the property graph instance properly:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>OraclePropertyGraph.getInstance</code>: Opens an instance of an Oracle property graph. This method has two parameters, the connection information and the graph name. The format of the connection information depends on whether you use HBase or Oracle NoSQL Database as the backend database.</p>
</li>
<li>
<p><code>OraclePropertyGraph.clearRepository</code>: Removes all vertices and edges from the property graph instance.</p>
</li>
<li>
<p><code>OraclePropertyGraph.shutdown</code>: Closes the graph instance.</p>
</li>
</ul>
<p>In addition, you must use the appropriate classes from the Oracle NoSQL Database or HBase APIs.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-24BD2A9F-DCB9-4CCB-ADC6-6C0F59037BE6">Using Oracle NoSQL Database</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-D11C4646-7854-4647-B046-339FFA11788D">Using Apache HBase</a></p>
</li>
</ul>
</div>
<a id="BDSPA219"></a>
<div class="props_rev_3"><a id="GUID-24BD2A9F-DCB9-4CCB-ADC6-6C0F59037BE6"></a>
<h4 id="BDSPA-GUID-24BD2A9F-DCB9-4CCB-ADC6-6C0F59037BE6" class="sect4"><span class="enumeration_section">4.4.3.1</span> Using Oracle NoSQL Database</h4>
<div>
<p>For Oracle NoSQL Database, the <code>OraclePropertyGraph.getInstance</code> method uses the KV store name, host computer name, and port number for the connection:</p>
<pre dir="ltr">
String kvHostPort = "cluster02:5000";
String kvStoreName = "kvstore";
String kvGraphName = "my_graph";

// Use NoSQL Java API
KVStoreConfig kvconfig = new KVStoreConfig(kvStoreName, kvHostPort);

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(kvconfig, kvGraphName);
opg.clearRepository(); 
//     .
//     .  Graph description
//     .
// Close the graph instance
opg.shutdown();
</pre>
<p>If the in-memory analyst functions are required for your application, then it is recommended that you use <code>GraphConfigBuilder</code> to create a graph <code>config</code> for Oracle NoSQL Database, and instantiates <code>OraclePropertyGraph</code> with the <code>config</code> as an argument.</p>
<p>As an example, the following code snippet constructs a graph <code>config</code>, gets an <code>OraclePropertyGraph</code> instance, loads some data into that graph, and gets an in-memory analyst.</p>
<pre dir="ltr">
  import oracle.pgx.config.*;
  import oracle.pgx.api.*;
  import oracle.pgx.common.types.*;

    ...
 
    String[] hhosts = new String[1];
    hhosts[0]          = "my_host_name:5000"; // need customization
    String szStoreName =  "kvstore";          // need customization
    String szGraphName = "my_graph";
    int dop            =  8;
 
    PgNosqlGraphConfig cfg = GraphConfigBuilder.forPropertyGraphNosql()
                                                     .setName(szGraphName)
                                                     .setHosts(Arrays.asList(hhosts))
                                                     .setStoreName(szStoreName)
                                                     .addEdgeProperty("lbl", PropertyType.STRING, "lbl")
                                                     .addEdgeProperty("weight", PropertyType.DOUBLE, "1000000")
                                                     .build();
 
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance(cfg);  
 
    String szOPVFile = "../../data/connections.opv";
    String szOPEFile = "../../data/connections.ope";
 
    // perform a parallel data load
    OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
    opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
 
    ...
    PgxSession session = Pgx.createSession("session-id-1");
    PgxGraph g = session.readGraphWithProperties(cfg);

    Analyst analyst = session.createAnalyst();
    ...
</pre></div>
</div>
<a id="BDSPA220"></a>
<div class="props_rev_3"><a id="GUID-D11C4646-7854-4647-B046-339FFA11788D"></a>
<h4 id="BDSPA-GUID-D11C4646-7854-4647-B046-339FFA11788D" class="sect4"><span class="enumeration_section">4.4.3.2</span> Using Apache HBase</h4>
<div>
<p>For Apache HBase, the <code>OraclePropertyGraph.getInstance</code> method uses the Hadoop nodes and the Apache HBase port number for the connection:</p>
<pre dir="ltr">
String hbQuorum = "bda01node01.example.com, bda01node02.example.com, bda01node03.example.com";
String hbClientPort = "2181"
String hbGraphName = "my_graph";
 
// Use HBase Java APIs
Configuration conf = HBaseConfiguration.create();
  conf.set("hbase.zookeeper.quorum", hbQuorum);
  conf.set("hbase.zookeper.property.clientPort", hbClientPort);
HConnection conn = HConnectionManager.createConnection(conf);
 
// Open the property graph
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(conf, conn, hbGraphName);
opg.clearRepository(); 
//     .
//     .  Graph description
//     .
// Close the graph instance
opg.shutdown();
// Close the HBase connection
conn.close();
</pre>
<p>If the in-memory analyst functions are required for your application, then it is recommended that you use <code>GraphConfigBuilder</code> to create a graph <code>config</code>, and instantiates <code>OraclePropertyGraph</code> with the <code>config</code> as an argument.</p>
<p>As an example, the following code snippet sets the configuration for in memory analytics, constructs a graph config for Apache HBase, instantiates an <code>OraclePropertyGraph</code> instance, gets an in-memory analyst, and counts the number of triangles in the graph.</p>
<pre dir="ltr">
    confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;(); 
    confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false); 
    confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop + 2); 
    confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, 8); // &lt;= # of physical cores 
    confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2); 
    confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);// no timeout set 
    confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);  // no timeout set 
    ServerInstance instance = Pgx.getInstance();
    instance.startEngine(confPgx); 
 
int iClientPort = Integer.parseInt(hbClientPort);
int splitsPerRegion = 2;
 
PgHbaseGraphConfig cfg = GraphConfigBuilder.forPropertyGraphHbase()
                           .setName(hbGraphName)
                           .setZkQuorum(hbQuorum)
                           .setZkClientPort(iClientPort)
                           .setZkSessionTimeout(60000)
                           .setMaxNumConnections(dop)
                           .setSplitsPerRegion(splitsPerRegion)
                           .addEdgeProperty("lbl", PropertyType.STRING, "lbl")
                           .addEdgeProperty("weight", PropertyType.DOUBLE, "1000000")
                           .build();

PgxSession session = Pgx.createSession("session-id-1");
PgxGraph g = session.readGraphWithProperties(cfg);
Analyst analyst = session.createAnalyst();

long triangles = analyst.countTriangles(g, false);
</pre></div>
</div>
</div>
<a id="BDSPA221"></a>
<div class="props_rev_3"><a id="GUID-E0DAB9AE-5962-41AF-9B73-F390AF6189DC"></a>
<h3 id="BDSPA-GUID-E0DAB9AE-5962-41AF-9B73-F390AF6189DC" class="sect3"><span class="enumeration_section">4.4.4</span> Creating the Vertices</h3>
<div>
<p>To create a vertex, use these Oracle Property Graph methods:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>OraclePropertyGraph.addVertex</code>: Adds a vertex instance to a graph.</p>
</li>
<li>
<p><code>OracleVertex.setProperty</code>: Assigns a key-value property to a vertex.</p>
</li>
<li>
<p><code>OraclePropertyGraph.commit</code>: Saves all changes to the property graph instance.</p>
</li>
</ul>
<p>The following code fragment creates two vertices named <code>V1</code> and <code>V2</code>, with properties for age, name, weight, height, and sex in the <code>opg</code> property graph instance. The <code>v1</code> properties set the data types explicitly.</p>
<pre dir="ltr">
// Create vertex v1 and assign it properties as key-value pairs
Vertex v1 = opg.addVertex(1l);
  v1.setProperty("age",  Integer.valueOf(31));
  v1.setProperty("name", "Alice");
  v1.setProperty("weight", Float.valueOf(135.0f));
  v1.setProperty("height", Double.valueOf(64.5d));
  v1.setProperty("female", Boolean.TRUE);
  
Vertex v2 = opg.addVertex(2l);
  v2.setProperty("age",  27);
  v2.setProperty("name", "Bob");
  v2.setProperty("weight", Float.valueOf(156.0f));
  v2.setProperty("height", Double.valueOf(69.5d));
  v2.setProperty("female", Boolean.FALSE); 
</pre></div>
</div>
<a id="BDSPA222"></a>
<div class="props_rev_3"><a id="GUID-B29900B4-6D97-41EF-B863-0CF17196234F"></a>
<h3 id="BDSPA-GUID-B29900B4-6D97-41EF-B863-0CF17196234F" class="sect3"><span class="enumeration_section">4.4.5</span> Creating the Edges</h3>
<div>
<p>To create an edge, use these Oracle Property Graph methods:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>OraclePropertyGraph.addEdge</code>: Adds an edge instance to a graph.</p>
</li>
<li>
<p><code>OracleEdge.setProperty</code>: Assigns a key-value property to an edge.</p>
</li>
</ul>
<p>The following code fragment creates two vertices (<code>v1</code> and <code>v2</code>) and one edge (<code>e1</code>).</p>
<pre dir="ltr">
// Add vertices v1 and v2
Vertex v1 = opg.addVertex(1l);
v1.setProperty("name", "Alice");
v1.setProperty("age", 31);

Vertex v2 = opg.addVertex(2l);  
v2.setProperty("name", "Bob");
v2.setProperty("age", 27);

// Add edge e1
Edge e1 = opg.addEdge(1l, v1, v2, "knows");
e1.setProperty("type", "friends");
</pre></div>
</div>
<a id="BDSPA223"></a>
<div class="props_rev_3"><a id="GUID-BFD2302B-C94B-47BC-A1AE-1BE4459BBBDD"></a>
<h3 id="BDSPA-GUID-BFD2302B-C94B-47BC-A1AE-1BE4459BBBDD" class="sect3"><span class="enumeration_section">4.4.6</span> Deleting the Vertices and Edges</h3>
<div>
<p>You can remove vertex and edge instances individually, or all of them simultaneously. Use these methods:</p>
<ul style="list-style-type: disc;">
<li>
<p><code>OraclePropertyGraph.removeEdge</code>: Removes the specified edge from the graph.</p>
</li>
<li>
<p><code>OraclePropertyGraph.removeVertex</code>: Removes the specified vertex from the graph.</p>
</li>
<li>
<p><code>OraclePropertyGraph.clearRepository</code>: Removes all vertices and edges from the property graph instance.</p>
</li>
</ul>
<p>The following code fragment removes edge <code>e1</code> and vertex <code>v1</code> from the graph instance. The adjacent edges will also be deleted from the graph when removing a vertex. This is because every edge must have an beginning and ending vertex. After removing the beginning or ending vertex, the edge is no longer a valid edge.</p>
<pre dir="ltr">
// Remove edge e1
opg.removeEdge(e1);

// Remove vertex v1
opg.removeVertex(v1);
</pre>
<p>The <code>OraclePropertyGraph.clearRepository</code> method can be used to remove all contents from an <code>OraclePropertyGraph</code> instance. However, use it with care because this action cannot be reversed.</p>
</div>
</div>
<div class="props_rev_3"><a id="GUID-64E7B0BF-315E-45CE-ACD5-2566B33A7501"></a>
<h3 id="BDSPA-GUID-64E7B0BF-315E-45CE-ACD5-2566B33A7501" class="sect3"><span class="enumeration_section">4.4.7</span> Reading a Graph from a Database into an Embedded In-Memory Analyst</h3>
<div>
<p>You can read a graph from Apache HBase or Oracle NoSQL Database into an in-memory analyst that is embedded in the same client Java application (a single JVM). For the following Apache HBase example:</p>
<ul style="list-style-type: disc;">
<li>
<p>A correct <code>java.io.tmpdir</code> setting is required.</p>
</li>
<li>
<p><code>dop + 2</code> is a workaround for a performance issue before Release 1.1.2. Effective with Release 1.1.2, you can instead specify a <code>dop</code> value directly in the configuration settings.</p>
</li>
</ul>
<pre dir="ltr">
int dop = 8;                    // need customization
Map&lt;PgxConfig.Field, Object&gt; confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;();
confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false);
confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop + 2);   // use dop directly with release 1.1.2 or newer
confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, dop); // &lt;= # of physical cores
confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2);
confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);  // no timeout set
confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);  // no timeout set

PgHbaseGraphConfig cfg = GraphConfigBuilder.forPropertyGraphHbase()
                          .setName("mygraph")
                          .setZkQuorum("localhost") // quorum, need customization
                          .setZkClientPort(2181)
                          .addNodeProperty("name", PropertyType.STRING, "default_name")
                          .build();

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(cfg);
ServerInstance localInstance = Pgx.getInstance();
localInstance.startEngine(confPgx);
PgxSession session = localInstance.createSession("session-id-1"); // Put your session description here.

Analyst analyst = session.createAnalyst();

// The following call will trigger a read of graph data from the database
PgxGraph pgxGraph = session.readGraphWithProperties(opg.getConfig());

long triangles = analyst.countTriangles(pgxGraph, false);
System.out.println("triangles " + triangles);

// Remove edge e1
opg.removeEdge(e1);

// Remove vertex v1
opg.removeVertex(v1);
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-ECB7B9A0-038B-451A-AAAB-9F8815AE2602"></a>
<h3 id="BDSPA-GUID-ECB7B9A0-038B-451A-AAAB-9F8815AE2602" class="sect3"><span class="enumeration_section">4.4.8</span> Building an In-Memory Graph</h3>
<div>
<p>In addition to <a href="using-inmem-analytics.htm#GUID-147E545D-CB0B-479A-8D7F-D36CF2064A45">Reading Graph Data into Memory</a>, you can create an in-memory graph programmatically. This can simplify development when the size of graph is small or when the content of the graph is highly dynamic. The key Java class is <code>GraphBuilder</code>, which can accumulate a set of vertices and edges added with the <code>addVertex</code> and <code>addEdge</code> APIs. After all changes are made, an in-memory graph instance (<code>PgxGraph</code>) can be created by the <code>GraphBuilder</code>.</p>
<p>The following Java code snippet illustrates a graph construction flow. Note that there are no explicit calls to <code>addVertex</code>, because any vertex that does not already exist will be added dynamically as its adjacent edges are created.</p>
<pre dir="ltr">
import oracle.pgx.api.*;

PgxSession session = Pgx.createSession("example");
GraphBuilder&lt;Integer&gt; builder = session.newGraphBuilder();

builder.addEdge(0, 1, 2);
builder.addEdge(1, 2, 3);
builder.addEdge(2, 2, 4);
builder.addEdge(3, 3, 4);
builder.addEdge(4, 4, 2);

PgxGraph graph = builder.build();
</pre>
<p>To construct a graph with vertex properties, you can use <code>setProperty</code> against the vertex objects created.</p>
<pre dir="ltr">
PgxSession session = Pgx.createSession("example");
GraphBuilder&lt;Integer&gt; builder = session.newGraphBuilder();

builder.addVertex(1).setProperty("double-prop", 0.1);
builder.addVertex(2).setProperty("double-prop", 2.0);
builder.addVertex(3).setProperty("double-prop", 0.3);
builder.addVertex(4).setProperty("double-prop", 4.56789);

builder.addEdge(0, 1, 2);
builder.addEdge(1, 2, 3);
builder.addEdge(2, 2, 4);
builder.addEdge(3, 3, 4);
builder.addEdge(4, 4, 2);

PgxGraph graph = builder.build();
</pre>
<p>To use long integers as vertex and edge identifiers, specify <code>IdType.LONG</code> when getting a new instance of <code>GraphBuilder</code>. For example:</p>
<pre dir="ltr">
import oracle.pgx.common.types.IdType;
GraphBuilder&lt;Long&gt; builder = session.newGraphBuilder(IdType.LONG);
</pre>
<p>During edge construction, you can directly use vertex objects that were previously created in a call to <code>addEdge</code>.</p>
<pre dir="ltr">
v1 = builder.addVertex(1l).setProperty("double-prop", 0.5)
v2 = builder.addVertex(2l).setProperty("double-prop", 2.0)

builder.addEdge(0, v1, v2)
</pre>
<p>As with vertices, edges can have properties. The following example sets the edge label by using <code>setLabel</code>:</p>
<pre dir="ltr">
builder.addEdge(4, v4, v2).setProperty("edge-prop", "edge_prop_4_2").setLabel("label")
</pre></div>
</div>
<a id="BDSPA224"></a>
<div class="props_rev_3"><a id="GUID-EE2C73EA-2185-4BD7-B1F8-974D455F41D3"></a>
<h3 id="BDSPA-GUID-EE2C73EA-2185-4BD7-B1F8-974D455F41D3" class="sect3"><span class="enumeration_section">4.4.9</span> Dropping a Property Graph</h3>
<div>
<p>To drop a property graph from the database, use the <code>OraclePropertyGraphUtils.dropPropertyGraph</code> method. This method has two parameters, the connection information and the graph name.</p>
<p>The format of the connection information depends on whether you use HBase or Oracle NoSQL Database as the backend database. It is the same as the connection information you provide to <code>OraclePropertyGraph.getInstance</code>.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-275733B0-B0A1-4255-BB60-93EDF0B98DBC">Using Oracle NoSQL Database</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-8851ED84-932C-47F6-A514-691F58ABE9FC">Using Apache HBase</a></p>
</li>
</ul>
</div>
<a id="BDSPA225"></a>
<div class="props_rev_3"><a id="GUID-275733B0-B0A1-4255-BB60-93EDF0B98DBC"></a>
<h4 id="BDSPA-GUID-275733B0-B0A1-4255-BB60-93EDF0B98DBC" class="sect4"><span class="enumeration_section">4.4.9.1</span> Using Oracle NoSQL Database</h4>
<div>
<p>For Oracle NoSQL Database, the <code>OraclePropertyGraphUtils.dropPropertyGraph</code> method uses the KV store name, host computer name, and port number for the connection. This code fragment deletes a graph named <code>my_graph</code> from Oracle NoSQL Database.</p>
<pre dir="ltr">
String kvHostPort = "cluster02:5000";
String kvStoreName = "kvstore";
String kvGraphName = "my_graph";

// Use NoSQL Java API
KVStoreConfig kvconfig = new KVStoreConfig(kvStoreName, kvHostPort);

// Drop the graph
OraclePropertyGraphUtils.dropPropertyGraph(kvconfig, kvGraphName);
</pre></div>
</div>
<a id="BDSPA226"></a>
<div class="props_rev_3"><a id="GUID-8851ED84-932C-47F6-A514-691F58ABE9FC"></a>
<h4 id="BDSPA-GUID-8851ED84-932C-47F6-A514-691F58ABE9FC" class="sect4"><span class="enumeration_section">4.4.9.2</span> Using Apache HBase</h4>
<div>
<p>For Apache HBase, the <code>OraclePropertyGraphUtils.dropPropertyGraph</code> method uses the Hadoop nodes and the Apache HBase port number for the connection. This code fragment deletes a graph named <code>my_graph</code> from Apache HBase.</p>
<pre dir="ltr">
String hbQuorum = "bda01node01.example.com, bda01node02.example.com, bda01node03.example.com";
String hbClientPort = "2181";
String hbGraphName = "my_graph";
 
// Use HBase Java APIs
Configuration conf = HBaseConfiguration.create();
    conf.set("hbase.zookeeper.quorum", hbQuorum);
    conf.set("hbase.zookeper.property.clientPort", hbClientPort);
 
// Drop the graph
OraclePropertyGraphUtils.dropPropertyGraph(conf, hbGraphName);
</pre></div>
</div>
</div>
</div>
<a id="BDSPA227"></a>
<div class="props_rev_3"><a id="GUID-727847CA-F6C9-40BD-B9BA-7FA48AF7D804"></a>
<h2 id="BDSPA-GUID-727847CA-F6C9-40BD-B9BA-7FA48AF7D804" class="sect2"><span class="enumeration_section">4.5</span> Managing Text Indexing for Property Graph Data</h2>
<div>
<p>Indexes in Oracle Big Data Spatial and Graph allow fast retrieval of elements by a particular key/value or key/text pair. These indexes are created based on an element type (vertices or edges), a set of keys (and values), and an index type.</p>
<p>Two types of indexing structures are supported by Oracle Big Data Spatial and Graph: manual and automatic.</p>
<ul style="list-style-type: disc;">
<li>
<p>Automatic text indexes provide automatic indexing of vertices or edges by a set of property keys. Their main purpose is to enhance query performance on vertices and edges based on particular key/value pairs.</p>
</li>
<li>
<p>Manual text indexes enable you to define multiple indexes over a designated set of vertices and edges of a property graph. You must specify what graph elements go into the index.</p>
</li>
</ul>
<p>Oracle Big Data Spatial and Graph provides APIs to create manual and automatic text indexes over property graphs for Oracle NoSQL Database and Apache HBase. Indexes are managed using the available search engines, Apache Lucene and SolrCloud. The rest of this section focuses on how to create text indexes using the property graph capabilities of the Data Access Layer.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-125EAC04-D4A5-4DF2-B839-26136F07374E">Using Automatic Indexes with the Apache Lucene Search Engine</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-9860595A-3EA6-47C6-8C1C-51274E679D31">Using Manual Indexes with the SolrCloud Search Engine</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969">Handling Data Types</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A">Uploading a Collection's SolrCloud Configuration to Zookeeper</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-0DA1EF5E-18DE-4500-91C2-AF501ADC6168">Updating Configuration Settings on Text Indexes for Property Graph Data</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-C574CB79-D84E-4011-95B1-62A696E0A87C">Using Parallel Query on Text Indexes for Property Graph Data</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-E64FB9A9-B342-4C8E-AC05-5CF649E3B71A">Using Native Query Objects on Text Indexes for Property Graph Data</a></p>
</li>
</ul>
</div>
<a id="BDSPA228"></a>
<div class="props_rev_3"><a id="GUID-125EAC04-D4A5-4DF2-B839-26136F07374E"></a>
<h3 id="BDSPA-GUID-125EAC04-D4A5-4DF2-B839-26136F07374E" class="sect3"><span class="enumeration_section">4.5.1</span> Using Automatic Indexes with the Apache Lucene Search Engine</h3>
<div>
<p>The supplied examples ExampleNoSQL6 and ExampleHBase6 create a property graph from an input file, create an automatic text index on vertices, and execute some text search queries using Apache Lucene.</p>
<p>The following code fragment creates an automatic index over an existing property graph's vertices with these property keys: name, role, religion, and country. The automatic text index will be stored under four subdirectories under the <code>/home/data/text-index</code> directory. Apache Lucene data types handling is enabled. This example uses a DOP (parallelism) of 4 for re-indexing tasks.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
      args,  szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
// number of connections to database, batch size, commit size, 
// enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(<span class="bold">4, 4, 10000, 50000, true,</span> 
             <span class="bold">"/home/data/text-index "</span>);
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class);
</pre>
<p>By default, indexes are configured based on the <code>OracleIndexParameters</code> associated with the property graph using the method <code>opg.setDefaultIndexParameters(indexParams</code>).</p>
<p>Indexes can also be created by specifying a different set of parameters. This is shown in the following code snippet.</p>
<pre dir="ltr">
// Create an OracleIndexParameters object to get Index configuration (search engine, etc).
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(args)  
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex("name", Vertex.class, indexParams.getParameters());
</pre>
<p>The code fragment in the next example executes a query over all vertices to find all matching vertices with the key/value pair <code>name:Barack Obama</code>. This operation will execute a lookup into the text index.</p>
<p>Additionally, wildcard searches are supported by specifying the parameter <code>useWildCards</code> in the <code>getVertices</code> API call. Wildcard search is only supported when automatic indexes are enabled for the specified property key. For details on text search syntax using Apache Lucene, see <a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html" target="_blank"><code>https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</code></a>.</p>
<pre dir="ltr">
// Find all vertices with name Barack Obama. 
    Iterator&lt;Vertices&gt; vertices = opg.getVertices("name", "Barack Obama").iterator();
    System.out.println("----- Vertices with name Barack Obama -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
 
   // Find all vertices with name including keyword "Obama"
   // Wildcard searching is supported.
    boolean useWildcard = true;
    Iterator&lt;Vertices&gt; vertices = opg.getVertices("name", "*Obama*").iterator();
    System.out.println("----- Vertices with name *Obama* -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
</pre>
<p>The preceding code example produces output like the following:</p>
<pre dir="ltr">
----- Vertices with name Barack Obama-----
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 1
 
----- Vertices with name *Obama* -----
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 1
</pre>
<div class="infoboxnotealso" id="GUID-125EAC04-D4A5-4DF2-B839-26136F07374E__GUID-D9D22FA9-FCFA-492F-BBD9-8705D49B8FC3">
<p class="notep1">See Also:</p>
<p><a href="using-pgs-bigdata.htm#GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C">Exploring the Sample Programs</a></p>
</div>
</div>
</div>
<a id="BDSPA229"></a>
<div class="props_rev_3"><a id="GUID-9860595A-3EA6-47C6-8C1C-51274E679D31"></a>
<h3 id="BDSPA-GUID-9860595A-3EA6-47C6-8C1C-51274E679D31" class="sect3"><span class="enumeration_section">4.5.2</span> Using Manual Indexes with the SolrCloud Search Engine</h3>
<div>
<p>The supplied examples ExampleNoSQL7 and ExampleHBase7 create a property graph from an input file, create a manual text index on edges, put some data into the index, and execute some text search queries using Apache SolrCloud.</p>
<p>When using SolrCloud, you must first load a collection's configuration for the text indexes into Apache Zookeeper, as described in <a href="using-pgs-bigdata.htm#GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A">Uploading a Collection's SolrCloud Configuration to Zookeeper</a>.</p>
<p>The following code fragment creates a manual text index over an existing property graph using four shards, one shard per node, and a replication factor of 1. The number of shards corresponds to the number of nodes in the SolrCloud cluster.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args, 
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
   // number of connections to database, batch size, commit size, 
         // write timeout (in secs)
             String configName = "opgconfig";
             String solrServerUrl = "nodea:2181/solr"
             String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                                  "nodec:8983_solr,noded:8983_solr";
 
         int zkTimeout = 15;
         int numShards = 4;
         int replicationFactor = 1;
         int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
 
// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
          }
</pre>
<p>The next code fragment executes a query over the manual index to get all edges with the key/value pair c<code>ollaboratesWith:Beyonce</code>. Additionally, wildcards search can be supported by specifying the parameter <code>useWildCards</code> in the get API call.</p>
<pre dir="ltr">
// Find all edges with collaboratesWith Beyonce. 
   // Wildcard searching is supported using true parameter.
    edges = index.get("collaboratesWith", "Beyonce").iterator();
    System.out.println("----- Edges with name Beyonce -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
 
// Find all vertices with name including Bey*. 
   // Wildcard searching is supported using true parameter.
    edges = index.get("collaboratesWith", "*Bey*", true).iterator();
    System.out.println("----- Edges with collaboratesWith Bey* -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: " + countE);
</pre>
<p>The preceding code example produces output like the following:</p>
<pre dir="ltr">
----- Edges with name Beyonce -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
 
----- Edges with collaboratesWith Bey* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
</pre>
<div class="infoboxnotealso" id="GUID-9860595A-3EA6-47C6-8C1C-51274E679D31__GUID-DC96E49D-FA92-40B0-9D6E-08B9A11E942C">
<p class="notep1">See Also:</p>
<p><a href="using-pgs-bigdata.htm#GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C">Exploring the Sample Programs</a></p>
</div>
</div>
</div>
<a id="BDSPA230"></a>
<div class="props_rev_3"><a id="GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969"></a>
<h3 id="BDSPA-GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969" class="sect3"><span class="enumeration_section">4.5.3</span> Handling Data Types</h3>
<div>
<p>Oracle's property graph support indexes and stores an element's Key/Value pairs based on the value data type. The main purpose of handling data types is to provide extensive query support like numeric and date range queries.</p>
<p>By default, searches over a specific key/value pair are matched up to a query expression based on the value's data type. For example, to find vertices with the key/value pair <code>age:30</code>, a query is executed over all age fields with a data type integer. If the value is a query expression, you can also specify the data type class of the value to find by calling the API <code>get(String key, Object value, Class dtClass, Boolean useWildcards)</code>. If no data type is specified, the query expression will be matched to all possible data types.</p>
<p>When dealing with Boolean operators, each subsequent key/value pair must append the data type's prefix/suffix so the query can find proper matches. The following topics describe how to append this prefix/suffix for Apache Lucene and SolrCloud.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA">Appending Data Type Identifiers on Apache Lucene</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363">Appending Data Type Identifiers on SolrCloud</a></p>
</li>
</ul>
</div>
<a id="BDSPA232"></a><a id="BDSPA231"></a>
<div class="props_rev_3"><a id="GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA"></a>
<h4 id="BDSPA-GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA" class="sect4"><span class="enumeration_section">4.5.3.1</span> Appending Data Type Identifiers on Apache Lucene</h4>
<div>
<p>When Lucene's data types handling is enabled, you must append the proper data type identifier as a suffix to the key in the query expression. This can be done by executing a <code>String.concat()</code> operation to the key. If Lucene's data types handling is disabled, you must insert the data type identifier as a prefix in the value String. <a href="using-pgs-bigdata.htm#GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA__CEGECEDC">Table 4-1</a> shows the data type identifiers available for text indexing using Apache Lucene (see also the Javadoc for <code>LuceneIndex</code>).</p>
<div class="tblformal" id="GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA__CEGECEDC">
<hr />
<p class="titleintable">Table 4-1 Apache Lucene Data Type Identifiers</p>
<table class="cellalignment336" title="Apache Lucene Data Type Identifiers" summary="Apache Lucene Data Type Identifiers">
<thead align="left">
<tr>
<th class="cellalignment344" id="d17953e3486">Lucene Data Type Identifier</th>
<th class="cellalignment345" id="d17953e3489">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="cellalignment344" id="d17953e3494" headers="d17953e3486">
<p>TYPE_DT_STRING</p>
</td>
<td class="cellalignment345" headers="d17953e3494 d17953e3489">
<p>String</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3501" headers="d17953e3486">
<p>TYPE_DT_BOOL</p>
</td>
<td class="cellalignment345" headers="d17953e3501 d17953e3489">
<p>Boolean</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3508" headers="d17953e3486">
<p>TYPE_DT_DATE</p>
</td>
<td class="cellalignment345" headers="d17953e3508 d17953e3489">
<p>Date</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3515" headers="d17953e3486">
<p>TYPE_DT_FLOAT</p>
</td>
<td class="cellalignment345" headers="d17953e3515 d17953e3489">
<p>Float</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3522" headers="d17953e3486">
<p>TYPE_DT_DOUBLE</p>
</td>
<td class="cellalignment345" headers="d17953e3522 d17953e3489">
<p>Double</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3529" headers="d17953e3486">
<p>TYPE_DT_INTEGER</p>
</td>
<td class="cellalignment345" headers="d17953e3529 d17953e3489">
<p>Integer</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3536" headers="d17953e3486">
<p>TYPE_DT_SERIALIZABLE</p>
</td>
<td class="cellalignment345" headers="d17953e3536 d17953e3489">
<p>Serializable</p>
</td>
</tr>
</tbody>
</table>
<hr /></div>
<!-- class="inftblhruleinformal" -->
<p>The following code fragment creates a manual index on edges using Lucene's data type handling, adds data, and later executes a query over the manual index to get all edges with the key/value pair <code>collaboratesWith:Beyonce AND country1:United*</code> using wildcards.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,               
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Specify Index Directory parameters (number of directories, 
   // number of connections to database, batch size, commit size, 
         // enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(<span class="bold">4, 4, 10000, 50000, true, 
            "/home/data/text-index "</span>);
opg.setDefaultIndexParameters(indexParams);
// Create manual indexing on above properties for all edges
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
             index.put("country", vIn.getProperty("country"), edge);
          }
 
// Wildcard searching is supported using true parameter.
    String key = "country";
    key = key.concat(String.valueOf(oracle.pg.text.lucene.LuceneIndex.TYPE_DT_STRING));
   
    String queryExpr = "Beyonce AND " + key + ":United*";
    edges = index.get("collaboratesWith", queryExpr, true /*UseWildcard*/).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre>
<p>The preceding code example might produce output like the following:</p>
<pre dir="ltr">
----- Edges with name Beyonce AND country1:United* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
</pre>
<p>The following code fragment creates an automatic index on vertices, disables Lucene's data type handling, adds data, and later executes a query over the manual index from a previous example to get all vertices with the key/value pair <code>country:United* AND role:1*political*</code> using wildcards.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,               
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
   // number of connections to database, batch size, commit size, 
         // enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(<span class="bold">4, 4, 10000, 50000, false, "/ home/data/text-index "</span>);
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class);
 
// Wildcard searching is supported using true parameter.
    String value = "*political*";
    value = String.valueOf(LuceneIndex.TYPE_DT_STRING) + value;
String queryExpr = "United* AND role:" + value;
    
 
vertices = opg.getVertices("country", queryExpr,  true /*useWildcard*/).iterator();
    System.out.println("----- Vertices with query: " + queryExpr + " -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
</pre>
<p>The preceding code example might produce output like the following:</p>
<pre dir="ltr">
----- Vertices with query: United* and role:1*political* -----
Vertex ID 30 {name:str:Jerry Brown, role:str:political authority, occupation:str:34th and 39th governor of California, country:str:United States, political party:str:Democratic, religion:str:roman catholicism}
Vertex ID 24 {name:str:Edward Snowden, role:str:political authority, occupation:str:system administrator, country:str:United States, religion:str:buddhism}
Vertex ID 22 {name:str:John Kerry, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:68th United States Secretary of State, religion:str:Catholicism}
Vertex ID 21 {name:str:Hillary Clinton, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:67th United States Secretary of State, religion:str:Methodism}
Vertex ID 19 {name:str:Kirsten Gillibrand, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:junior United States Senator from New York, religion:str:Methodism}
Vertex ID 13 {name:str:Ertharin Cousin, role:str:political authority, country:str:United States, political party:str:Democratic}
Vertex ID 11 {name:str:Eric Holder, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:United States Deputy Attorney General}
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 8
</pre>
<p>Additionally, Oracle Big Data Spatial and Graph provides a set of utilities to help users write their own Lucene text search queries using the query syntax and data type identifiers required by the automatic and manual text indexes. The method <code>buildSearchTerm(key, value, dtClass)</code> in <code>LuceneIndex</code> creates a query expression of the form <span class="italic">field:query_expr</span> by adding the data type identifier to the key (or value) and transforming the value into the required string representation based on the given data type and Apache Lucene's data type handling configuration.</p>
<p>The following code fragment uses the <code>buildSearchTerm</code> method to produce a query expression <span class="italic">country1:United*</span> (if Lucene's data type handling is enabled), or <span class="italic">country:1United*</span> (if Lucene's data type handling is disabled) used in the previous examples:</p>
<pre dir="ltr">
String szQueryStrCountry = index.buildSearchTerm("country", 
                                  "United*", String.class);
</pre>
<p>To deal with the key and values as individual objects to construct a different Lucene Query like a WildcardQuery using the required syntax, the methods <code>appendDatatypesSuffixToKey(key, dtClass)</code> and <code>appendDatatypesSuffixToValue(value, dtClass)</code> in LuceneIndex will append the appropriate data type identifiers and transform the value into the required Lucene string representation based on the given data type.</p>
<p>The following code fragment uses the<code>appendDatatypesSuffixToKey</code> method to generate the field name required in a Lucene text query. If Lucene&rsquo;s data type handling is enabled, the string returned will append the String data type identifier as a suffix of the key (country1). In any other case, the retrieved string will be the original key (country).</p>
<pre dir="ltr">
String key = index.appendDatatypesSuffixToKey("country", String.class);
</pre>
<p>The next code fragment uses the <code>appendDatatypesSuffixToValue</code> method to generate the query body expression required in a Lucene text query. If Lucene&rsquo;s data type handling is disabled, the string returned will append the String data type identifier as a prefix of the key (1United*). In all other cases, the string returned will be the string representation of the value (United*).</p>
<pre dir="ltr">
String value = index.appendDatatypesSuffixToValue("United*", String.class);
</pre>
<p><code>LuceneIndex</code> also supports generating a Term object using the method <code>buildSearchTermObject(key, value, dtClass)</code>. Term objects are commonly used among different type of Lucene Query objects to constrain the fields and values of the documents to be retrieved. The following code fragment shows how to create a Wildcard Query object using the <code>buildSearchTermObject</code> method.</p>
<pre dir="ltr">
Term term = index.buildSearchTermObject("country", "United*", String.class);  
Query query = new WildcardQuery(term);
</pre></div>
</div>
<a id="BDSPA234"></a><a id="BDSPA233"></a>
<div class="props_rev_3"><a id="GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363"></a>
<h4 id="BDSPA-GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363" class="sect4"><span class="enumeration_section">4.5.3.2</span> Appending Data Type Identifiers on SolrCloud</h4>
<div>
<p>For Boolean operations on SolrCloud text indexes, you must append the proper data type identifier as suffix to the key in the query expression. This can be done by executing a <code>String.concat()</code> operation to the key. <a href="using-pgs-bigdata.htm#GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363__CEGGAEJA">Table 4-2</a> shows the data type identifiers available for text indexing using SolrCloud (see the Javadoc for <code>SolrIndex</code>).</p>
<div class="tblformal" id="GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363__CEGGAEJA">
<hr />
<p class="titleintable">Table 4-2 SolrCloud Data Type Identifiers</p>
<table class="cellalignment336" title="SolrCloud Data Type Identifiers" summary="SolrCloud Data Type Identifiers">
<thead align="left">
<tr>
<th class="cellalignment344" id="d17953e3699">Solr Data Type Identifier</th>
<th class="cellalignment345" id="d17953e3702">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="cellalignment344" id="d17953e3707" headers="d17953e3699">
<p>TYPE_DT_STRING</p>
</td>
<td class="cellalignment345" headers="d17953e3707 d17953e3702">
<p>String</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3714" headers="d17953e3699">
<p>TYPE_DT_BOOL</p>
</td>
<td class="cellalignment345" headers="d17953e3714 d17953e3702">
<p>Boolean</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3721" headers="d17953e3699">
<p>TYPE_DT_DATE</p>
</td>
<td class="cellalignment345" headers="d17953e3721 d17953e3702">
<p>Date</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3728" headers="d17953e3699">
<p>TYPE_DT_FLOAT</p>
</td>
<td class="cellalignment345" headers="d17953e3728 d17953e3702">
<p>Float</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3735" headers="d17953e3699">
<p>TYPE_DT_DOUBLE</p>
</td>
<td class="cellalignment345" headers="d17953e3735 d17953e3702">
<p>Double</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3742" headers="d17953e3699">
<p>TYPE_DT_INTEGER</p>
</td>
<td class="cellalignment345" headers="d17953e3742 d17953e3702">
<p>Integer</p>
</td>
</tr>
<tr>
<td class="cellalignment344" id="d17953e3749" headers="d17953e3699">
<p>TYPE_DT_SERIALIZABLE</p>
</td>
<td class="cellalignment345" headers="d17953e3749 d17953e3702">
<p>Serializable</p>
</td>
</tr>
</tbody>
</table>
<hr /></div>
<!-- class="inftblhruleinformal" -->
<p>The following code fragment creates a manual index on edges using SolrCloud, adds data, and later executes a query over the manual index to get all edges with the key/value pair <code>collaboratesWith:Beyonce AND country1:United*</code> using wildcards.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,       
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
   // number of connections to database, batch size, commit size, 
         // write timeout (in secs)
             String configName = "opgconfig";
             String solrServerUrl = "nodea:2181/solr"
             String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                                  "nodec:8983_solr,noded:8983_solr";
 
         int zkTimeout = 15;
         int numShards = 4;
         int replicationFactor = 1;
         int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
             index.put("country", vIn.getProperty("country"), edge);
          }
 
// Wildcard searching is supported using true parameter.
    String key = "country";
    key = key.concat(oracle.pg.text.solr.SolrIndex.TYPE_DT_STRING);
   
    String queryExpr = "Beyonce AND " + key + ":United*";
    edges = index.get("collaboratesWith", queryExpr, true /** UseWildcard*/).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre>
<p>The preceding code example might produce output like the following:</p>
<pre dir="ltr">
----- Edges with name Beyonce AND country_str:United* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
</pre>
<p>Additionally, Oracle Big Data Spatial and Graph provides a set of utilities to help users write their own SolrCloud text search queries using the query syntax and data type identifiers required by the automatic and manual text indexes. The method <code>buildSearchTerm(key, value, dtClass)</code> in <code>SolrIndex</code> creates a query expression of the form <span class="italic">field:query_expr</span> by adding the data type identifier to the key (or value) and transforming the value into the required string representation using the data type formats required by the index</p>
<p>The following code fragment uses the <code>buildSearchTerm</code> method to produce a query expression <span class="italic">country1:United*</span> (if Lucene's data type handling is enabled), or <span class="italic">country:1United*</span> (if Lucene's data type handling is disabled) used in the previous examples:</p>
<pre dir="ltr">
String szQueryStrCountry = index.buildSearchTerm("country", 
                                  "United*", String.class);
</pre>
<p>To deal with the key and values as individual objects to construct a different Lucene Query like a WildcardQuery using the required syntax, the methods <code>appendDatatypesSuffixToKey(key, dtClass)</code> and <code>appendDatatypesSuffixToValue(value, dtClass)</code> in <code>SolrIndex</code> will append the appropriate data type identifiers and transform the value into the required SolrCloud string representation based on the given data type.</p>
<p>The following code fragment uses the<code>appendDatatypesSuffixToKey</code> method to generate the field name required in a SolrCloud text query. The retrieved string will append the String data type identifier as a suffix of the key (country_str).</p>
<pre dir="ltr">
String key = index.appendDatatypesSuffixToKey("country", String.class);
</pre>
<p>The next code fragment uses the <code>appendDatatypesSuffixToValue</code> method to generate the query body expression required in a SolrCloud text query. The string returned will be the string representation of the value (United*).</p>
<pre dir="ltr">
String value = index.appendDatatypesSuffixToValue("United*", String.class);
</pre></div>
</div>
</div>
<a id="BDSPA235"></a>
<div class="props_rev_3"><a id="GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A"></a>
<h3 id="BDSPA-GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A" class="sect3"><span class="enumeration_section">4.5.4</span> Uploading a Collection's SolrCloud Configuration to Zookeeper</h3>
<div>
<p>Before using SolrCloud text indexes on Oracle Big Data Spatial and Graph property graphs, you must upload a collection's configuration to Zookeeper. This can be done using the ZkCli tool from one of the SolrCloud cluster nodes.</p>
<p>A predefined collection configuration directory can be found in <code>dal/opg-solr-config</code> under the installation home. The following shows an example on how to upload the PropertyGraph configuration directory.</p>
<ol>
<li>
<p>Copy dal/opg-solr-config under the installation home into /tmp directory on one of the Solr cluster nodes. For example:</p>
<pre dir="ltr">
scp &ndash;r dal/opg-solr-config user@solr-node:/tmp
</pre></li>
<li>
<p>Execute the following command line like the following example using the ZkCli tool on the same node:</p>
<pre dir="ltr">
$SOLR_HOME/bin/zkcli.sh -zkhost 127.0.0.1:2181/solr -cmd upconfig &ndash;confname opgconfig -confdir /tmp/opg-solr-config
</pre></li>
</ol>
</div>
</div>
<a id="BDSPA458"></a>
<div class="props_rev_3"><a id="GUID-0DA1EF5E-18DE-4500-91C2-AF501ADC6168"></a>
<h3 id="BDSPA-GUID-0DA1EF5E-18DE-4500-91C2-AF501ADC6168" class="sect3"><span class="enumeration_section">4.5.5</span> Updating Configuration Settings on Text Indexes for Property Graph Data</h3>
<div>
<p>Oracle's property graph support manages manual and automatic text indexes through integration with Apache Lucene and SolrCloud. At creation time, you must create an <code>OracleIndexParameters</code> object specifying the search engine and other configuration settings to be used by the text index. After a text index for property graph is created, these configuration settings cannot be changed. For automatic indexes, all vertex index keys are managed by a single text index, and all edge index keys are managed by a different text index using the configuration specified when the first vertex or edge key is indexed.</p>
<p>If you need to change the configuration settings, you must first disable the current index and create it again using a new <code>OracleIndexParameters</code> object. The following code fragment creates two automatic Apache Lucene-based indexes (on vertices and edges) over an existing property graph, disables them, and recreates them to use SolrCloud.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
      args,  szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do parallel data loading
OraclePropertyGraphDataLoader opgdl =
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop);
 
// Create an automatic index using Apache Lucene.
// Specify Index Directory parameters (number of directories,
// number of connections to database, batch size, commit size,
// enable datatypes, location)
OracleIndexParameters luceneIndexParams =
     OracleIndexParameters.buildFS(4, 4, 10000, 50000, true,
             "/home/data/text-index ");
 
// Specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class, luceneIndexParams.getParameters());
 
// Create auto indexing on weight for all edges
opg.createKeyIndex("weight", Edge.class, luceneIndexParams.getParameters());
 
// Disable auto indexes to change parameters
opg.getOracleIndexManager().disableVertexAutoIndexer();
opg.getOracleIndexManager().disableEdgeAutoIndexer();
 
 
// Recreate text indexes using SolrCloud
// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set,
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,
// number of connections to database, batch size, commit size,
// write timeout (in secs)
String configName = "opgconfig";
String solrServerUrl = "nodea:2181/solr"
String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +
   "nodec:8983_solr,noded:8983_solr";
 
int zkTimeout = 15;
int numShards = 4;
int replicationFactor = 1;
int maxShardsPerNode = 1;
 
OracleIndexParameters solrIndexParams =
OracleIndexParameters.buildSolr(configName,
                                solrServerUrl,
                                solrNodeSet,
                                zkTimeout,
                                numShards,
                                replicationFactor,
                                maxShardsPerNode,
                                4,
                                10000,
                                500000,
                                15);
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class, solrIndexParams.getParameters());
 
// Create auto indexing on weight for all edges
opg.createKeyIndex("weight", Edge.class, solrIndexParams.getParameters());
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-C574CB79-D84E-4011-95B1-62A696E0A87C"></a>
<h3 id="BDSPA-GUID-C574CB79-D84E-4011-95B1-62A696E0A87C" class="sect3"><span class="enumeration_section">4.5.6</span> Using Parallel Query on Text Indexes for Property Graph Data</h3>
<div>
<p>Text indexes in Oracle Big Data Spatial and Graph allow executing text queries over millions of vertices and edges by a particular key/value or key/text pair using parallel query execution.</p>
<p>Parallel text querying is an optimized solution taking advantage of the distribution of the data in the index among shards in SolrCloud (or subdirectories in Apache Lucene), so each one is queried using separate index connection. This involves multiple threads and connections to SolrCloud (or Apache Lucene) search engines to increase performance on read operations and retrieve multiple elements from the index. Note that this approach will not rank the matching results based on their score.</p>
<p>Parallel text query will produce an array where each element holds all the vertices (or edges) with an attribute matching the given K/V pair from a shard. The subset of shards queried will be delimited by the given start sub-directory ID and the size of the connections array provided. This way, the subset will consider shards in the range of [start, start - 1 + size of connections array]. Note that an integer ID (in the range of [0, N - 1]) is assigned to all the shards in index with N shards.</p>
<div class="section">
<p class="subhead3"><span class="bold">Parallel Text Query Using Apache Lucene</span></p>
<p>You can use parallel text query using Apache Lucene by calling the method <code>getPartitioned</code> in <code>LuceneIndex</code>, specifying an array of connections to set of subdirectories (<code>SearcherManager</code> objects), the key/value pair to search, and the starting subdirectory ID. Each connection needs to be linked to the appropriate subdirectory, as each subdirectory is independent of the rest of the subdirectories in the index.</p>
<p>The following code fragment generates an automatic text index using the Apache Lucene Search engine, and executes a parallel text query. The number of calls to the <code>getPartitioned</code> method in the <code>LuceneIndex</code> class is controlled by the total number of subdirectories and the number of connections used.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create an automatic index
OracleIndexParameters indexParams 
= OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name for vertices");
opg.createKeyIndex("name", Vertex.class);

// Get the SolrIndex object 
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);


long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets a connection object from subdirectory split to 
//(split + conns.length)
for (int idx = 0; idx &lt; conns.length; idx++) { 
<span class="bold">conns[idx] = index.getOracleSearcherManager(idx + split);</span> 
}

// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr }
= <span class="bold">index.getPartitioned(conns /* connections */, 
 "name"/* key */, 
 "*" /* value */, 
 true /* wildcards */, 
 split /* start split ID */);
</span>
lCount = countFromIterables(iterAr); /* Consume iterables in parallel */

// Close the connections to the sub-directories after completed
for (int idx = 0; idx &lt; conns.length; idx++) { 
conns[idx].close();
}
}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parallel Text Search Using SolrCloud</p>
<p>You can use parallel text query using SolrCloud by calling the method <code>getPartitioned</code> in <code>SolrIndex</code>, specifying an array of connections to SolrCloud (<code>CloudSolrServer</code> objects), the key/value pair to search, and the starting shard ID.</p>
<p>The following code fragment generates an automatic text index using the SolrCloud Search engine and executes a parallel text query. The number of calls to the <code>getPartitioned</code> method in the <code>SolrIndex</code> class is controlled by the total number of shards in the index and the number of connections used.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout /* zookeeper timeout in seconds */,
 numShards /* total number of shards */,
 replicationFactor /* Replication factor */,
 maxShardsPerNode /* maximum number of shardsper node*/,
 4 /* dop used for scan */,
 10000 /* batch size before commit*/,
 500000 /* commit size before SolrCloud commit*/,
 15 /* write timeout in seconds */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name for vertices");
opg.createKeyIndex("name", Vertex.class);

// Get the SolrIndex object 
<span class="bold">SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);</span>

// Open an array of connections to handle connections to SolrCloud needed for parallel text search
CloudSolrServer[] conns = new CloudSolrServer[dop];


<span class="bold">for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx] = index.getCloudSolrServer(15 /* write timeout in 
secs*/);
}
</span>
// Iterate to cover all the shards in the index
long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr = <span class="bold">index.getPartitioned(conns /* connections */, 
 "name"/* key */, 
 "*" /* value */, 
 true /* wildcards */, 
 split /* start split ID */);</span>

lCount = countFromIterables(iterAr); /* Consume iterables in parallel */
}

// Do not close the connections to the subdirectories after completion,
// because those connections are used by the index itself.

// Count results
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" --></div>
</div>
<div class="props_rev_3"><a id="GUID-E64FB9A9-B342-4C8E-AC05-5CF649E3B71A"></a>
<h3 id="BDSPA-GUID-E64FB9A9-B342-4C8E-AC05-5CF649E3B71A" class="sect3"><span class="enumeration_section">4.5.7</span> Using Native Query Objects on Text Indexes for Property Graph Data</h3>
<div>
<p>Using Query objects directly is for advanced users, enabling them to take full advantage of the underlying query capabilities of the text search engine (Apache Lucene or SolrCloud). For example, you can add constraints to text searches, such as adding a boost to the matching scores and adding sorting clauses.</p>
<p>Using text searches with Query objects will produce an Iterable object holding all the vertices (or edges) with an attribute (or set of attributes) matching the text query while satisfying the constraints. This approach will automatically rank the results based on their matching score.</p>
<p>To build the clauses in the query body, you may need to consider the data type used by the key/value pair to be matched, as well as the configuration of the search engine used. For more information about building a search term, see <a href="using-pgs-bigdata.htm#GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969">Handling Data Types</a>.</p>
<div class="section">
<p class="subhead3"><span class="bold">Using Native Query Objects with Apache Lucene</span></p>
<p>You can use native query objects using Apache Lucene by calling the method <code>get(Query)</code> in <code>LuceneIndex</code>. You can also use parallel text query with native query objects by calling the method <code>getPartitioned(SearcherManager[], Query, int)</code> in <code>LuceneIndex</code> specifying an array of connections to a set of subdirectories (<code>SearcherManager</code> objects), the Lucene query object, and the starting subdirectory ID. Each connection must be linked to the appropriate subdirectory, because each subdirectory is independent of the rest of the subdirectories in the index.</p>
<p>The following code fragment generates an automatic text index using Apache Lucene Search engine, creates a Lucene Query, and executes a parallel text query. The number of calls to the <code>getPartitioned</code> method in the <code>LuceneIndex</code> class is controlled by the total number of subdirectories and the number of connections used.</p>
<pre dir="ltr">
import oracle.pg.text.lucene.LuceneIndex;
import org.apache.lucene.search.*;
import org.apache.lucene.index.*;

...

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create an automatic index
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name and country properties for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the LuceneIndex object 
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
Term term = index.buildSearchTermObject("name", "Beyo*", String.class);
Query queryBey = new WildcardQuery(term);

// Add another condition to query all the vertices whose country is 
//"United States"
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

Query queryCountry = new PhraseQuery();
StringTokenizer st = new StringTokenizer(value);
while (st.hasMoreTokens()) {
  queryCountry.add(new Term(key, st.nextToken()));
};

//Concatenate queries
Boolean bQuery = new BooleanQuery();
bQuery.add(queryBey, BooleanClause.Occur.MUST);
bQuery.add(queryCountry, BooleanClause.Occur.MUST);

long lCount = 0;
conns = new SearcherManager[dop];
for (int split = 0; split &lt; index.getTotalShards(); split += conns.length) {
  // Gets a connection object from subdirectory split to 
  //(split + conns.length). Skip the cache so we clone the connection and
  // avoid using the connection used by the index.
  for (int idx = 0; idx &lt; conns.length; idx++) { 
    conns[idx] = index.getOracleSearcherManager(idx + split, 
                                      true /* skip looking in the cache*/                 
); 
  }

  // Gets elements from split to split + conns.length
  Iterable&lt;Vertex&gt;[] iterAr = index.getPartitioned(conns /* connections */, 
                                                   bQuery,  
                                                   split /* start split ID */);

  lCount = countFromIterables(iterAr); /* Consume iterables in parallel */

  // Do not close the connections to the sub-directories after completed,
  // as those connections are used by the index itself

}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Using Native Query Objects withSolrCloud</p>
<p>You can directly use native query objects against SolrCloud by calling the method <code>get(SolrQuery)</code> in <code>SolrIndex</code>. You can also use parallel text query with native query objects by calling the method <code>getPartitioned(CloudSolrServer[],SolrQuery,int)</code> in <code>SolrIndex</code> specifying an array of connections to SolrCloud (<code>CloudSolrServer</code> objects), the <code>SolrQuery</code> object, and the starting shard ID.</p>
<p>The following code fragment generates an automatic text index using the Apache SolrCloud Search engine, creates a <code>SolrQuery</code> object, and executes a parallel text query. The number of calls to the <code>getPartitioned</code> method in the <code>SolrIndex</code> class is controlled by the total number of subdirectories and the number of connections used.</p>
<pre dir="ltr">
import oracle.pg.text.solr.*;
import org.apache.solr.client.solrj.*;

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout          /* zookeeper timeout in seconds */,
 numShards          /* total number of shards */,
 replicationFactor  /* Replication factor */,
 maxShardsPerNode   /* maximum number of shardsper node*/,
 4                  /* dop used for scan */,
 10000              /* batch size before commit*/,
 500000             /* commit size before SolrCloud commit*/,
 15                 /* write timeout in seconds */
);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the SolrIndex object 
SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
String szQueryStrBey = index.buildSearchTerm("name", "Beyo*", String.class);
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

String szQueryStrCountry = key + ":" + value;
Solrquery query = new SolrQuery(szQueryStrBey + " AND " + szQueryStrCountry);

//Query using get operation
index.get(query);

// Open an array of connections to handle connections to SolrCloud needed 
// for parallel text search
CloudSolrServer[] conns = new CloudSolrServer[dop];

for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx] = index.getCloudSolrServer(15 /* write timeout in 
secs*/);
}

// Iterate to cover all the shards in the index
long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr = index.getPartitioned(conns /* connections */, 
 query, 
 split /* start split ID */);

lCount = countFromIterables(iterAr); /* Consume iterables in parallel */
}

// Close the connections to SolCloud after completion
for (int idx = 0; idx &lt; conns.length; idx++) { 
  conns[idx].shutdown();
}

// Count results
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<div class="props_rev_3"><a id="GUID-25432BC8-B8EA-494E-8A6A-5C19ECD6760F"></a>
<h2 id="BDSPA-GUID-25432BC8-B8EA-494E-8A6A-5C19ECD6760F" class="sect2"><span class="enumeration_section">4.6</span> Querying Property Graph Data</h2>
<div>
<p>Oracle Big Data Spatial and Graph supports a rich set of graph pattern matching capabilities. It provides a SQL-like declarative language that allows you to express a graph query pattern that consists of vertices and edges, and constraints on the properties of the vertices and edges.</p>
<p>An example property graph query is as follows. It defines a graph pattern inspired by the famous ancient proverb: <span class="italic">The enemy of my enemy is my friend</span>. In this example, variables <code>x</code>, <code>y</code>, <code>z</code> are used for vertices, and variables <code>e1</code>, <code>e2</code> are used for edges. There is a constraint on the edge label, and the query returns (projects) the value of the <code>name</code> property of vertices <code>x</code> and <code>y</code>.</p>
<pre dir="ltr">
SELECT x.name, z.name
WHERE
    x -[e1 WITH label = 'feuds']-&gt; y,
    y -[e2 WITH label = 'feuds']-&gt; z
</pre>
<p>You can run the query either in a Groovy shell environment or from Java. For example, to run the preceding query from the Groovy shell for Apache HBase or Oracle NoSQL Database, you can first read the graph from the database into the in-memory analyst, get an in-memory graph, and invoke the <code>queryPgql</code> function.</p>
<pre dir="ltr">
// Read graph data from a backend database into memory
// Note that opg is an instance of OraclePropertyGraph class
opg-hbase&gt; G = session.readGraphWithProperties(<span class="bold">opg.getConfig()</span>);
opg-hbase&gt; 

resultSet = G.<span class="bold">queryPgql</span>("SELECT x.name, z.name WHERE x -[e1 WITH label = 'feuds']-&gt; y,  y -[e2 WITH label = 'feuds']-&gt; z")
</pre>
<p>To get the type and variable name of the first projected variable in the result set, you can enter the following:</p>
<pre dir="ltr">
opg-hbase&gt; resultElement = resultElements.get(0)
opg-hbase&gt; type = resultElement.getElementType() // STRING
opg-hbase&gt; varName = resultElement.getVarName() // x.name
</pre>
<p>You can also iterate over the result set. For example:</p>
<pre dir="ltr">
opg-hbase&gt; resultSet.getResults().each { \
       // the variable 'it' is implicitly declared to references each PgqlResult instance
     }
</pre>
<p>Finally, you can display (print) results. For example, to display the first 10 rows:</p>
<pre dir="ltr">
opg-hbase&gt; resultSet.print(10) // print the first 10 results
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-924E8670-F550-41F9-884A-1998409A7544"></a>
<h2 id="BDSPA-GUID-924E8670-F550-41F9-884A-1998409A7544" class="sect2"><span class="enumeration_section">4.7</span> Support for Secure Oracle NoSQL Database</h2>
<div>
<p>Oracle Big Data Spatial and Graph property graph support works with both secure and non-secure Oracle NoSQL Database installations. This topic provides information about how to use property graph functions with a secure Oracle NoSQL Database setup. It assumes that a secure Oracle NoSQL Database is already installed (a process explained in "Performing a Secure Oracle NoSQL Database Installation" in the <span class="italic">Oracle NoSQL Database Security Guide</span> at <a href="http://docs.oracle.com/cd/NOSQL/html/SecurityGuide/secure_installation.html" target="_blank"><code>http://docs.oracle.com/cd/NOSQL/html/SecurityGuide/secure_installation.html</code></a>).</p>
<p>You must have the correct credentials to access the secure database. Create a user such as the following:</p>
<pre dir="ltr">
kv-&gt; plan create-user -name myusername -admin -wait
</pre>
<p>Grant this user the <code>readwrite</code> and <code>dbaadmin</code> roles. For example:</p>
<pre dir="ltr">
kv-&gt; plan grant -user myusername -role readwrite -wait
kv-&gt; plan grant -user myusername -role dbadmin -wait
</pre>
<p>When generating the <code>login_properties.txt</code> from the file <code>client.security</code>, make sure the user name is correct. For example:</p>
<pre dir="ltr">
oracle.kv.auth.username=myusername
</pre>
<p>On Oracle property graph client side, you must have the security-related files and libraries to interact with the secure Oracle NoSQL Database. First, copy these files (or directories) from <code>KVROOT/security/</code> to the client side:</p>
<pre dir="ltr">
client.security
client.trust    
login.wallet/
login_properties.txt
</pre>
<p>If Oracle Wallet is used to hold passwords that are needed for accessing the secure database, copy these three libraries to the client side and set the class path correctly:</p>
<pre dir="ltr">
oraclepki.jar
osdt_cert.jar
osdt_core.jar
</pre>
<p>After configuring the database and Oracle property graph client side correctly, you can connect to a graph stored in Secure NoSQL Database using either one of the following two approaches.</p>
<ul style="list-style-type: disc;">
<li>
<p>Specify the login properties file, using a Java VM setting with the following format:</p>
<pre dir="ltr">
-Doracle.kv.security=/&lt;your-path&gt;/login_properties.txt
</pre>
<p>You can also set this Java VM property for applications deployed into a J2EE container (including in-memory analytics). For example, before starting WebLogic Server, you can set an environment variable in the following format to refer to the login properties configuration file:</p>
<pre dir="ltr">
setenv JAVA_OPTIONS "-Doracle.kv.security=/&lt;your-path&gt;/login_properties.txt"
</pre>
<p>Then you can call <code>OraclePropertyGraph.getInstance(kconfig, szGraphName)</code> as usual to create an <code>OraclePropertyGraph</code> instance.</p>
</li>
<li>
<p>Call <code>OraclePropertyGraph.getInstance(kconfig, szGraphName, username, password, truStoreFile)</code>, where <code>username</code> and <code>password</code> are the correct credentials to access secure Oracle NoSQL Database, and <code>truStoreFile</code> is the path to the client side trust store file <code>client.trust</code>.</p>
<p>The following code fragment creates a property graph in a Secure Oracle NoSQL Database, loads the data, and then counts how many vertices and edges in the graph:</p>
<pre dir="ltr">
// This object will handle operations over the property graph 
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(kconfig,
szGraphName,
username,
password,
truStoreFile);

// Clear existing vertices/edges in the property graph 
opg.clearRepository();
opg.setQueueSize(100); // 100 elements

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
// This object will handle parallel data loading over the property graph
System.out.println("Load data for graph " + szGraphName);
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop);
// Count all vertices
long countV = 0;
Iterator&lt;Vertex&gt; vertices = opg.getVertices().iterator();
while (vertices.hasNext()) {
vertices.next();
countV++;
}

System.out.println("Vertices found: " + countV);
// Count all edges
long countE = 0;
Iterator&lt;Edge&gt; edges = opg.getEdges().iterator();
while (edges.hasNext()) {
edges.next();
countE++;
}

System.out.println("Edges found: " + countE);
</pre></li>
</ul>
</div>
</div>
<div class="sect2"><a id="GUID-71095D2A-E20F-4FD2-9571-A36031995D8C"></a>
<h2 id="BDSPA-GUID-71095D2A-E20F-4FD2-9571-A36031995D8C" class="sect2"><span class="enumeration_section">4.8</span> Implementing Security on Graphs Stored in Apache HBase</h2>
<div>
<p>Kerberos authentication is recommended for Apache HBase to secure property graphs in Oracle Big Data Spatial and Graph.</p>
<p>Oracle's property graph support works with both secure and non-secure Cloudera Hadoop (CDH) cluster installations. This topic provides information about secure Apache HBase installations.</p>
<p>Kerberos authentication is recommended for Apache HBase to secure property graphs in Oracle Big Data Spatial and Graph.</p>
<p>This topic assumes that a secure Apache HBase is already configured with Kerberos, that the client machine has the Kerberos libraries installed and that you have the correct credentials. For detailed information, see "Configuring Kerberos Authentication for HBase" at: <a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_sg_hbase_authentication.html" target="_blank"><code>http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_sg_hbase_authentication.html</code></a>. For information about how to set up your Kerberos cluster and clients, see the MIT Kerberos Documentation at <a href="http://web.mit.edu/kerberos/krb5-latest/doc/index.html" target="_blank"><code>http://web.mit.edu/kerberos/krb5-latest/doc/index.html</code></a>.</p>
<p>On the client side, you must have a Kerberos credential to interact with the Kerberos-enabled HDFS daemons. Additionally, you need to modify the Kerberos configuration information (located in <code>krb5.conf</code>) to include the realm and mappings of hostnames onto Kerberos realms used in the Secure CDH Cluster.</p>
<p>The following code fragment shows the realm and hostname mapping used in a Secure CDH cluster on BDA.COM:</p>
<pre dir="ltr">
[libdefaults]
 default_realm = EXAMPLE.COM
 dns_lookup_realm = false
 dns_lookup_kdc = false
 ticket_lifetime = 24h
 renew_lifetime = 7d
 forwardable = yes

[realms]
 EXAMPLE.COM = {
kdc = hostname1.example.com:88
kdc = hostname2.example.com:88
admin_server = hostname1.example.com:749
default_domain = example.com
 }
<span class="bold">BDA.COM = {
kdc = hostname1.bda.com:88
kdc = hostname2.bda.com:88
admin_server = hostname1.bda.com:749
default_domain = bda.com
 }
</span>
[domain_realm]
 .example.com = EXAMPLE.COM
 example.com = EXAMPLE.COM
 <span class="bold">.bda.com = BDA.COM
 bda.com = BDA.COM
</span>
</pre>
<p>After modifying <code>krb5.conf</code>, you can connect to a graph stored in Apache HBase by using a Java Authentication and Authorization Service (JAAS) configuration file to provide your credentials to the application. This provides the same capabilities of the preceding example without having to modify a single line of your code in case you already have an application that uses an insecure Apache HBase installation.</p>
<p>To use property graph support for for HBase with a JAAS configuration, create a file with content in the following form, replacing the <code>keytab</code> and <code>principal</code> entries with your own information:</p>
<pre dir="ltr">
Client {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab=true
useTicketCache=true
keyTab="/path/to/your/keytab/user.keytab"
principal="your-user/your.fully.qualified.domain.name@YOUR.REALM";
};
</pre>
<p>The following code fragment shows an example JAAS file with the realm used in a Secure CDH cluster on BDA.COM:</p>
<pre dir="ltr">
Client {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab=true
useTicketCache=true
keyTab="/path/to/keytab/user.keytab"
principal="hbaseuser/hostname1@BDA.COM";
};
</pre>
<p>In order to run your Secure HBase application you must specify the JAAS configuration file you created by using the java.security.auth.login.config flag. You can run your application using a command in the following format:</p>
<pre dir="ltr">
java -Djava.security.auth.login.config=/path/to/your/jaas.conf/ -classpath ./classes/:../../lib/'*' YourJavaApplication
</pre>
<p>Then, you can call <code>OraclePropertyGraph.getInstance(conf, hconn, szGraphName)</code> as usual to create an Oracle property graph.</p>
<p>Another option to use the Oracle Big Data Spatial and Graph property graph support on a secure Apache HBase installation is to use a secure HBase configuration. The following code fragment shows how to obtain a secure HBase configuration using prepareSecureConfig(). This API requires the security authentication setting used in Apache Hadoop and Apache HBase, as well as Kerberos credentials set to authenticate and obtain an authorized ticket.</p>
<p>The following code fragment creates a property graph in a Secure Apache HBase, loads the data, and then counts how many vertices and edges in the graph.</p>
<pre dir="ltr">
String szQuorum= "hostname1,hostname2,hostname3";
String szCliPort = "2181"; 
String szGraph = "SecureGraph";

<span class="bold">String hbaseSecAuth="kerberos";
String hadoopSecAuth="kerberos";
String hmKerberosPrincipal="hbase/_HOST@BDA.COM";
String rsKerberosPrincipal="hbase/_HOST@BDA.COM";
String userPrincipal = "hbase/hostname1@BDA.COM";
String keytab= "/path/to/your/keytab/hbase.keytab";
int dop= 8;</span>

Configuration conf = HBaseConfiguration.create();
conf.set("hbase.zookeeper.quorum", szQuorum);
conf.set("hbase.zookeeper.property.clientPort", szCliPort);

// Prepare the secure configuration providing the credentials in the keytab
conf = OraclePropertyGraph.prepareSecureConfig(conf, 
 hbaseSecAuth, 
 hadoopSecAuth, 
 hmKerberosPrincipal, 
 rsKerberosPrincipal, 
 userPrincipal, 
 keytab);
HConnection hconn = HConnectionManager.createConnection(conf);

OraclePropertyGraph opg=OraclePropertyGraph.getInstance(conf, hconn, szGraph);
opg.setInitialNumRegions(24);
opg.clearRepository();

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop);
opg.commit();
</pre></div>
</div>
<a id="BDSPA373"></a>
<div class="props_rev_3"><a id="GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A"></a>
<h2 id="BDSPA-GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A" class="sect2"><span class="enumeration_section">4.9</span> Using the Groovy Shell with Property Graph Data</h2>
<div>
<p>The Oracle Big Data Spatial and Graph property graph support includes a built-in Groovy shell (based on the original Gremlin Groovy shell script). With this command-line shell interface, you can explore the Java APIs.</p>
<p>To start the Groovy shell, go to the <code>dal/groovy</code> directory under the installation home (<code>/opt/oracle/oracle-spatial-graph/property_graph</code> by default). For example:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/dal/groovy/
</pre>
<p>Included are the scripts <code>gremlin-opg-nosql.sh</code> and <code>gremlin-opg-hbase.sh</code>, for connecting to an Oracle NoSQL Database and an Apache HBase, respectively.</p>
<div class="infobox-note" id="GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A__GUID-08B8E3DA-9227-4BF6-ABD3-7C3ABCC2CA38">
<p class="notep1">Note:</p>
To run some gremlin traversal examples, you must first do the following import operation:
<pre dir="ltr">
import com.tinkerpop.pipes.util.structures.*;
</pre></div>
<p>The following example connects to an Oracle NoSQL Database, gets an instance of <code>OraclePropertyGraph</code> with graph name <code>myGraph</code>, loads some example graph data, and gets the list of vertices and edges.</p>
<pre dir="ltr">
<span class="bold">$ ./gremlin-opg-nosql.sh</span>
 
opg-nosql&gt;
opg-nosql&gt; hhosts = new String[1];
==&gt;null
 
opg-nosql&gt; hhosts[0] = "bigdatalite:5000";
==&gt;bigdatalite:5000
 
opg-nosql&gt; cfg = GraphConfigBuilder.forPropertyGraphNosql().setName("myGraph").setHosts(Arrays.asList(hhosts)).setStoreName("mystore").addEdgeProperty("lbl", PropertyType.STRING, "lbl").addEdgeProperty("weight", PropertyType.DOUBLE, "1000000").build();
==&gt;{"db_engine":"NOSQL","loading":{},"format":"pg","name":"myGraph","error_handling":{},"hosts":["bigdatalite:5000"],"node_props":[],"store_name":"mystore","edge_props":[{"type":"string","name":"lbl","default":"lbl"},{"type":"double","name":"weight","default":"1000000"}]}
 
opg-nosql&gt; opg = OraclePropertyGraph.getInstance(cfg);
==&gt;oraclepropertygraph with name myGraph
 
opg-nosql&gt; opgdl = OraclePropertyGraphDataLoader.getInstance();
==&gt;oracle.pg.nosql.OraclePropertyGraphDataLoader@576f1cad
 
opg-nosql&gt; opgdl.loadData(opg, new FileInputStream("../../data/connections.opv"), new FileInputStream("../../data/connections.ope"), 1, 1, 0, null);
==&gt;null
 
opg-nosql&gt; opg.getVertices();
==&gt;Vertex ID 5 {country:str:Italy, name:str:Pope Francis, occupation:str:pope, religion:str:Catholicism, role:str:Catholic religion authority}
[... other output lines omitted for brevity ...]
 
opg-nosql&gt;  opg.getEdges();
==&gt;Edge ID 1139 from Vertex ID 64 {country:str:United States, name:str:Jeff Bezos, occupation:str:business man} =[leads]=&gt; Vertex ID 37 {country:str:United States, name:str:Amazon, type:str:online retailing} edgeKV[{weight:flo:1.0}]
[... other output lines omitted for brevity ...]
</pre>
<p>The following example customizes several configuration parameters for in-memory analytics. It connects to an Apache HBase, gets an instance of <code>OraclePropertyGraph</code> with graph name <code>myGraph</code>, loads some example graph data, gets the list of vertices and edges, gets an in-memory analyst, and execute one of the built-in analytics, triangle counting.</p>
<pre dir="ltr">
<span class="bold">$ ./gremlin-opg-hbase.sh</span>
opg-hbase&gt;
opg-hbase&gt; dop=2;   // degree of parallelism
==&gt;2
opg-hbase&gt; confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;();
opg-hbase&gt; confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop + 2);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, 3);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);
==&gt;null
opg-hbase&gt; instance = Pgx.getInstance()
==&gt;null
opg-hbase&gt; instance.startEngine(confPgx) 
==&gt;null

opg-hbase&gt; cfg = GraphConfigBuilder.forPropertyGraphHbase() .setName("myGraph") .setZkQuorum("bigdatalite") .setZkClientPort(iClientPort) .setZkSessionTimeout(60000) .setMaxNumConnections(dop) .setLoadEdgeLabel(true) .setSplitsPerRegion(1) .addEdgeProperty("lbl", PropertyType.STRING, "lbl") .addEdgeProperty("weight", PropertyType.DOUBLE, "1000000") .build();
==&gt;{"splits_per_region":1,"max_num_connections":2,"node_props":[],"format":"pg","load_edge_label":true,"name":"myGraph","zk_client_port":2181,"zk_quorum":"bigdatalite","edge_props":[{"type":"string","default":"lbl","name":"lbl"},{"type":"double","default":"1000000","name":"weight"}],"loading":{},"error_handling":{},"zk_session_timeout":60000,"db_engine":"HBASE"}
 
opg-hbase&gt; opg = OraclePropertyGraph.getInstance(cfg);  
==&gt;oraclepropertygraph with name myGraph
 
 
opg-hbase&gt; opgdl = OraclePropertyGraphDataLoader.getInstance();
==&gt;oracle.pg.hbase.OraclePropertyGraphDataLoader@3451289b
 
opg-hbase&gt; opgdl.loadData(opg, "../../data/connections.opv", "../../data/connections.ope", 1, 1, 0, null);
==&gt;null
 
opg-hbase&gt; opg.getVertices();
==&gt;Vertex ID 78 {country:str:United States, name:str:Hosain Rahman, occupation:str:CEO of Jawbone}
...
 
opg-hbase&gt; opg.getEdges();
==&gt;Edge ID 1139 from Vertex ID 64 {country:str:United States, name:str:Jeff Bezos, occupation:str:business man} =[leads]=&gt; Vertex ID 37 {country:str:United States, name:str:Amazon, type:str:online retailing} edgeKV[{weight:flo:1.0}]
[... other output lines omitted for brevity ...]
 
opg-hbase&gt; session = Pgx.createSession("session-id-1");
opg-hbase&gt; g = session.readGraphWithProperties(cfg);
opg-hbase&gt; analyst = session.createAnalyst();
 
opg-hbase&gt;  triangles = analyst.countTriangles(false).get();
==&gt;22
</pre>
<p>For detailed information about the Java APIs, see the Javadoc reference information in <code>doc/dal/</code> and <code>doc/pgx/</code> under the installation home (<code>/opt/oracle/oracle-spatial-graph/property_graph/</code> by default).</p>
</div>
</div>
<a id="BDSPA236"></a>
<div class="props_rev_3"><a id="GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C"></a>
<h2 id="BDSPA-GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C" class="sect2"><span class="enumeration_section">4.10</span> Exploring the Sample Programs</h2>
<div>
<p>The software installation includes a directory of example programs, which you can use to learn about creating and manipulating property graphs.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-8123198B-CF83-4860-8F59-352431B3EE97">About the Sample Programs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C">Compiling and Running the Sample Programs</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-995091E2-0002-4C92-A24A-A6B284118B71">About the Example Output</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3">Example: Creating a Property Graph</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-47690868-616C-4230-8DD5-BA7DAB129566">Example: Dropping a Property Graph</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778">Examples: Adding and Dropping Vertices and Edges</a></p>
</li>
</ul>
</div>
<a id="BDSPA238"></a><a id="BDSPA237"></a>
<div class="props_rev_3"><a id="GUID-8123198B-CF83-4860-8F59-352431B3EE97"></a>
<h3 id="BDSPA-GUID-8123198B-CF83-4860-8F59-352431B3EE97" class="sect3"><span class="enumeration_section">4.10.1</span> About the Sample Programs</h3>
<div>
<p>The sample programs are distributed in an installation subdirectory named <code>examples/dal</code>. The examples are replicated for HBase and Oracle NoSQL Database, so that you can use the set of programs corresponding to your choice of backend database. <a href="using-pgs-bigdata.htm#GUID-8123198B-CF83-4860-8F59-352431B3EE97__CEGFIGEG">Table 4-3</a> describes the some of the programs.</p>
<div class="tblformal" id="GUID-8123198B-CF83-4860-8F59-352431B3EE97__CEGFIGEG">
<hr />
<p class="titleintable">Table 4-3 Property Graph Program Examples (Selected)</p>
<table class="cellalignment336" title="Property Graph Program Examples (Selected)" summary="sample program descriptions">
<thead align="left">
<tr>
<th class="cellalignment346" id="d17953e4801">Program Name</th>
<th class="cellalignment347" id="d17953e4804">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="cellalignment346" id="d17953e4809" headers="d17953e4801">
<p>ExampleNoSQL1</p>
<p>ExampleHBase1</p>
</td>
<td class="cellalignment347" headers="d17953e4809 d17953e4804">
<p>Creates a minimal property graph consisting of one vertex, sets properties with various data types on the vertex, and queries the database for the saved graph description.</p>
</td>
</tr>
<tr>
<td class="cellalignment346" id="d17953e4818" headers="d17953e4801">
<p>ExampleNoSQL2</p>
<p>ExampleHBase2</p>
</td>
<td class="cellalignment347" headers="d17953e4818 d17953e4804">
<p>Creates the same minimal property graph as Example1, and then deletes it.</p>
</td>
</tr>
<tr>
<td class="cellalignment346" id="d17953e4827" headers="d17953e4801">
<p>ExampleNoSQL3</p>
<p>ExampleHBase3</p>
</td>
<td class="cellalignment347" headers="d17953e4827 d17953e4804">
<p>Creates a graph with multiple vertices and edges. Deletes some vertices and edges explicitly, and other implicitly by deleting other, required objects. This example queries the database repeatedly to show the current list of objects.</p>
</td>
</tr>
</tbody>
</table>
<hr /></div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="BDSPA240"></a><a id="BDSPA241"></a><a id="BDSPA239"></a>
<div class="props_rev_3"><a id="GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C"></a>
<h3 id="BDSPA-GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C" class="sect3"><span class="enumeration_section">4.10.2</span> Compiling and Running the Sample Programs</h3>
<div>
<p>To compile and run the Java source files:</p>
<ol>
<li>
<p>Change to the examples directory:</p>
<pre dir="ltr">
cd examples/dal
</pre></li>
<li>
<p>Use the Java compiler:</p>
<pre dir="ltr">
javac -classpath ../../lib/'*' filename.java
</pre>
<p>For example: <code>javac -classpath ../../lib/'*' ExampleNoSQL1.java</code></p>
</li>
<li>
<p>Execute the compiled code:</p>
<pre dir="ltr">
java -classpath ../../lib/'*':./ filename args
</pre>
<p>The arguments depend on whether you are using Oracle NoSQL Database or Apache HBase to store the graph. The values are passed to <code>OraclePropertyGraph.getInstance</code>.</p>
</li>
</ol>
<div class="section">
<p class="subhead3">Apache HBase Argument Descriptions</p>
</div>
<!-- class="section" -->
<div class="section">
<p>Provide these arguments when using the HBase examples:</p>
<ol>
<li>
<p><span class="italic">quorum</span>: A comma-delimited list of names identifying the nodes where HBase runs, such as <code>"node01.example.com, node02.example.com, node03.example.com"</code>.</p>
</li>
<li>
<p><span class="italic">client_port</span>: The HBase client port number, such as <code>"2181"</code>.</p>
</li>
<li>
<p><span class="italic">graph_name</span>: The name of the graph, such as <code>"customer_graph"</code>.</p>
</li>
</ol>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Oracle NoSQL Database Argument Descriptions</p>
</div>
<!-- class="section" -->
<div class="section">
<p>Provide these arguments when using the NoSQL examples:</p>
<ol>
<li>
<p><span class="italic">host_name</span>: The cluster name and port number for Oracle NoSQL Database registration, such as <code>"cluster02:5000"</code>.</p>
</li>
<li>
<p><span class="italic">store_name</span>: The name of the key-value store, such as <code>"kvstore"</code></p>
</li>
<li>
<p><span class="italic">graph_name</span>: The name of the graph, such as <code>"customer_graph"</code>.</p>
</li>
</ol>
</div>
<!-- class="section" --></div>
</div>
<a id="BDSPA243"></a><a id="BDSPA242"></a>
<div class="props_rev_3"><a id="GUID-995091E2-0002-4C92-A24A-A6B284118B71"></a>
<h3 id="BDSPA-GUID-995091E2-0002-4C92-A24A-A6B284118B71" class="sect3"><span class="enumeration_section">4.10.3</span> About the Example Output</h3>
<div>
<p>The example programs use <code>System.out.println</code> to retrieve the property graph descriptions from the database where it is stored, either Oracle NoSQL Database or Apache HBase. The key name, data type, and value are delimited by colons. For example, <code>weight:flo:30.0</code> indicates that the key name is <code>weight</code>, the data type is <code>float</code>, and the value is <code>30.0.</code></p>
<p><a href="using-pgs-bigdata.htm#GUID-995091E2-0002-4C92-A24A-A6B284118B71__CEGHEIAI">Table 4-4</a> identifies the data type abbreviations used in the output.</p>
<div class="tblformal" id="GUID-995091E2-0002-4C92-A24A-A6B284118B71__CEGHEIAI">
<hr />
<p class="titleintable">Table 4-4 Property Graph Data Type Abbreviations</p>
<table class="cellalignment336" title="Property Graph Data Type Abbreviations" summary="Property graph output data type abbrevations">
<thead align="left">
<tr>
<th class="cellalignment348" id="d17953e5054">Abbreviation</th>
<th class="cellalignment348" id="d17953e5057">Data Type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="cellalignment348" id="d17953e5062" headers="d17953e5054">
<p>bol</p>
</td>
<td class="cellalignment348" headers="d17953e5062 d17953e5057">
<p>Boolean</p>
</td>
</tr>
<tr>
<td class="cellalignment348" id="d17953e5069" headers="d17953e5054">
<p>dat</p>
</td>
<td class="cellalignment348" headers="d17953e5069 d17953e5057">
<p>date</p>
</td>
</tr>
<tr>
<td class="cellalignment348" id="d17953e5076" headers="d17953e5054">
<p>dbl</p>
</td>
<td class="cellalignment348" headers="d17953e5076 d17953e5057">
<p>double</p>
</td>
</tr>
<tr>
<td class="cellalignment348" id="d17953e5083" headers="d17953e5054">
<p>flo</p>
</td>
<td class="cellalignment348" headers="d17953e5083 d17953e5057">
<p>float</p>
</td>
</tr>
<tr>
<td class="cellalignment348" id="d17953e5090" headers="d17953e5054">
<p>int</p>
</td>
<td class="cellalignment348" headers="d17953e5090 d17953e5057">
<p>integer</p>
</td>
</tr>
<tr>
<td class="cellalignment348" id="d17953e5097" headers="d17953e5054">
<p>ser</p>
</td>
<td class="cellalignment348" headers="d17953e5097 d17953e5057">
<p>serializable</p>
</td>
</tr>
<tr>
<td class="cellalignment348" id="d17953e5104" headers="d17953e5054">
<p>str</p>
</td>
<td class="cellalignment348" headers="d17953e5104 d17953e5057">
<p>string</p>
</td>
</tr>
</tbody>
</table>
<hr /></div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="BDSPA245"></a><a id="BDSPA244"></a>
<div class="props_rev_3"><a id="GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3"></a>
<h3 id="BDSPA-GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3" class="sect3"><span class="enumeration_section">4.10.4</span> Example: Creating a Property Graph</h3>
<div>
<p><code>ExampleNoSQL1</code> and <code>ExampleHBase1</code> create a minimal property graph consisting of one vertex. The code fragment in <a href="using-pgs-bigdata.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3__BHBCBGCB">Example 4-5</a> creates a vertex named <code>v1</code> and sets properties with various data types. It then queries the database for the saved graph description.</p>
<div class="example" id="GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3__BHBCBGCB">
<p class="titleinexample">Example 4-5 Creating a Property Graph</p>
<pre dir="ltr">
// Create a property graph instance named opg
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(<span class="italic">args</span>);
 
// Clear all vertices and edges from opg
    opg.clearRepository();

// Create vertex v1 and assign it properties as key-value pairs
    Vertex v1 = opg.addVertex(1l);
    v1.setProperty("age",  Integer.valueOf(18));
    v1.setProperty("name", "Name");
    v1.setProperty("weight", Float.valueOf(30.0f));
    v1.setProperty("height", Double.valueOf(1.70d));
    v1.setProperty("female", Boolean.TRUE);
 
// Save the graph in the database
    opg.commit();

// Display the stored vertex description
System.out.println("Fetch 1 vertex: " + opg.getVertices().iterator().next());
 
// Close the graph instance
    opg.shutdown();
</pre>
<p>The <code>OraclePropertyGraph.getInstance</code> arguments (<span class="italic">args</span>) depend on whether you are using Oracle NoSQL Database or Apache HBase to store the graph. See <span class="q">"<a href="using-pgs-bigdata.htm#GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C">Compiling and Running the Sample Programs</a>"</span>.</p>
<p><code>System.out.println</code> displays the following output:</p>
<pre dir="ltr">
Fetch 1 vertex: Vertex ID 1 {age:int:18, name:str:Name, weight:flo:30.0, height:dbl:1.7, female:bol:true}
</pre>
<p>See the property graph support Javadoc (<code>/opt/oracle/oracle-spatial-graph/property_graph/doc/pgx</code> by default) for the following:</p>
<pre dir="ltr">
OraclePropertyGraph.addVertex
OraclePropertyGraph.clearRepository
OraclePropertyGraph.getInstance
OraclePropertyGraph.getVertices
OraclePropertyGraph.shutdown
Vertex.setProperty
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA247"></a><a id="BDSPA246"></a>
<div class="props_rev_3"><a id="GUID-47690868-616C-4230-8DD5-BA7DAB129566"></a>
<h3 id="BDSPA-GUID-47690868-616C-4230-8DD5-BA7DAB129566" class="sect3"><span class="enumeration_section">4.10.5</span> Example: Dropping a Property Graph</h3>
<div>
<p>ExampleNoSQL2 and ExampleHBase2 create a graph like the one in <span class="q">"<a href="using-pgs-bigdata.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3">Example: Creating a Property Graph</a>"</span>, and then drop it from the database.</p>
<p>The code fragment in <a href="using-pgs-bigdata.htm#GUID-47690868-616C-4230-8DD5-BA7DAB129566__BHBBHIDF">Example 4-6</a> drops the graph. See <span class="q">"<a href="using-pgs-bigdata.htm#GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C">Compiling and Running the Sample Programs</a>"</span> for descriptions of the <code>OraclePropertyGraphUtils.dropPropertyGraph</code> arguments.</p>
<div class="example" id="GUID-47690868-616C-4230-8DD5-BA7DAB129566__BHBBHIDF">
<p class="titleinexample">Example 4-6 Dropping a Property Graph</p>
<pre dir="ltr">
// Drop the property graph from the database
OraclePropertyGraphUtils.dropPropertyGraph(<span class="italic">args</span>);

// Display confirmation that the graph was dropped
System.out.println("Graph " + <span class="italic">graph_name</span> + " dropped. ");
</pre>
<p><code>System.out.println</code> displays the following output:</p>
<pre dir="ltr">
Graph <span class="italic">graph_name</span> dropped.
</pre>
<p>See the Javadoc for <code>OraclePropertyGraphUtils.dropPropertyGraph</code>.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="BDSPA249"></a><a id="BDSPA250"></a><a id="BDSPA251"></a><a id="BDSPA252"></a><a id="BDSPA248"></a>
<div class="props_rev_3"><a id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778"></a>
<h3 id="BDSPA-GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778" class="sect3"><span class="enumeration_section">4.10.6</span> Examples: Adding and Dropping Vertices and Edges</h3>
<div>
<p>ExampleNoSQL3 and ExampleHBase3 add and drop both vertices and edges.</p>
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCBCFH">
<p class="titleinexample">Example 4-7 Creating the Vertices</p>
<p>The code fragment in <a href="using-pgs-bigdata.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCBCFH">Example 4-7</a> creates three vertices. It is a simple variation of <a href="using-pgs-bigdata.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3__BHBCBGCB">Example 4-5</a>.</p>
<pre dir="ltr">
// Create a property graph instance named opg
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(<span class="italic">args</span>);
 
// Clear all vertices and edges from opg
    opg.clearRepository();

// Add vertices a, b, and c
    Vertex a = opg.addVertex(1l);
    a.setProperty("name", "Alice");
    a.setProperty("age", 31);
  
    Vertex b = opg.addVertex(2l);  
    b.setProperty("name", "Bob");
    b.setProperty("age", 27);
 
    Vertex c = opg.addVertex(3l);
    c.setProperty("name", "Chris");
    c.setProperty("age", 33);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHIGH">
<p class="titleinexample">Example 4-8 Creating the Edges</p>
<p>The code fragment in <a href="using-pgs-bigdata.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHIGH">Example 4-8</a> uses vertices a, b, and c to create the edges.</p>
<pre dir="ltr">
// Add edges e1, e2, and e3
    Edge e1 = opg.addEdge(1l, a, b, "knows");
    e1.setProperty("type", "partners");
 
    Edge e2 = opg.addEdge(2l, a, c, "knows");
    e2.setProperty("type", "friends");
 
    Edge e3 = opg.addEdge(3l, b, c, "knows");
    e3.setProperty("type", "colleagues");
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHGCE">
<p class="titleinexample">Example 4-9 Deleting Edges and Vertices</p>
<p>The code fragment in <a href="using-pgs-bigdata.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHGCE">Example 4-9</a> explicitly deletes edge <code>e3</code> and vertex <code>b</code>. It implicitly deletes edge <code>e1</code>, which was connected to vertex <code>b</code>.</p>
<pre dir="ltr">
 // Remove edge e3
    opg.removeEdge(e3);

// Remove vertex b and all related edges
    opg.removeVertex(b);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBEIDEH">
<p class="titleinexample">Example 4-10 Querying for Vertices and Edges</p>
<p>This example queries the database to show when objects are added and dropped. The code fragment in <a href="using-pgs-bigdata.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBEIDEH">Example 4-10</a> shows the method used.</p>
<pre dir="ltr">
// Print all vertices
    vertices = opg.getVertices().iterator();
    System.out.println("----- Vertices ----");
    vCount = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      vCount++;
    }
    System.out.println("Vertices found: " + vCount);
 
    // Print all edges
    edges = opg.getEdges().iterator();
    System.out.println("----- Edges ----");
    eCount = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      eCount++;
    }
    System.out.println("Edges found: " + eCount);
</pre>
<p>The examples in this topic may produce output like the following:</p>
<pre dir="ltr">
----- Vertices ----
Vertex ID 3 {name:str:Chris, age:int:33}
Vertex ID 1 {name:str:Alice, age:int:31}
Vertex ID 2 {name:str:Bob, age:int:27}
Vertices found: 3
----- Edges ----
Edge ID 2 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:friends}]
Edge ID 3 from Vertex ID 2 {name:str:Bob, age:int:27} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:colleagues}]
Edge ID 1 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 2 {name:str:Bob, age:int:27} edgeKV[{type:str:partners}]
Edges found: 3
 Remove edge Edge ID 3 from Vertex ID 2 {name:str:Bob, age:int:27} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:colleagues}]
----- Vertices ----
Vertex ID 1 {name:str:Alice, age:int:31}
Vertex ID 2 {name:str:Bob, age:int:27}
Vertex ID 3 {name:str:Chris, age:int:33}
Vertices found: 3
----- Edges ----
Edge ID 2 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:friends}]
Edge ID 1 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 2 {name:str:Bob, age:int:27} edgeKV[{type:str:partners}]
Edges found: 2
Remove vertex Vertex ID 2 {name:str:Bob, age:int:27}
----- Vertices ----
Vertex ID 1 {name:str:Alice, age:int:31}
Vertex ID 3 {name:str:Chris, age:int:33}
Vertices found: 2
----- Edges ----
Edge ID 2 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:friends}]
Edges found: 1
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="BDSPA254"></a>
<div class="props_rev_3"><a id="GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5"></a>
<h2 id="BDSPA-GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5" class="sect2"><span class="enumeration_section">4.11</span> Oracle Flat File Format Definition</h2>
<div>
<p>A property graph can be defined in two flat files, specifically description files for the vertices and edges.</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-pgs-bigdata.htm#GUID-5DA27116-5238-45AA-8D4F-78A66D320F5A">About the Property Graph Description Files</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71">Vertex File</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A">Edge File</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-A6950802-B4B6-4698-8513-ED7D05357F9B">Encoding Special Characters</a></p>
</li>
<li>
<p><a href="using-pgs-bigdata.htm#GUID-A5A1666F-53CF-41DE-A814-1C70F44E70ED">Example Property Graph in Oracle Flat File Format</a></p>
</li>
</ul>
</div>
<a id="BDSPA255"></a>
<div class="props_rev_3"><a id="GUID-5DA27116-5238-45AA-8D4F-78A66D320F5A"></a>
<h3 id="BDSPA-GUID-5DA27116-5238-45AA-8D4F-78A66D320F5A" class="sect3"><span class="enumeration_section">4.11.1</span> About the Property Graph Description Files</h3>
<div>
<p>A pair of files describe a property graph:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Vertex file</span>: Describes the vertices of the property graph. This file has an <code>.opv</code> file name extension.</p>
</li>
<li>
<p><span class="bold">Edge file</span>: Describes the edges of the property graph. This file has an <code>.ope</code> file name extension.</p>
</li>
</ul>
<p>It is recommended that these two files share the same base name. For example, <code>simple.opv</code> and <code>simple.ope</code> define a property graph.</p>
</div>
</div>
<a id="BDSPA257"></a><a id="BDSPA256"></a>
<div class="props_rev_3"><a id="GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71"></a>
<h3 id="BDSPA-GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71" class="sect3"><span class="enumeration_section">4.11.2</span> Vertex File</h3>
<div>
<p>Each line in a vertex file is a record that describes a vertex of the property graph. A record can describe one key-value property of a vertex, thus multiple records/lines are used to describe a vertex with multiple properties.</p>
<p>A record contains six fields separated by commas. Each record must contain five commas to delimit all fields, whether or not they have values:</p>
<p><span class="italic">vertex_ID, key_name, value_type, value, value, value</span></p>
<p><a href="using-pgs-bigdata.htm#GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71__BHBCCEDI">Table 4-5</a> describes the fields composing a vertex file record.</p>
<div class="tblformal" id="GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71__BHBCCEDI">
<hr />
<p class="titleintable">Table 4-5 Vertex File Record Format</p>
<table class="cellalignment336" title="Vertex File Record Format" summary="Vertex file field descriptions. Columns are Field Number, Name, and Description.">
<thead align="left">
<tr>
<th class="cellalignment349" id="d17953e5629">Field Number</th>
<th class="cellalignment350" id="d17953e5632">Name</th>
<th class="cellalignment351" id="d17953e5635">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="cellalignment349" id="d17953e5640" headers="d17953e5629">
<p>1</p>
</td>
<td class="cellalignment350" headers="d17953e5640 d17953e5632">
<p><span class="italic">vertex_ID</span></p>
</td>
<td class="cellalignment351" headers="d17953e5640 d17953e5635">
<p>An integer that uniquely identifies the vertex</p>
</td>
</tr>
<tr>
<td class="cellalignment349" id="d17953e5651" headers="d17953e5629">
<p>2</p>
</td>
<td class="cellalignment350" headers="d17953e5651 d17953e5632">
<p><span class="italic">key_name</span></p>
</td>
<td class="cellalignment351" headers="d17953e5651 d17953e5635">
<p>The name of the key in the key-value pair</p>
<p>If the vertex has no properties, then enter a space (<code>%20</code>). This example describes vertex 1 with no properties:</p>
<pre dir="ltr">
1,%20,,,,
</pre></td>
</tr>
<tr>
<td class="cellalignment349" id="d17953e5669" headers="d17953e5629">
<p>3</p>
</td>
<td class="cellalignment350" headers="d17953e5669 d17953e5632">
<p><span class="italic">value_type</span></p>
</td>
<td class="cellalignment351" headers="d17953e5669 d17953e5635">
<p>An integer that represents the data type of the value in the key-value pair:</p>
<ul class="simple">
<li><code>1</code> String</li>
<li><code>2</code> Integer</li>
<li><code>3</code> Float</li>
<li><code>4</code> Double</li>
<li><code>5</code> Date</li>
<li><code>6</code> Boolean</li>
<li><code>7</code> Long integer</li>
<li><code>8</code> Short integer</li>
<li><code>9</code> Byte</li>
<li><code>10</code> Char</li>
<li><code>101</code> Serializable Java object</li>
</ul>
</td>
</tr>
<tr>
<td class="cellalignment349" id="d17953e5725" headers="d17953e5629">
<p>4</p>
</td>
<td class="cellalignment350" headers="d17953e5725 d17953e5632">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment351" headers="d17953e5725 d17953e5635">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is neither numeric nor date</p>
</td>
</tr>
<tr>
<td class="cellalignment349" id="d17953e5739" headers="d17953e5629">
<p>5</p>
</td>
<td class="cellalignment350" headers="d17953e5739 d17953e5632">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment351" headers="d17953e5739 d17953e5635">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is numeric</p>
</td>
</tr>
<tr>
<td class="cellalignment349" id="d17953e5753" headers="d17953e5629">
<p>6</p>
</td>
<td class="cellalignment350" headers="d17953e5753 d17953e5632">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment351" headers="d17953e5753 d17953e5635">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is a date</p>
<p>Use the Java <code>SimpleDateFormat</code> class to identify the format of the date. This example describes the date format of <code>2015-03-26T00:00:00.000-05:00</code>:</p>
<pre dir="ltr">
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX"); encode(sdf.format((java.util.Date) value));
</pre></td>
</tr>
</tbody>
</table>
<hr /></div>
<!-- class="inftblhruleinformal" -->
<p><span class="bold">Required Grouping of Vertices</span>: A vertex can have multiple properties, and the vertex file includes a record (represented by a single line of text in the flat file) for each combination of a vertex ID and a property for that vertex. In the vertex file, all records for each vertex must be grouped together (that is, not have any intervening records for other vertices. You can accomplish this any way you want, but a convenient way is to sort the vertex file records in ascending (or descending) order by vertex ID. (Note, however, a vertex file is not required to have all records sorted by vertex ID; this is merely one way to achieve the grouping requirement.)</p>
</div>
</div>
<a id="BDSPA259"></a><a id="BDSPA258"></a>
<div class="props_rev_3"><a id="GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A"></a>
<h3 id="BDSPA-GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A" class="sect3"><span class="enumeration_section">4.11.3</span> Edge File</h3>
<div>
<p>Each line in an edge file is a record that describes an edge of the property graph. A record can describe one key-value property of an edge, thus multiple records are used to describe an edge with multiple properties.</p>
<p>A record contains nine fields separated by commas. Each record must contain eight commas to delimit all fields, whether or not they have values:</p>
<p><span class="italic">edge_ID, source_vertex_ID, destination_vertex_ID, edge_label, key_name, value_type, value, value, value</span></p>
<p><a href="using-pgs-bigdata.htm#GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A__BHBBIECI">Table 4-6</a> describes the fields composing an edge file record.</p>
<div class="tblformal" id="GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A__BHBBIECI">
<hr />
<p class="titleintable">Table 4-6 Edge File Record Format</p>
<table class="cellalignment336" title="Edge File Record Format" summary="Edge file field descriptions. Columns are Field Number, Name, and Description.">
<thead align="left">
<tr>
<th class="cellalignment352" id="d17953e5852">Field Number</th>
<th class="cellalignment353" id="d17953e5855">Name</th>
<th class="cellalignment354" id="d17953e5858">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="cellalignment352" id="d17953e5863" headers="d17953e5852">
<p>1</p>
</td>
<td class="cellalignment353" headers="d17953e5863 d17953e5855">
<p><span class="italic">edge_ID</span></p>
</td>
<td class="cellalignment354" headers="d17953e5863 d17953e5858">
<p>An integer that uniquely identifies the edge</p>
</td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e5874" headers="d17953e5852">
<p>2</p>
</td>
<td class="cellalignment353" headers="d17953e5874 d17953e5855">
<p><span class="italic">source_vertex_ID</span></p>
</td>
<td class="cellalignment354" headers="d17953e5874 d17953e5858">
<p>The <span class="italic">vertex_ID</span> of the outgoing tail of the edge.</p>
</td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e5888" headers="d17953e5852">
<p>3</p>
</td>
<td class="cellalignment353" headers="d17953e5888 d17953e5855">
<p><span class="italic">destination_vertex_ID</span></p>
</td>
<td class="cellalignment354" headers="d17953e5888 d17953e5858">
<p>The <span class="italic">vertex_ID</span> of the incoming head of the edge.</p>
</td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e5902" headers="d17953e5852">
<p>4</p>
</td>
<td class="cellalignment353" headers="d17953e5902 d17953e5855">
<p><span class="italic">edge_label</span></p>
</td>
<td class="cellalignment354" headers="d17953e5902 d17953e5858">
<p>The encoded label of the edge, which describes the relationship between the two vertices</p>
</td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e5913" headers="d17953e5852">
<p>5</p>
</td>
<td class="cellalignment353" headers="d17953e5913 d17953e5855">
<p><span class="italic">key_name</span></p>
</td>
<td class="cellalignment354" headers="d17953e5913 d17953e5858">
<p>The encoded name of the key in a key-value pair</p>
<p>If the edge has no properties, then enter a space (<code>%20</code>). This example describes edge 100 with no properties:</p>
<pre dir="ltr">
100,1,2,likes,%20,,,,
</pre></td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e5931" headers="d17953e5852">
<p>6</p>
</td>
<td class="cellalignment353" headers="d17953e5931 d17953e5855">
<p><span class="italic">value_type</span></p>
</td>
<td class="cellalignment354" headers="d17953e5931 d17953e5858">
<p>An integer that represents the data type of the value in the key-value pair:</p>
<ul class="simple">
<li><code>1</code> String</li>
<li><code>2</code> Integer</li>
<li><code>3</code> Float</li>
<li><code>4</code> Double</li>
<li><code>5</code> Date</li>
<li><code>6</code> Boolean</li>
<li><code>7</code> Long integer</li>
<li><code>8</code> Short integer</li>
<li><code>9</code> Byte</li>
<li><code>10</code> Char</li>
<li><code>101</code> Serializable Java object</li>
</ul>
</td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e5987" headers="d17953e5852">
<p>7</p>
</td>
<td class="cellalignment353" headers="d17953e5987 d17953e5855">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment354" headers="d17953e5987 d17953e5858">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is neither numeric nor date</p>
</td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e6001" headers="d17953e5852">
<p>8</p>
</td>
<td class="cellalignment353" headers="d17953e6001 d17953e5855">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment354" headers="d17953e6001 d17953e5858">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is numeric</p>
</td>
</tr>
<tr>
<td class="cellalignment352" id="d17953e6015" headers="d17953e5852">
<p>9</p>
</td>
<td class="cellalignment353" headers="d17953e6015 d17953e5855">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment354" headers="d17953e6015 d17953e5858">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is a date</p>
<p>Use the Java <code>SimpleDateFormat</code> class to identify the format of the date. This example describes the date format of <code>2015-03-26Th00:00:00.000-05:00</code>:</p>
<pre dir="ltr">
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'Th'HH:mm:ss.SSSXXX"); encode(sdf.format((java.util.Date) value));
</pre></td>
</tr>
</tbody>
</table>
<hr /></div>
<!-- class="inftblhruleinformal" -->
<p><span class="bold">Required Grouping of Edges</span>: An edge can have multiple properties, and the edge file includes a record (represented by a single line of text in the flat file) for each combination of an edge ID and a property for that edge. In the edge file, all records for each edge must be grouped together (that is, not have any intervening records for other edges. You can accomplish this any way you want, but a convenient way is to sort the edge file records in ascending (or descending) order by edge ID. (Note, however, an edge file is not required to have all records sorted by edge ID; this is merely one way to achieve the grouping requirement.)</p>
</div>
</div>
<a id="BDSPA261"></a><a id="BDSPA260"></a>
<div class="props_rev_3"><a id="GUID-A6950802-B4B6-4698-8513-ED7D05357F9B"></a>
<h3 id="BDSPA-GUID-A6950802-B4B6-4698-8513-ED7D05357F9B" class="sect3"><span class="enumeration_section">4.11.4</span> Encoding Special Characters</h3>
<div>
<p>The encoding is UTF-8 for the vertex and edge files. <a href="using-pgs-bigdata.htm#GUID-A6950802-B4B6-4698-8513-ED7D05357F9B__BHBEFDGC">Table 4-7</a> lists the special characters that must be encoded as strings when they appear in a vertex or edge property (key-value pair) or an edge label. No other characters require encoding.</p>
<div class="tblformal" id="GUID-A6950802-B4B6-4698-8513-ED7D05357F9B__BHBEFDGC">
<hr />
<p class="titleintable">Table 4-7 Special Character Codes in the Oracle Flat File Format</p>
<table class="cellalignment336" title="Special Character Codes in the Oracle Flat File Format" summary="Special character encoding">
<thead align="left">
<tr>
<th class="cellalignment355" id="d17953e6107">Special Character</th>
<th class="cellalignment356" id="d17953e6110">String Encoding</th>
<th class="cellalignment356" id="d17953e6113">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="cellalignment355" id="d17953e6118" headers="d17953e6107">
<p><code>%</code></p>
</td>
<td class="cellalignment356" headers="d17953e6118 d17953e6110">
<p><code>%25</code></p>
</td>
<td class="cellalignment356" headers="d17953e6118 d17953e6113">
<p>Percent</p>
</td>
</tr>
<tr>
<td class="cellalignment355" id="d17953e6130" headers="d17953e6107">
<p><code>\t</code></p>
</td>
<td class="cellalignment356" headers="d17953e6130 d17953e6110">
<p><code>%09</code></p>
</td>
<td class="cellalignment356" headers="d17953e6130 d17953e6113">
<p>Tab</p>
</td>
</tr>
<tr>
<td class="cellalignment355" id="d17953e6142" headers="d17953e6107">&nbsp;</td>
<td class="cellalignment356" headers="d17953e6142 d17953e6110">
<p><code>%20</code></p>
</td>
<td class="cellalignment356" headers="d17953e6142 d17953e6113">
<p>Space</p>
</td>
</tr>
<tr>
<td class="cellalignment355" id="d17953e6154" headers="d17953e6107">
<p><code>\n</code></p>
</td>
<td class="cellalignment356" headers="d17953e6154 d17953e6110">
<p><code>%0A</code></p>
</td>
<td class="cellalignment356" headers="d17953e6154 d17953e6113">
<p>New line</p>
</td>
</tr>
<tr>
<td class="cellalignment355" id="d17953e6166" headers="d17953e6107">
<p><code>\r</code></p>
</td>
<td class="cellalignment356" headers="d17953e6166 d17953e6110">
<p><code>%0D</code></p>
</td>
<td class="cellalignment356" headers="d17953e6166 d17953e6113">
<p>Return</p>
</td>
</tr>
<tr>
<td class="cellalignment355" id="d17953e6178" headers="d17953e6107">
<p><code>,</code></p>
</td>
<td class="cellalignment356" headers="d17953e6178 d17953e6110">
<p><code>%2C</code></p>
</td>
<td class="cellalignment356" headers="d17953e6178 d17953e6113">
<p>Comma</p>
</td>
</tr>
</tbody>
</table>
<hr /></div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="BDSPA262"></a>
<div class="props_rev_3"><a id="GUID-A5A1666F-53CF-41DE-A814-1C70F44E70ED"></a>
<h3 id="BDSPA-GUID-A5A1666F-53CF-41DE-A814-1C70F44E70ED" class="sect3"><span class="enumeration_section">4.11.5</span> Example Property Graph in Oracle Flat File Format</h3>
<div>
<p>An example property graph in Oracle flat file format is as follows. In this example, there are two vertices (John and Mary), and a single edge denoting that John is a friend of Mary.</p>
<pre dir="ltr">
%cat simple.opv
1,age,2,,10,
1,name,1,John,,
2,name,1,Mary,,
2,hobby,1,soccer,,
 
%cat simple.ope
100,1,2,friendOf,%20,,,,
</pre></div>
</div>
</div>
<a id="BDSPA263"></a>
<div class="props_rev_3"><a id="GUID-F363808E-6416-4B2D-AFE6-49B9C91B9EED"></a>
<h2 id="BDSPA-GUID-F363808E-6416-4B2D-AFE6-49B9C91B9EED" class="sect2"><span class="enumeration_section">4.12</span> Example Python User Interface</h2>
<div>
<p>The Oracle Big Data Spatial and Graph support for property graphs includes an example Python user interface. It can invoke a set of example Python scripts and modules that perform a variety of property graph operations.</p>
<p>Instructions for installing the example Python user interface are in the <code>/property_graph/examples/pyopg/README</code> file under the installation home (<code>/opt/oracle/oracle-spatial-graph</code> by default).</p>
<p>The example Python scripts in <code>/property_graph/examples/pyopg/</code> can used with Oracle Spatial and Graph Property Graph, and you may want to change and enhance them (or copies of them) to suit your needs.</p>
<p>To invoke the user interface to run the examples, use the script <code>pyopg.sh</code>.</p>
<p>The examples include the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Example 1: Connect to an Oracle NoSQL Database and perform a simple check of number of vertices and edges. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectONDB("mygraph", "kvstore", "localhost:5000")
print "vertices", countV()
print "edges", countE()
</pre>
<p>In the preceding example, <code>mygraph</code> is the name of the graph stored in the Oracle NoSQL Database, <code>kvstore</code> and <code>localhost:5000</code> are the connection information to access the Oracle NoSQL Database. They must be customized for your environment.</p>
</li>
<li>
<p>Example 2: Connect to an Apache HBase and perform a simple check of number of vertices and edges. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectHBase("mygraph", "localhost", "2181")
print "vertices", countV()
print "edges", countE()
</pre>
<p>In the preceding example, <code>mygraph</code> is the name of the graph stored in the Apache HBase, and <code>localhost</code> and <code>2181</code> are the connection information to access the Apache HBase. They must be customized for your environment.</p>
</li>
<li>
<p>Example 3: Connect to an Oracle NoSQL Database and run a few analytical functions. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectONDB("mygraph", "kvstore", "localhost:5000")
print "vertices", countV()
print "edges", countE()
 
import pprint
 
analyzer = analyst()
print "# triangles in the graph", analyzer.countTriangles()
 
graph_communities = [{"commid":i.getName(),"size":i.size()} for i in analyzer.communities().iterator()]
 
import pandas as pd
import numpy as np
 
community_frame = pd.DataFrame(graph_communities)
community_frame[:5]
 
import matplotlib as mpl
import matplotlib.pyplot as plt
 
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(16,12));
community_frame["size"].plot(kind="bar", title="Communities and Sizes")
ax.set_xticklabels(community_frame.index);
plt.show()
</pre>
<p>The preceding example connects to an Oracle NoSQL Database, prints basic information about the vertices and edges, get an in memory analyst, computes the number of triangles, performs community detection, and finally plots out in a bar chart communities and their sizes.</p>
</li>
<li>
<p>Example 4: Connect to an Apache HBase and run a few analytical functions. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectHBase("mygraph", "localhost", "2181")
print "vertices", countV()
print "edges", countE()
 
import pprint
 
analyzer = analyst()
print "# triangles in the graph", analyzer.countTriangles()
 
graph_communities = [{"commid":i.getName(),"size":i.size()} for i in analyzer.communities().iterator()]
import pandas as pd
import numpy as np
community_frame = pd.DataFrame(graph_communities)
community_frame[:5]
 
import matplotlib as mpl
import matplotlib.pyplot as plt
 
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(16,12));
community_frame["size"].plot(kind="bar", title="Communities and Sizes")
ax.set_xticklabels(community_frame.index);
plt.show()
</pre>
<p>The preceding example connects to an Apache HBase, prints basic information about the vertices and edges, gets an in-memory analyst, computes the number of triangles, performs community detection, and finally plots out in a bar chart communities and their sizes.</p>
</li>
</ul>
<p>For detailed information about this example Python interface, see the following directory under the installation home:</p>
<pre dir="ltr">
property_graph/examples/pyopg/doc/
</pre></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment324">
<tr>
<td class="cellalignment331">
<table class="cellalignment329">
<tr>
<td class="cellalignment328"><a href="config-pg-support.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment328"><a href="using-inmem-analytics.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2015, 2016, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment333">
<table class="cellalignment327">
<tr>
<td class="cellalignment328"><a href="../index.htm"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment328"><a href="../nav/portal_booklist.htm"><img width="24" height="24" src="../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment328"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment328"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment328"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
