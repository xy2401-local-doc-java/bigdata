<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Using Property Graphs in a Big Data Environment</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="description" content="This chapter provides conceptual and usage information about creating, storing, and working with property graph data in a Big Data environment." />
<meta name="keywords" content=", PGQL (Property Graph Query Language), Property Graph Query Language (PGQL), Apache Spark, using with property graph data, Spark, Apache HBase, using Apache Spark with property graph data, NoSQL" />
<meta name="dcterms.created" content="2017-08-11T06:40:03Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Big Data Spatial and Graph User&rsquo;s Guide and Reference" />
<meta name="dcterms.identifier" content="E67958-12" />
<meta name="dcterms.isVersionOf" content="BDSPA" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2015, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://docs.oracle.com/bigdata/bda49/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="configuring-property-graph-support.htm" title="Previous" type="text/html" />
<link rel="Next" href="using-in-memory-analyst.htm" title="Next" type="text/html" />
<link rel="alternate" href="BDSPA.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-FF0B76C5-0626-441B-A750-102C02A0C7AA"></a> <span id="PAGE" style="display:none;">11/15</span> <!-- End Header -->
<a id="BDSPA191"></a>
<h1 id="BDSPA-GUID-FF0B76C5-0626-441B-A750-102C02A0C7AA" class="sect1"><span class="enumeration_chapter">5</span> Using Property Graphs in a Big Data Environment</h1>
<div>
<p>This chapter provides conceptual and usage information about creating, storing, and working with property graph data in a Big Data environment.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-2ECE6EAB-383A-44D6-8C25-25F5FCB5A26D">About Property Graphs</a><br />
Property graphs allow an easy association of properties (key-value pairs) with graph vertices and edges, and they enable analytical operations based on relationships across a massive set of data.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-349A3705-6A70-4A35-A71B-7E3D65AB42CA">About Property Graph Data Formats</a><br />
The following graph formats are supported.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-C621157E-AB7C-4B98-86C5-02D22FA7A20E">Getting Started with Property Graphs</a><br />
To get started with property graphs, follow these main steps.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B">Using Java APIs for Property Graph Data</a><br />
Creating a property graph involves using the Java APIs to create the property graph and objects in it.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-727847CA-F6C9-40BD-B9BA-7FA48AF7D804">Managing Text Indexing for Property Graph Data</a><br />
Indexes in Oracle Big Data Spatial and Graph allow fast retrieval of elements by a particular key/value or key/text pair. These indexes are created based on an element type (vertices or edges), a set of keys (and values), and an index type.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-25432BC8-B8EA-494E-8A6A-5C19ECD6760F">Querying Property Graph Data Using PGQL</a><br />
Oracle Big Data Spatial and Graph supports a rich set of graph pattern matching capabilities.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-EFECEBBB-6BD6-4A63-B962-DB5AD7EB4C03">Using Apache Spark with Property Graph Data</a><br />
Apache Spark lets you process large amounts of data efficiently, and it comes with a set of libraries for processing data:&nbsp;SQL,&nbsp;MLlib, Spark Streaming, and&nbsp;DataFrames, Apache Spark can read data from different sources, such as HDFS, Oracle NoSQL Database, and Apache HBase.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-924E8670-F550-41F9-884A-1998409A7544">Support for Secure Oracle NoSQL Database</a><br />
Oracle Big Data Spatial and Graph property graph support works with both secure and non-secure Oracle NoSQL Database installations. This topic provides information about how to use property graph functions with a secure Oracle NoSQL Database setup.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-71095D2A-E20F-4FD2-9571-A36031995D8C">Implementing Security on Graphs Stored in Apache HBase</a><br />
Kerberos authentication is recommended for Apache HBase to secure property graphs in Oracle Big Data Spatial and Graph.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A">Using the Groovy Shell with Property Graph Data</a><br />
The Oracle Big Data Spatial and Graph property graph support includes a built-in Groovy shell (based on the original Gremlin Groovy shell script). With this command-line shell interface, you can explore the Java APIs.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C">Exploring the Sample Programs</a><br />
The software installation includes a directory of example programs, which you can use to learn about creating and manipulating property graphs.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5">Oracle Flat File Format Definition</a><br />
A property graph can be defined in two flat files, specifically description files for the vertices and edges.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-F363808E-6416-4B2D-AFE6-49B9C91B9EED">Example Python User Interface</a><br />
The Oracle Big Data Spatial and Graph support for property graphs includes an example Python user interface. It can invoke a set of example Python scripts and modules that perform a variety of property graph operations.</li>
</ul>
</div>
<a id="BDSPA192"></a>
<div class="props_rev_3"><a id="GUID-2ECE6EAB-383A-44D6-8C25-25F5FCB5A26D"></a>
<h2 id="BDSPA-GUID-2ECE6EAB-383A-44D6-8C25-25F5FCB5A26D" class="sect2"><span class="enumeration_section">5.1</span> About Property Graphs</h2>
<div>
<p>Property graphs allow an easy association of properties (key-value pairs) with graph vertices and edges, and they enable analytical operations based on relationships across a massive set of data.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD">What Are Property Graphs?</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A">What Is Big Data Support for Property Graphs?</a><br /></li>
</ul>
</div>
<a id="BDSPA194"></a><a id="BDSPA193"></a>
<div class="props_rev_3"><a id="GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD"></a>
<h3 id="BDSPA-GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD" class="sect3"><span class="enumeration_section">5.1.1</span> What Are Property Graphs?</h3>
<div>
<p>A property graph consists of a set of objects or <span class="bold">vertices</span>, and a set of arrows or <span class="bold">edges</span> connecting the objects. Vertices and edges can have multiple properties, which are represented as key-value pairs.</p>
<p>Each vertex has a unique identifier and can have:</p>
<ul style="list-style-type: disc;">
<li>
<p>A set of outgoing edges</p>
</li>
<li>
<p>A set of incoming edges</p>
</li>
<li>
<p>A collection of properties</p>
</li>
</ul>
<p>Each edge has a unique identifier and can have:</p>
<ul style="list-style-type: disc;">
<li>
<p>An outgoing vertex</p>
</li>
<li>
<p>An incoming vertex</p>
</li>
<li>
<p>A text label that describes the relationship between the two vertices</p>
</li>
<li>
<p>A collection of properties</p>
</li>
</ul>
<p><a href="using-property-graphs-big-data.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 5-1</a> illustrates a very simple property graph with two vertices and one edge. The two vertices have identifiers 1 and 2. Both vertices have properties <code class="codeph">name</code> and <code class="codeph">age</code>. The edge is from the outgoing vertex 1 to the incoming vertex 2. The edge has a text label <code class="codeph">knows</code> and a property <code class="codeph">type</code> identifying the type of relationship between vertices 1 and 2.</p>
<div class="figure" id="GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">
<p class="titleinfigure">Figure 5-1 Simple Property Graph Example</p>
<img width="265" height="113" src="img/GUID-CBE7DF5E-2A8D-4108-A0E5-31A15A5766B0-default.png" alt="Description of Figure 5-1 follows" title="Description of Figure 5-1 follows" /><br />
<a href="img_text/GUID-CBE7DF5E-2A8D-4108-A0E5-31A15A5766B0-default.htm">Description of "Figure 5-1 Simple Property Graph Example"</a></div>
<!-- class="figure" -->
<p>Standards are not available for Big Data Spatial and Graph property graph data model, but it is similar to the W3C standards-based Resource Description Framework (RDF) graph data model. The property graph data model is simpler and much less precise than RDF. These differences make it a good candidate for use cases such as these:</p>
<ul style="list-style-type: disc;">
<li>
<p>Identifying influencers in a social network</p>
</li>
<li>
<p>Predicting trends and customer behavior</p>
</li>
<li>
<p>Discovering relationships based on pattern matching</p>
</li>
<li>
<p>Identifying clusters to customize campaigns</p>
</li>
</ul>
<div class="infobox-note" id="GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__GUID-96854C1F-4DF4-403B-8E69-0F87B790873F">
<p class="notep1">Note:</p>
<p>The property graph data model that Oracle supports at the database side does not allow labels for vertices. However, you can treat the value of a designated vertex property as one or more labels, as explained in <a href="using-property-graphs-big-data.htm#GUID-5043DDBF-C215-4453-936B-FE0D24DE1D82">Specifying Labels for Vertices</a>.</p>
</div>
</div>
</div>
<a id="BDSPA196"></a><a id="BDSPA195"></a>
<div class="props_rev_3"><a id="GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A"></a>
<h3 id="BDSPA-GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A" class="sect3"><span class="enumeration_section">5.1.2</span> What Is Big Data Support for Property Graphs?</h3>
<div>
<p>Property graphs are supported for Big Data in Hadoop and in Oracle NoSQL Database. This support consists of a data access layer and an analytics layer. A choice of databases in Hadoop provides scalable and persistent storage management.</p>
<p><a href="using-property-graphs-big-data.htm#GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A__BHBDDCAI">Figure 5-2</a> provides an overview of the Oracle property graph architecture.</p>
<div class="figure" id="GUID-11A3AD36-58BE-4B6C-9B15-41A3ACE08F7A__BHBDDCAI">
<p class="titleinfigure">Figure 5-2 Oracle Property Graph Architecture</p>
<img width="413" height="363" src="img/GUID-48E81E9D-68F5-4769-9DD8-69BAAF81EADC-default.jpg" alt="Description of Figure 5-2 follows" title="Description of Figure 5-2 follows" /><br />
<a href="img_text/GUID-48E81E9D-68F5-4769-9DD8-69BAAF81EADC-default.htm">Description of "Figure 5-2 Oracle Property Graph Architecture"</a></div>
<!-- class="figure" --></div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-67CA6CE9-4726-42F0-BEE9-A119E54CD7D8">In-Memory Analyst</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-B6C6C3FC-864B-4E1F-B3FA-7AD05A8F4C33">Data Access Layer</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-F5588AE8-918D-417C-A33E-5BF0730F2106">Storage Management</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-1D8C99DB-8C8B-45B2-995D-E5DD2BA68505">RESTful Web Services</a><br /></li>
</ul>
</div>
<a id="BDSPA197"></a>
<div class="props_rev_3"><a id="GUID-67CA6CE9-4726-42F0-BEE9-A119E54CD7D8"></a>
<h4 id="BDSPA-GUID-67CA6CE9-4726-42F0-BEE9-A119E54CD7D8" class="sect4"><span class="enumeration_section">5.1.2.1</span> In-Memory Analyst</h4>
<div>
<p>The in-memory analyst layer enables you to analyze property graphs using parallel in-memory execution. It provides over 35 analytic functions, including path calculation, ranking, community detection, and recommendations.</p>
</div>
</div>
<a id="BDSPA198"></a>
<div class="props_rev_3"><a id="GUID-B6C6C3FC-864B-4E1F-B3FA-7AD05A8F4C33"></a>
<h4 id="BDSPA-GUID-B6C6C3FC-864B-4E1F-B3FA-7AD05A8F4C33" class="sect4"><span class="enumeration_section">5.1.2.2</span> Data Access Layer</h4>
<div>
<p>The data access layer provides a set of Java APIs that you can use to create and drop property graphs, add and remove vertices and edges, search for vertices and edges using key-value pairs, create text indexes, and perform other manipulations. The Java APIs include an implementation of TinkerPop Blueprints graph interfaces for the property graph data model. The APIs also integrate with the Apache Lucene and Apache SolrCloud, which are widely-adopted open-source text indexing and search engines.</p>
</div>
</div>
<a id="BDSPA199"></a>
<div class="props_rev_3"><a id="GUID-F5588AE8-918D-417C-A33E-5BF0730F2106"></a>
<h4 id="BDSPA-GUID-F5588AE8-918D-417C-A33E-5BF0730F2106" class="sect4"><span class="enumeration_section">5.1.2.3</span> Storage Management</h4>
<div>
<p>You can store your property graphs in either Oracle NoSQL Database or Apache HBase. Both databases are mature and scalable, and support efficient navigation, querying, and analytics. Both use tables to model the vertices and edges of property graphs.</p>
</div>
</div>
<a id="BDSPA200"></a>
<div class="props_rev_3"><a id="GUID-1D8C99DB-8C8B-45B2-995D-E5DD2BA68505"></a>
<h4 id="BDSPA-GUID-1D8C99DB-8C8B-45B2-995D-E5DD2BA68505" class="sect4"><span class="enumeration_section">5.1.2.4</span> RESTful Web Services</h4>
<div>
<p>You can also use RESTful web services to access the graph data and perform graph operations. For example, you can use the Linux <code class="codeph">curl</code> command to obtain vertices and edges, and to add and remove graph elements.</p>
</div>
</div>
</div>
</div>
<a id="BDSPA202"></a>
<div class="props_rev_3"><a id="GUID-349A3705-6A70-4A35-A71B-7E3D65AB42CA"></a>
<h2 id="BDSPA-GUID-349A3705-6A70-4A35-A71B-7E3D65AB42CA" class="sect2"><span class="enumeration_section">5.2</span> About Property Graph Data Formats</h2>
<div>
<p>The following graph formats are supported.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-B31C005F-0234-405C-837C-F12C11C0E941">GraphML Data Format</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734">GraphSON Data Format</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-DCC9B9AF-9714-4D03-A307-93DC10751453">GML Data Format</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A">Oracle Flat File Format</a><br /></li>
</ul>
</div>
<a id="BDSPA204"></a><a id="BDSPA203"></a>
<div class="props_rev_3"><a id="GUID-B31C005F-0234-405C-837C-F12C11C0E941"></a>
<h3 id="BDSPA-GUID-B31C005F-0234-405C-837C-F12C11C0E941" class="sect3"><span class="enumeration_section">5.2.1</span> GraphML Data Format</h3>
<div>
<p>The GraphML file format uses XML to describe graphs. <a href="using-property-graphs-big-data.htm#GUID-B31C005F-0234-405C-837C-F12C11C0E941__BHBJAHIE">Example 5-1</a> shows a GraphML description of the property graph shown in <a href="using-property-graphs-big-data.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 5-1</a>.</p>
<div class="infoboxnotealso" id="GUID-B31C005F-0234-405C-837C-F12C11C0E941__GUID-55C13F67-3B82-4EF3-B89D-FCE9530E8DCC">
<p class="notep1">See Also:</p>
<p>"The GraphML File Format" at</p>
<p><a href="http://graphml.graphdrawing.org/" target="_blank"><code class="codeph">http://graphml.graphdrawing.org/</code></a></p>
</div>
<div class="example" id="GUID-B31C005F-0234-405C-837C-F12C11C0E941__BHBJAHIE">
<p class="titleinexample">Example 5-1 GraphML Description of a Simple Property Graph</p>
<pre dir="ltr">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns"&gt;
    &lt;key id="name" for="node" attr.name="name" attr.type="string"/&gt;
    &lt;key id="age" for="node" attr.name="age" attr.type="int"/&gt;
    &lt;key id="type" for="edge" attr.name="type" attr.type="string"/&gt;
    &lt;graph id="PG" edgedefault="directed"&gt;
        &lt;node id="1"&gt;
            &lt;data key="name"&gt;Alice&lt;/data&gt;
            &lt;data key="age"&gt;31&lt;/data&gt;
        &lt;/node&gt;
        &lt;node id="2"&gt;
            &lt;data key="name"&gt;Bob&lt;/data&gt;
            &lt;data key="age"&gt;27&lt;/data&gt;
        &lt;/node&gt;
        &lt;edge id="3" source="1" target="2" label="knows"&gt;
            &lt;data key="type"&gt;friends&lt;/data&gt;
        &lt;/edge&gt;
    &lt;/graph&gt;
&lt;/graphml&gt;
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA206"></a><a id="BDSPA205"></a>
<div class="props_rev_3"><a id="GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734"></a>
<h3 id="BDSPA-GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734" class="sect3"><span class="enumeration_section">5.2.2</span> GraphSON Data Format</h3>
<div>
<p>The GraphSON file format is based on JavaScript Object Notation (JSON) for describing graphs. <a href="using-property-graphs-big-data.htm#GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734__BHBHABBB">Example 5-2</a> shows a GraphSON description of the property graph shown in <a href="using-property-graphs-big-data.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 5-1</a>.</p>
<div class="infoboxnotealso" id="GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734__GUID-64AF1AC3-E709-4F3E-890F-2D336C5CE7AB">
<p class="notep1">See Also:</p>
<p>"GraphSON Reader and Writer Library" at</p>
<p><a href="https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library" target="_blank"><code class="codeph">https://github.com/tinkerpop/blueprints/wiki/GraphSON-Reader-and-Writer-Library</code></a></p>
</div>
<div class="example" id="GUID-185B9A3A-83C1-4165-8A7C-86D30ED74734__BHBHABBB">
<p class="titleinexample">Example 5-2 GraphSON Description of a Simple Property Graph</p>
<pre dir="ltr">
{
    "graph": {
        "mode":"NORMAL",
        "vertices": [
            {
                "name": "Alice",
                "age": 31,
                "_id": "1",
                "_type": "vertex"
            },
            {
                "name": "Bob",
                "age": 27,
                "_id": "2",
                "_type": "vertex"
            }       
        ],
        "edges": [
            {
                "type": "friends",
                "_id": "3",
                "_type": "edge",
                "_outV": "1",
                "_inV": "2",
                "_label": "knows"
            }
        ]
    }
}
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA208"></a><a id="BDSPA207"></a>
<div class="props_rev_3"><a id="GUID-DCC9B9AF-9714-4D03-A307-93DC10751453"></a>
<h3 id="BDSPA-GUID-DCC9B9AF-9714-4D03-A307-93DC10751453" class="sect3"><span class="enumeration_section">5.2.3</span> GML Data Format</h3>
<div>
<p>The Graph Modeling Language (GML) file format uses ASCII to describe graphs. <a href="using-property-graphs-big-data.htm#GUID-DCC9B9AF-9714-4D03-A307-93DC10751453__BHBDFBBB">Example 5-3</a> shows a GML description of the property graph shown in <a href="using-property-graphs-big-data.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 5-1</a>.</p>
<div class="infoboxnotealso" id="GUID-DCC9B9AF-9714-4D03-A307-93DC10751453__GUID-52203D16-4D87-44B7-9023-60A80C067EAE">
<p class="notep1">See Also:</p>
<p>"GML: A Portable Graph File Format" by Michael Himsolt at</p>
<p><a href="http://www.fim.uni-passau.de/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf" target="_blank"><code class="codeph">http://www.fim.uni-passau.de/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf</code></a></p>
</div>
<div class="example" id="GUID-DCC9B9AF-9714-4D03-A307-93DC10751453__BHBDFBBB">
<p class="titleinexample">Example 5-3 GML Description of a Simple Property Graph</p>
<pre dir="ltr">
graph [
   comment "Simple property graph"
   directed 1
   IsPlanar 1
   node [
      id 1
      label "1"
      name "Alice"
      age 31
        ]
   node [
      id 2
      label "2"
      name "Bob"
      age 27
        ]
   edge [
      source 1
      target 2
      label "knows"
      type "friends"
        ]
      ]
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA210"></a><a id="BDSPA209"></a>
<div class="props_rev_3"><a id="GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A"></a>
<h3 id="BDSPA-GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A" class="sect3"><span class="enumeration_section">5.2.4</span> Oracle Flat File Format</h3>
<div>
<p>The Oracle flat file format exclusively describes property graphs. It is more concise and provides better data type support than the other file formats. The Oracle flat file format uses two files for a graph description, one for the vertices and one for edges. Commas separate the fields of the records.</p>
<p><a href="using-property-graphs-big-data.htm#GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A__BHBJGIJJ">Example 5-4</a> shows the Oracle flat files that describe the property graph shown in <a href="using-property-graphs-big-data.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD__BHBBGAGE">Figure 5-1</a>.</p>
<div class="infoboxnotealso" id="GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A__GUID-BA266589-1929-420E-BF61-8AE0D4697573">
<p class="notep1">See Also:</p>
<p><span class="q">"<a href="using-property-graphs-big-data.htm#GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5" title="A property graph can be defined in two flat files, specifically description files for the vertices and edges.">Oracle Flat File Format Definition</a>"</span></p>
</div>
<div class="example" id="GUID-1C6C8F47-DA08-47D5-9C4B-750F9867765A__BHBJGIJJ">
<p class="titleinexample">Example 5-4 Oracle Flat File Description of a Simple Property Graph</p>
<p><span class="bold">Vertex file:</span></p>
<pre dir="ltr">
1,name,1,Alice,,
1,age,2,,31,
2,name,1,Bob,,
2,age,2,,27,
</pre>
<p><span class="bold">Edge file:</span></p>
<pre dir="ltr">
1,1,2,knows,type,1,friends,, 
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="BDSPA201"></a>
<div class="props_rev_3"><a id="GUID-C621157E-AB7C-4B98-86C5-02D22FA7A20E"></a>
<h2 id="BDSPA-GUID-C621157E-AB7C-4B98-86C5-02D22FA7A20E" class="sect2"><span class="enumeration_section">5.3</span> Getting Started with Property Graphs</h2>
<div>
<p>To get started with property graphs, follow these main steps.</p>
<ol>
<li class="stepexpand"><span>The first time you use property graphs, ensure that the software is installed and operational.</span></li>
<li class="stepexpand"><span>Create your Java programs, using the classes provided in the Java API.</span>
<div>
<p>See <span class="q">"<a href="using-property-graphs-big-data.htm#GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B" title="Creating a property graph involves using the Java APIs to create the property graph and objects in it.">Using Java APIs for Property Grsph Data</a>"</span>.</p>
</div>
</li>
</ol>
</div>
</div>
<a id="BDSPA211"></a>
<div class="props_rev_3"><a id="GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B"></a>
<h2 id="BDSPA-GUID-D235D1E8-71DE-4FF6-B989-74E4A643152B" class="sect2"><span class="enumeration_section">5.4</span> Using Java APIs for Property Graph Data</h2>
<div>
<p>Creating a property graph involves using the Java APIs to create the property graph and objects in it.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-FEAADCBB-EFDD-4C3D-8759-0F84D4732836">Overview of the Java APIs</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-EC851482-926D-4EB4-A922-ADEBF71C5611">Parallel Loading of Graph Data</a><br />
A Java API is provided for performing parallel loading of graph data.</li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-A25C4F9E-E84D-4585-AF70-CE244F8AB547">Opening and Closing a Property Graph Instance</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-E0DAB9AE-5962-41AF-9B73-F390AF6189DC">Creating Vertices</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-B29900B4-6D97-41EF-B863-0CF17196234F">Creating Edges</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-BFD2302B-C94B-47BC-A1AE-1BE4459BBBDD">Deleting Vertices and Edges</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-64E7B0BF-315E-45CE-ACD5-2566B33A7501">Reading a Graph from a Database into an Embedded In-Memory Analyst</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-5043DDBF-C215-4453-936B-FE0D24DE1D82">Specifying Labels for Vertices</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-ECB7B9A0-038B-451A-AAAB-9F8815AE2602">Building an In-Memory Graph</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-EE2C73EA-2185-4BD7-B1F8-974D455F41D3">Dropping a Property Graph</a><br /></li>
</ul>
</div>
<a id="BDSPA212"></a>
<div class="props_rev_3"><a id="GUID-FEAADCBB-EFDD-4C3D-8759-0F84D4732836"></a>
<h3 id="BDSPA-GUID-FEAADCBB-EFDD-4C3D-8759-0F84D4732836" class="sect3"><span class="enumeration_section">5.4.1</span> Overview of the Java APIs</h3>
<div>
<p>The Java APIs that you can use for property graphs include the following.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC">Oracle Big Data Spatial and Graph Java APIs</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C">TinkerPop Blueprints Java APIs</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57">Apache Hadoop Java APIs</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE">Oracle NoSQL Database Java APIs</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6">Apache HBase Java APIs</a><br /></li>
</ul>
</div>
<a id="BDSPA213"></a>
<div class="props_rev_3"><a id="GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC"></a>
<h4 id="BDSPA-GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC" class="sect4"><span class="enumeration_section">5.4.1.1</span> Oracle Big Data Spatial and Graph Java APIs</h4>
<div>
<p>Oracle Big Data Spatial and Graph property graph support provides database-specific APIs for Apache HBase and Oracle NoSQL Database. The data access layer API (<code class="codeph">oracle.pg.*</code>) implements TinkerPop Blueprints APIs, text search, and indexing for property graphs stored in Oracle NoSQL Database and Apache HBase.</p>
<p>To use the Oracle Big Data Spatial and Graph API, import the classes into your Java program:</p>
<pre dir="ltr">
import oracle.pg.nosql.*; // <span class="italic">or</span> oracle.pg.hbase.*
import oracle.pgx.config.*;
import oracle.pgx.common.types.*;
</pre>
<p>Also include <a href="using-property-graphs-big-data.htm#GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C">TinkerPop Blueprints Java APIs</a>.</p>
<div class="infoboxnotealso" id="GUID-832C939A-FDFD-42EF-8A5F-12CD83C850DC__GUID-B72E4169-2009-49EC-9323-134FBD04D734">
<p class="notep1">See Also:</p>
<p>Oracle Big Data Spatial and Graph Java API Reference</p>
</div>
</div>
</div>
<a id="BDSPA214"></a>
<div class="props_rev_3"><a id="GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C"></a>
<h4 id="BDSPA-GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C" class="sect4"><span class="enumeration_section">5.4.1.2</span> TinkerPop Blueprints Java APIs</h4>
<div>
<p>TinkerPop Blueprints supports the property graph data model. The API provides utilities for manipulating graphs, which you use primarily through the Big Data Spatial and Graph data access layer Java APIs.</p>
<p>To use the Blueprints APIs, import the classes into your Java program:</p>
<pre dir="ltr">
import com.tinkerpop.blueprints.Vertex;
import com.tinkerpop.blueprints.Edge;
</pre>
<div class="infoboxnotealso" id="GUID-3AF353CD-925F-4DDA-9842-6630E0833C6C__GUID-28679CB5-6802-4307-B590-E358E554C4B9">
<p class="notep1">See Also:</p>
<p>"Blueprints: A Property Graph Model Interface API" at</p>
<p><a href="http://www.tinkerpop.com/docs/javadocs/blueprints/2.3.0/index.html" target="_blank"><code class="codeph">http://www.tinkerpop.com/docs/javadocs/blueprints/2.3.0/index.html</code></a></p>
</div>
</div>
</div>
<a id="BDSPA215"></a>
<div class="props_rev_3"><a id="GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57"></a>
<h4 id="BDSPA-GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57" class="sect4"><span class="enumeration_section">5.4.1.3</span> Apache Hadoop Java APIs</h4>
<div>
<p>The Apache Hadoop Java APIs enable you to write your Java code as a MapReduce program that runs within the Hadoop distributed framework.</p>
<p>To use the Hadoop Java APIs, import the classes into your Java program. For example:</p>
<pre dir="ltr">
import org.apache.hadoop.conf.Configuration;
</pre>
<div class="infoboxnotealso" id="GUID-73E11D5B-C388-4E0F-84F8-F076E1106F57__GUID-68EAC838-16C3-432C-A7D8-61F54C9E0AC8">
<p class="notep1">See Also:</p>
<p>"Apache Hadoop Main 2.5.0-cdh5.3.2 API" at</p>
<p><a href="http://archive.cloudera.com/cdh5/cdh/5/hadoop/api/" target="_blank"><code class="codeph">http://archive.cloudera.com/cdh5/cdh/5/hadoop/api/</code></a></p>
</div>
</div>
</div>
<a id="BDSPA216"></a>
<div class="props_rev_3"><a id="GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE"></a>
<h4 id="BDSPA-GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE" class="sect4"><span class="enumeration_section">5.4.1.4</span> Oracle NoSQL Database Java APIs</h4>
<div>
<p>The Oracle NoSQL Database APIs enable you to create and populate a key-value (KV) store, and provide interfaces to Hadoop, Hive, and Oracle NoSQL Database.</p>
<p>To use Oracle NoSQL Database as the graph data store, import the classes into your Java program. For example:</p>
<pre dir="ltr">
import oracle.kv.*; 
import oracle.kv.table.TableOperation;
</pre>
<div class="infoboxnotealso" id="GUID-01E71094-FBC1-4EDB-AF83-C8BA97A75CAE__GUID-9CD7E0FB-EA89-46F9-B645-01DA9C2D74E7">
<p class="notep1">See Also:</p>
<p>"Oracle NoSQL Database Java API Reference" at</p>
<p><a href="http://docs.oracle.com/cd/NOSQL/html/javadoc/" target="_blank"><code class="codeph">http://docs.oracle.com/cd/NOSQL/html/javadoc/</code></a></p>
</div>
</div>
</div>
<a id="BDSPA217"></a>
<div class="props_rev_3"><a id="GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6"></a>
<h4 id="BDSPA-GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6" class="sect4"><span class="enumeration_section">5.4.1.5</span> Apache HBase Java APIs</h4>
<div>
<p>The Apache HBase APIs enable you to create and manipulate key-value pairs.</p>
<p>To use HBase as the graph data store, import the classes into your Java program. For example:</p>
<pre dir="ltr">
import org.apache.hadoop.hbase.*; 
import org.apache.hadoop.hbase.client.*;
import org.apache.hadoop.hbase.filter.*; 
import org.apache.hadoop.hbase.util.Bytes; 
import org.apache.hadoop.conf.Configuration; 
</pre>
<div class="infoboxnotealso" id="GUID-9FA18F0A-A476-4184-9455-2F9CFDB33CB6__GUID-925DDFA4-97FF-4A9F-8C3E-AC17BBBA2FDE">
<p class="notep1">See Also:</p>
<p>"HBase 0.98.6-cdh5.3.2 API" at</p>
<p><a href="http://archive.cloudera.com/cdh5/cdh/5/hbase/apidocs/index.html?overview-summary.html" target="_blank"><code class="codeph">http://archive.cloudera.com/cdh5/cdh/5/hbase/apidocs/index.html?overview-summary.html</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect3"><a id="GUID-EC851482-926D-4EB4-A922-ADEBF71C5611"></a>
<h3 id="BDSPA-GUID-EC851482-926D-4EB4-A922-ADEBF71C5611" class="sect3"><span class="enumeration_section">5.4.2</span> Parallel Loading of Graph Data</h3>
<div>
<p>A Java API is provided for performing parallel loading of graph data.</p>
<p>Given a set of vertex files (or input streams) and a set of edge files (or input streams), they can be split into multiple chunks and loaded into database in parallel. The number of chunks is determined by the degree of parallelism (DOP) specified by the user.</p>
<p>Parallelism is achieved with Splitter threads that split vertex and edge flat files into multiple chunks and Loader threads that load each chunk into the database using separate database connections. Java pipes are used to connect Splitter and Loader threads -- Splitter: <code class="codeph">PipedOutputStream</code> and Loader: <code class="codeph">PipedInputStream</code>.</p>
<p>The simplest usage of data loading API is specifying a property graph instance, one vertex file, one edge file, and a DOP.</p>
<p>The following example of the load process loads graph data stored in a vertices file and an edges file of the optimized Oracle flat file format, and executes the load with 48 degrees of parallelism.</p>
<pre dir="ltr">
opgdl = OraclePropertyGraphDataLoader.getInstance();
vfile = "../../data/connections.opv";
efile = "../../data/connections.ope";
opgdl.loadData(opg, vfile, efile, 48);
</pre></div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-614C3D33-7CA0-488E-A78E-B18E78D4B272">Parallel Data Loading Using Partitions</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-45FA9E93-3E67-490D-ABDC-FB5B12BD0535">Parallel Data Loading Using Fine-Tuning</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-85A51A8F-2471-4D73-B256-2D28FFF57F05">Parallel Data Loading Using Multiple Files</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-A3BEAED2-37E2-47AC-B79F-ED327C8F0D20">Parallel Retrieval of Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-5141A57A-0BF5-4DAD-9645-C943DE11B55A">Using an Element Filter Callback for Subgraph Extraction</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-ABB127C9-72BB-47FD-879C-907E481BA9E9">Using Optimization Flags on Reads over Property Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-1DF4100F-F4D4-480A-8DDD-1454645857E3">Adding and Removing Attributes of a Property Graph Subgraph</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-DE1C0716-45F4-4396-BE5E-A23AC8104296">Getting Property Graph Metadata</a><br /></li>
</ul>
</div>
<div class="props_rev_3"><a id="GUID-614C3D33-7CA0-488E-A78E-B18E78D4B272"></a>
<h4 id="BDSPA-GUID-614C3D33-7CA0-488E-A78E-B18E78D4B272" class="sect4"><span class="enumeration_section">5.4.2.1</span> Parallel Data Loading Using Partitions</h4>
<div>
<p>The data loading API allows loading the data into database using multiple partitions. This API requires the property graph, the vertex file, the edge file, the DOP, the total number of partitions, and the partition offset (from 0 to total number of partitions - 1). For example, to load the data using two partitions, the partition offsets should be 0 and 1. That is, there should be two data loading API calls to fully load the graph, and the only difference between the two API calls is the partition offset (0 and 1).</p>
<p>The following code fragment loads the graph data using 4 partitions. Each call to the data loader can be processed using a separate Java client, on a single system or from multiple systems.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

int totalPartitions = 4;
int dop= 32; // degree of parallelism for each client.

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
SimpleLogBasedDataLoaderListenerImpl dll = SimpleLogBasedDataLoaderListenerImpl.getInstance(100 /* frequency */,
                                       true /* Continue on error */);

// Run the data loading using 4 partitions (Each call can be run from a
// separate Java Client)

// Partition 1
OraclePropertyGraphDataLoader opgdlP1 = OraclePropertyGraphDataLoader.getInstance();
opgdlP1.<span class="bold">loadData(opg, szOPVFile, szOPEFile, dop,  
   4 /* Total number of partitions, default 1 */,
   0 /* Partition to load (from 0 to totalPartitions - 1, default 0 */,
   dll);
</span>
// Partition 2
OraclePropertyGraphDataLoader opgdlP2 = OraclePropertyGraphDataLoader.getInstance();
opgdlP2.loadData(opg, szOPVFile, szOPEFile, dop,  4 /* Total number of partitions, default 1 */,
 1 /* Partition to load (from 0 to totalPartitions - 1, default 0 */, dll);


// Partition 3
OraclePropertyGraphDataLoader opgdlP3 = OraclePropertyGraphDataLoader.getInstance();
opgdlP3.loadData(opg, szOPVFile, szOPEFile, dop,  4 /* Total number of partitions, default 1 */,
 2 /* Partition to load (from 0 to totalPartitions - 1, default 0 */, dll);

// Partition 4
OraclePropertyGraphDataLoader opgdlP4 = OraclePropertyGraphDataLoader.getInstance();
opgdlP4.loadData(opg, szOPVFile, szOPEFile, dop,  4 /* Total number of partitions, default 1 */,
 3 /* Partition to load (from 0 to totalPartitions - 1, default 0 */, dll);
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-45FA9E93-3E67-490D-ABDC-FB5B12BD0535"></a>
<h4 id="BDSPA-GUID-45FA9E93-3E67-490D-ABDC-FB5B12BD0535" class="sect4"><span class="enumeration_section">5.4.2.2</span> Parallel Data Loading Using Fine-Tuning</h4>
<div>
<p>Data loading APIs also support fine-tuning those lines in the source vertex and edges files that are to be loaded. You can specify the vertex (or edge) offset line number and vertex (or edge) maximum line number. Data will be loaded from the offset line number until the maximum line number. If the maximum line number is -1, the loading process will scan the data until reaching the end of file.</p>
<p>The following code fragment loads the graph data using fine-tuning.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

int totalPartitions = 4;
int dop= 32; // degree of parallelism for each client.

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
SimpleLogBasedDataLoaderListenerImpl dll = SimpleLogBasedDataLoaderListenerImpl.getInstance(100 /* frequency */,
                                       true /* Continue on error */);

// Run the data loading using fine tuning
long lVertexOffsetlines = 0;
long lEdgeOffsetlines = 0;
long lVertexMaxlines = 100;
long lEdgeMaxlines = 100;
int totalPartitions = 1;
int idPartition = 0;

OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
<span class="bold">opgdl.loadData(opg, szOPVFile, szOPEFile,
 lVertexOffsetlines /* offset of lines to start loading 
 from partition, default 0*/,
 lEdgeOffsetlines /* offset of lines to start loading 
 from partition, default 0*/,
 lVertexMaxlines /* maximum number of lines to start loading 
 from partition, default -1 (all lines in partition)*/,
 lEdgeMaxlines /* maximun number of lines to start loading 
 from partition, default -1 (all lines in partition)*/,
 dop,
 totalPartitions /* Total number of partitions, default 1 */,
 idPartition /* Partition to load (from 0 to totalPartitions - 1, 
 default 0 */,
 dll);
</span>
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-85A51A8F-2471-4D73-B256-2D28FFF57F05"></a>
<h4 id="BDSPA-GUID-85A51A8F-2471-4D73-B256-2D28FFF57F05" class="sect4"><span class="enumeration_section">5.4.2.3</span> Parallel Data Loading Using Multiple Files</h4>
<div>
<p>Oracle Big Data Spatial and Graph also support loading multiple vertex files and multiple edges files into database. The given multiple vertex files will be split into DOP chunks and loaded into database in parallel using DOP threads. Similarly, the multiple edge files will also be split and loaded in parallel.</p>
<p>The following code fragment loads multiple vertex fan and edge files using the parallel data loading APIs. In the example, two string arrays szOPVFiles and szOPEFiles are used to hold the input files; Although only one vertex file and one edge file is used in this example, you can supply multiple vertex files and multiple edge files in these two arrays.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

String[] szOPVFiles = new String[] {"../../data/connections.opv"};
String[] szOPEFiles = new String[] {"../../data/connections.ope"};

// Clear existing vertices/edges in the property graph 
opg.clearRepository();
opg.setQueueSize(100); // 100 elements

// This object will handle parallel data loading over the property graph
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();

<span class="bold">opgdl.loadData(opg, szOPVFiles, szOPEFiles, dop);
</span>
System.out.println("Total vertices: " + opg.countVertices());
System.out.println("Total edges: " + opg.countEdges());
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-A3BEAED2-37E2-47AC-B79F-ED327C8F0D20"></a>
<h4 id="BDSPA-GUID-A3BEAED2-37E2-47AC-B79F-ED327C8F0D20" class="sect4"><span class="enumeration_section">5.4.2.4</span> Parallel Retrieval of Graph Data</h4>
<div>
<p>The parallel property graph query provides a simple Java API to perform parallel scans on vertices (or edges). Parallel retrieval is an optimized solution taking advantage of the distribution of the data among splits with the back-end database, so each split is queried using separate database connections.</p>
<p>Parallel retrieval will produce an array where each element holds all the vertices (or edges) from a specific split. The subset of shards queried will be separated by the given start split ID and the size of the connections array provided. This way, the subset will consider splits in the range of [start, start - 1 + size of connections array]. Note that an integer ID (in the range of [0, N - 1]) is assigned to all the splits in the vertex table with N splits.</p>
<p>The following code loads a property graph using Apache HBase, opens an array of connections, and executes a parallel query to retrieve all vertices and edges using the opened connections. The number of calls to the <code class="codeph">getVerticesPartitioned (getEdgesPartitioned)</code> method is controlled by the total number of splits and the number of connections used.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create connections used in parallel query
HConnection[] hConns= new HConnection[dop];
for (int i = 0; i &lt; dop; i++) { 
Configuration conf_new = 
HBaseConfiguration.create(opg.getConfiguration());
hConns[i] = HConnectionManager.createConnection(conf_new); 
}


long lCountV = 0;
// Iterate over all the vertices&rsquo; splits to count all the vertices
for (int split = 0; split &lt; opg.getVertexTableSplits(); 
 split += dop) { 
Iterable&lt;Vertex&gt;[] iterables 
 = <span class="bold">opg.getVerticesPartitioned(hConns /* Connection array */, 
 true /* skip store to cache */, 
 split /* starting split */);</span> 
lCountV += consumeIterables(iterables); /* consume iterables using 
 threads */
}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCountV);

long lCountE = 0;
// Iterate over all the edges&rsquo; splits to count all the edges
for (int split = 0; split &lt; opg.getEdgeTableSplits(); 
 split += dop) { 
Iterable&lt;Edge&gt;[] iterables 
 = <span class="bold">opg.getEdgesPartitioned(hConns /* Connection array */, 
 true /* skip store to cache */, 
 split /* starting split */);</span> 
lCountE += consumeIterables(iterables); /* consume iterables using 
 threads */
}

// Count all edges
System.out.println("Edges found using parallel query: " + lCountE);

// Close the connections to the database after completed
for (int idx = 0; idx &lt; hConns.length; idx++) { 
hConns[idx].close();
}
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-5141A57A-0BF5-4DAD-9645-C943DE11B55A"></a>
<h4 id="BDSPA-GUID-5141A57A-0BF5-4DAD-9645-C943DE11B55A" class="sect4"><span class="enumeration_section">5.4.2.5</span> Using an Element Filter Callback for Subgraph Extraction</h4>
<div>
<p>Oracle Big Data Spatial and Graph provides support for an easy subgraph extraction using user-defined element filter callbacks. An element filter callback defines a set of conditions that a vertex (or an edge) must meet in order to keep it in the subgraph. Users can define their own element filtering by implementing the <code class="codeph">VertexFilterCallback</code> and <code class="codeph">EdgeFilterCallback</code> API interfaces.</p>
<p>The following code fragment implements a <code class="codeph">VertexFilterCallback</code> that validates if a vertex does not have a political role and its origin is the United States.</p>
<pre dir="ltr">
/**
* VertexFilterCallback to retrieve a vertex from the United States 
* that does not have a political role 
*/
private static class NonPoliticianFilterCallback 
implements VertexFilterCallback
{
@Override
public boolean keepVertex(OracleVertexBase vertex) 
{
String country = vertex.getProperty("country");
String role = vertex.getProperty("role");

if (country != null &amp;&amp; country.equals("United States")) {
if (role == null || !role.toLowerCase().contains("political")) {
return true;
}
}

return false;
}

public static NonPoliticianFilterCallback getInstance()
{
return new NonPoliticianFilterCallback();
}
}
</pre>
<p>The following code fragment implements an <code class="codeph">EdgeFilterCallback</code> that uses the <code class="codeph">VertexFilterCallback</code> to keep only edges connected to the given input vertex, and whose connections are not politicians and come from the United States.</p>
<pre dir="ltr">
/**
 * EdgeFilterCallback to retrieve all edges connected to an input 
 * vertex with "collaborates" label, and whose vertex is from the 
 * United States with a role different than political
*/
private static class CollaboratorsFilterCallback 
implements EdgeFilterCallback
{
private VertexFilterCallback m_vfc;
private Vertex m_startV;

public CollaboratorsFilterCallback(VertexFilterCallback vfc, 
 Vertex v) 
{
m_vfc = vfc;
m_startV = v; 
}

@Override
public boolean keepEdge(OracleEdgeBase edge) 
{
if ("collaborates".equals(edge.getLabel())) {
if (edge.getVertex(Direction.IN).equals(m_startV) &amp;&amp; 
m_vfc.keepVertex((OracleVertex) 
edge.getVertex(Direction.OUT))) {
return true;
}
else if (edge.getVertex(Direction.OUT).equals(m_startV) &amp;&amp; 
 m_vfc.keepVertex((OracleVertex) 
edge.getVertex(Direction.IN))) {
return true;
}
}

return false;
}

public static CollaboratorsFilterCallback
getInstance(VertexFilterCallback vfc, Vertex v)
{
return new CollaboratorsFilterCallback(vfc, v);
}

}
</pre>
<p>Using the filter callbacks previously defined, the following code fragment loads a property graph, creates an instance of the filter callbacks and later gets all of Barack Obama&rsquo;s collaborators who are not politicians and come from the United States.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// VertexFilterCallback to retrieve all people from the United States // who are not politicians
<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance();
</span>
// Initial vertex: Barack Obama
Vertex v = opg.getVertices("name", "Barack Obama").iterator().next();

// EdgeFilterCallback to retrieve all collaborators of Barack Obama 
// from the United States who are not politicians
<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance(npvfc, v);
</span>
Iterable&lt;&lt;Edge&gt; obamaCollabs = <span class="bold">opg.getEdges((String[])null /* Match any 
of the properties */,
cefc /* Match the 
EdgeFilterCallback */
);</span>
Iterator&lt;&lt;Edge&gt; iter = obamaCollabs.iterator();

System.out.println("\n\n--------Collaborators of Barack Obama from " +
 " the US and non-politician\n\n");
long countV = 0;
while (iter.hasNext()) {
Edge edge = iter.next(); // get the edge
// check if obama is the IN vertex
if (edge.getVertex(Direction.IN).equals(v)) {
 System.out.println(edge.getVertex(Direction.OUT) + "(Edge ID: " + 
 edge.getId() + ")"); // get out vertex
}
else {
System.out.println(edge.getVertex(Direction.IN)+ "(Edge ID: " + 
 edge.getId() + ")"); // get in vertex
}

countV++;
}
</pre>
<p>By default, all reading operations such as get all vertices, get all edges (and parallel approaches) will use the filter callbacks associated with the property graph using the methods <code class="codeph">opg.setVertexFilterCallback(vfc)</code> and <code class="codeph">opg.setEdgeFilterCallback(efc)</code>. If there is no filter callback set, then all the vertices (or edges) and edges will be retrieved.</p>
<p>The following code fragment uses the default edge filter callback set on the property graph to retrieve the edges.</p>
<pre dir="ltr">
// VertexFilterCallback to retrieve all people from the United States // who are not politicians
<span class="bold">NonPoliticianFilterCallback npvfc = NonPoliticianFilterCallback.getInstance();
</span>
// Initial vertex: Barack Obama
Vertex v = opg.getVertices("name", "Barack Obama").iterator().next();

// EdgeFilterCallback to retrieve all collaborators of Barack Obama 
// from the United States who are not politicians
<span class="bold">CollaboratorsFilterCallback cefc = CollaboratorsFilterCallback.getInstance(npvfc, v);

opg.setEdgeFilterCallback(cefc);
</span>
Iterable&lt;Edge&gt; obamaCollabs = <span class="bold">opg.getEdges()</span>;
Iterator&lt;Edge&gt; iter = obamaCollabs.iterator();

System.out.println("\n\n--------Collaborators of Barack Obama from " +
 " the US and non-politician\n\n");
long countV = 0;
while (iter.hasNext()) {
Edge edge = iter.next(); // get the edge
// check if obama is the IN vertex
if (edge.getVertex(Direction.IN).equals(v)) {
 System.out.println(edge.getVertex(Direction.OUT) + "(Edge ID: " + 
 edge.getId() + ")"); // get out vertex
}
else {
System.out.println(edge.getVertex(Direction.IN)+ "(Edge ID: " + 
 edge.getId() + ")"); // get in vertex
}

countV++;
}
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-ABB127C9-72BB-47FD-879C-907E481BA9E9"></a>
<h4 id="BDSPA-GUID-ABB127C9-72BB-47FD-879C-907E481BA9E9" class="sect4"><span class="enumeration_section">5.4.2.6</span> Using Optimization Flags on Reads over Property Graph Data</h4>
<div>
<p>Optimization flags can improve graph iteration performance. Optimization flags allow processing vertices or edges as objects with no or minimal information, such as ID, label, and incoming/outgoing vertices. This way, the time required to process each vertex or edge during iteration is reduced.</p>
<p>The following table shows the optimization flags available when processing vertices or edges in a property graph.</p>
<div class="tblformal" id="GUID-ABB127C9-72BB-47FD-879C-907E481BA9E9__OPTIMIZATIONFLAGSFORPROCESSINGVERTI-2117A677">
<p class="titleintable">Table 5-1 Optimization Flags for Processing Vertices or Edges in a Property Graph</p>
<table class="cellalignment330" title="Optimization Flags for Processing Vertices or Edges in a Property Graph" summary="Optimization flags and descriptions for processing vertices or edges in a property graph. Column 1 is Optimization Flag, and column 2 is Description.">
<thead>
<tr class="cellalignment324">
<th class="cellalignment331" id="d28904e2023">Optimization Flag</th>
<th class="cellalignment331" id="d28904e2025">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment332" id="d28904e2029" headers="d28904e2023">DO_NOT_CREATE_OBJECT</td>
<td class="cellalignment332" headers="d28904e2029 d28904e2025">Use a predefined constant object when processing vertices or edges.</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment332" id="d28904e2034" headers="d28904e2023">JUST_EDGE_ID</td>
<td class="cellalignment332" headers="d28904e2034 d28904e2025">Construct edge objects with ID only when processing edges.</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment332" id="d28904e2039" headers="d28904e2023">JUST_LABEL_EDGE_ID</td>
<td class="cellalignment332" headers="d28904e2039 d28904e2025">Construct edge objects with ID and label only when processing edges.</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment332" id="d28904e2044" headers="d28904e2023">JUST_LABEL_VERTEX_EDGE_ID</td>
<td class="cellalignment332" headers="d28904e2044 d28904e2025">Construct edge objects with ID, label, and in/out vertex IDs only when processing edges</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment332" id="d28904e2049" headers="d28904e2023">JUST_VERTEX_EDGE_ID</td>
<td class="cellalignment332" headers="d28904e2049 d28904e2025">Construct edge objects with just ID and in/out vertex IDs when processing edges.</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment332" id="d28904e2054" headers="d28904e2023">JUST_VERTEX_ID</td>
<td class="cellalignment332" headers="d28904e2054 d28904e2025">Construct vertex objects with ID only when processing vertices.</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The following code fragment uses a set of optimization flags to retrieve only all the IDs from the vertices and edges in the property graph. The objects retrieved by reading all vertices and edges will include only the IDs and no Key/Value properties or additional information.</p>
<pre dir="ltr">
import oracle.pg.common.OraclePropertyGraphBase.OptimizationFlag;
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 


// Optimization flag to retrieve only vertices IDs
<span class="bold">OptimizationFlag optFlagVertex = OptimizationFlag.JUST_VERTEX_ID;
</span>
// Optimization flag to retrieve only edges IDs
<span class="bold">OptimizationFlag optFlagEdge = OptimizationFlag.JUST_EDGE_ID;
</span>
// Print all vertices
Iterator&lt;Vertex&gt; vertices = 
<span class="bold">opg.getVertices((String[])null /* Match any of the 
properties */,
null /* Match the VertexFilterCallback */, 
optFlagVertex /* optimization flag */ 
).iterator();
</span>
System.out.println("----- Vertices IDs----");
long vCount = 0;
while (vertices.hasNext()) {
OracleVertex v = vertices.next();
System.out.println((Long) v.getId());
vCount++;
}
System.out.println("Vertices found: " + vCount);

// Print all edges
Iterator&lt;Edge&gt; edges =
<span class="bold">opg.getEdges((String[])null /* Match any of the properties */,
null /* Match the EdgeFilterCallback */, 
optFlagEdge /* optimization flag */ 
).iterator();
</span>
System.out.println("----- Edges ----");
long eCount = 0;
while (edges.hasNext()) {
Edge e = edges.next();
System.out.println((Long) e.getId());
eCount++;
}
System.out.println("Edges found: " + eCount);
</pre>
<p>By default, all reading operations such as get all vertices, get all edges (and parallel approaches) will use the optimization flag associated with the property graph using the method <code class="codeph">opg.setDefaultVertexOptFlag(optFlagVertex)</code> and <code class="codeph">opg.setDefaultEdgeOptFlag(optFlagEdge)</code>. If the optimization flags for processing vertices and edges are not defined, then all the information about the vertices and edges will be retrieved.</p>
<p>The following code fragment uses the default optimization flags set on the property graph to retrieve only all the IDs from its vertices and edges.</p>
<pre dir="ltr">
import oracle.pg.common.OraclePropertyGraphBase.OptimizationFlag;

// Optimization flag to retrieve only vertices IDs
OptimizationFlag optFlagVertex = OptimizationFlag.JUST_VERTEX_ID;

// Optimization flag to retrieve only edges IDs
OptimizationFlag optFlagEdge = OptimizationFlag.JUST_EDGE_ID;

<span class="bold">opg.setDefaultVertexOptFlag(optFlagVertex);
opg.setDefaultEdgeOptFlag(optFlagEdge);
</span>
Iterator&lt;Vertex&gt; vertices = <span class="bold">opg.getVertices().iterator();</span>
System.out.println("----- Vertices IDs----");
long vCount = 0;
while (vertices.hasNext()) {
OracleVertex v = vertices.next();
System.out.println((Long) v.getId());
vCount++;
}
System.out.println("Vertices found: " + vCount);

// Print all edges
Iterator&lt;Edge&gt; edges = <span class="bold">opg.getEdges().iterator();
</span>System.out.println("----- Edges ----");
long eCount = 0;
while (edges.hasNext()) {
Edge e = edges.next();
System.out.println((Long) e.getId());
eCount++;
}
System.out.println("Edges found: " + eCount);
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-1DF4100F-F4D4-480A-8DDD-1454645857E3"></a>
<h4 id="BDSPA-GUID-1DF4100F-F4D4-480A-8DDD-1454645857E3" class="sect4"><span class="enumeration_section">5.4.2.7</span> Adding and Removing Attributes of a Property Graph Subgraph</h4>
<div>
<p>Oracle Big Data Spatial and Graph supports updating attributes (key/value pairs) to a subgraph of vertices and/or edges by using a user-customized operation callback. An operation callback defines a set of conditions that a vertex (or an edge) must meet in order to update it (either add or remove the given attribute and value).</p>
<p>You can define your own attribute operations by implementing the <code class="codeph">VertexOpCallback</code> and <code class="codeph">EdgeOpCallback</code> API interfaces. You must override the <code class="codeph">needOp</code> method, which defines the conditions to be satisfied by the vertices (or edges) to be included in the update operation, as well as the <code class="codeph">getAttributeKeyName</code> and <code class="codeph">getAttributeKeyValue</code> methods, which return the key name and value, respectively, to be used when updating the elements.</p>
<p>The following code fragment implements a <code class="codeph">VertexOpCallback</code> that operates over the <code class="codeph">obamaCollaborator</code> attribute associated only with Barack Obama collaborators. The value of this property is specified based on the role of the collaborators.</p>
<pre dir="ltr">
private static class CollaboratorsVertexOpCallback 
<span class="bold">implements VertexOpCallback</span>
{
private OracleVertexBase m_obama;
private List&lt;Vertex&gt; m_obamaCollaborators;

public CollaboratorsVertexOpCallback(OraclePropertyGraph opg)
{
// Get a list of Barack Obama'sCollaborators
m_obama = (OracleVertexBase) opg.getVertices("name", 
 "Barack Obama")
.iterator().next();

Iterable&lt;Vertex&gt; iter = m_obama.getVertices(Direction.BOTH, 
"collaborates");
m_obamaCollaborators = OraclePropertyGraphUtils.listify(iter);
}

public static CollaboratorsVertexOpCallback 
getInstance(OraclePropertyGraph opg)
{
return new CollaboratorsVertexOpCallback(opg);
}

/**
 * Add attribute if and only if the vertex is a collaborator of Barack 
 * Obama
*/
@Override
public boolean <span class="bold">needOp(OracleVertexBase v)</span>
{
return m_obamaCollaborators != null &amp;&amp; 
 m_obamaCollaborators.contains(v);
}

@Override
public String <span class="bold">getAttributeKeyName(OracleVertexBase v)</span>
{
return "obamaCollaborator";
}

/**
 * Define the property's value based on the vertex role
 */
@Override
public Object <span class="bold">getAttributeKeyValue(OracleVertexBase v)</span>
{
String role = v.getProperty("role");
role = role.toLowerCase();
if (role.contains("political")) {
return "political";
}
else if (role.contains("actor") || role.contains("singer") ||
 role.contains("actress") || role.contains("writer") ||
 role.contains("producer") || role.contains("director")) {
return "arts";
}
else if (role.contains("player")) {
return "sports";
}
else if (role.contains("journalist")) {
return "journalism";
}
else if (role.contains("business") || role.contains("economist")) {
return "business";
}
else if (role.contains("philanthropist")) {
return "philanthropy";
}
return " ";
}
}
</pre>
<p>The following code fragment implements an <code class="codeph">EdgeOpCallback</code> that operates over the <code class="codeph">obamaFeud</code> attribute associated only with Barack Obama feuds. The value of this property is specified based on the role of the collaborators.</p>
<pre dir="ltr">
private static class FeudsEdgeOpCallback 
<span class="bold">implements EdgeOpCallback</span>
{
private OracleVertexBase m_obama;
private List&lt;Edge&gt; m_obamaFeuds;

public FeudsEdgeOpCallback(OraclePropertyGraph opg)
{
// Get a list of Barack Obama's feuds
m_obama = (OracleVertexBase) opg.getVertices("name", 
 "Barack Obama")
.iterator().next();

Iterable&lt;Vertex&gt; iter = m_obama.getVertices(Direction.BOTH, 
"feuds");
m_obamaFeuds = OraclePropertyGraphUtils.listify(iter);
}

public static FeudsEdgeOpCallback getInstance(OraclePropertyGraph opg)
{
return new FeudsEdgeOpCallback(opg);
}

/**
 * Add attribute if and only if the edge is in the list of Barack Obama's 
 * feuds
*/
@Override
public boolean <span class="bold">needOp(OracleEdgeBase e)</span>
{
return m_obamaFeuds != null &amp;&amp; m_obamaFeuds.contains(e);
}

@Override
public String <span class="bold">getAttributeKeyName(OracleEdgeBase e)</span>
{
return "obamaFeud";
}

/**
 * Define the property's value based on the in/out vertex role
 */
@Override
public Object <span class="bold">getAttributeKeyValue(OracleEdgeBase e)</span>
{
OracleVertexBase v = (OracleVertexBase) e.getVertex(Direction.IN);
if (m_obama.equals(v)) {
v = (OracleVertexBase) e.getVertex(Direction.OUT);
}
String role = v.getProperty("role");
role = role.toLowerCase();

if (role.contains("political")) {
return "political";
}
else if (role.contains("actor") || role.contains("singer") ||
 role.contains("actress") || role.contains("writer") ||
 role.contains("producer") || role.contains("director")) {
return "arts";
}
else if (role.contains("journalist")) {
return "journalism";
}
else if (role.contains("player")) {
return "sports";
}
else if (role.contains("business") || role.contains("economist")) {
return "business";
}
else if (role.contains("philanthropist")) {
return "philanthropy";
}
return " ";
}
}
</pre>
<p>Using the operations callbacks defined previously, the following code fragment loads a property graph, creates an instance of the operation callbacks, and later adds the attributes into the pertinent vertices and edges using the <code class="codeph">addAttributeToAllVertices</code> and <code class="codeph">addAttributeToAllEdges</code> methods in <code class="codeph">OraclePropertyGraph</code>.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create the vertex operation callback
<span class="bold">CollaboratorsVertexOpCallback cvoc = CollaboratorsVertexOpCallback.getInstance(opg);</span>

// Add attribute to all people collaborating with Obama based on their role
<span class="bold">opg.addAttributeToAllVertices(cvoc, true /** Skip store to Cache */, dop);</span>

// Look up for all collaborators of Obama
Iterable&lt;Vertex&gt; collaborators = opg.getVertices("obamaCollaborator", "political");
System.out.println("Political collaborators of Barack Obama " + getVerticesAsString(collaborators));

collaborators = opg.getVertices("obamaCollaborator", "business");
System.out.println("Business collaborators of Barack Obama " + 
getVerticesAsString(collaborators));

// Add an attribute to all people having a feud with Barack Obama to set
// the type of relation they have
<span class="bold">FeudsEdgeOpCallback feoc = FeudsEdgeOpCallback.getInstance(opg);
opg.addAttributeToAllEdges(feoc, true /** Skip store to Cache */, dop);</span>

// Look up for all feuds of Obama
Iterable&lt;Edge&gt; feuds = opg.getEdges("obamaFeud", "political");
System.out.println("\n\nPolitical feuds of Barack Obama " + getEdgesAsString(feuds));

feuds = opg.getEdges("obamaFeud", "business");
System.out.println("Business feuds of Barack Obama " + 
getEdgesAsString(feuds));
</pre>
<p>The following code fragment defines an implementation of <code class="codeph">VertexOpCallback</code> that can be used to remove vertices having value philanthropy for attribute <code class="codeph">obamaCollaborator</code>, then call the API <code class="codeph">removeAttributeFromAllVertices</code>; It also defines an implementation of <code class="codeph">EdgeOpCallback</code> that can be used to remove edges having value business for attribute <code class="codeph">obamaFeud</code>, then call the API <code class="codeph">removeAttributeFromAllEdges</code>.</p>
<pre dir="ltr">
System.out.println("\n\nRemove 'obamaCollaborator' property from all the" + 
 "philanthropy collaborators");
PhilanthropyCollaboratorsVertexOpCallback pvoc = PhilanthropyCollaboratorsVertexOpCallback.getInstance();

<span class="bold">opg.removeAttributeFromAllVertices(pvoc);</span>

System.out.println("\n\nRemove 'obamaFeud' property from all the" + "business feuds");
BusinessFeudsEdgeOpCallback beoc = BusinessFeudsEdgeOpCallback.getInstance();

<span class="bold">opg.removeAttributeFromAllEdges(beoc);</span>

/**
 * Implementation of a EdgeOpCallback to remove the "obamaCollaborators" 
 * property from all people collaborating with Barack Obama that have a 
 * philanthropy role
 */
private static class PhilanthropyCollaboratorsVertexOpCallback implements VertexOpCallback
{
  public static PhilanthropyCollaboratorsVertexOpCallback getInstance()
  {
     return new PhilanthropyCollaboratorsVertexOpCallback();
  }
  
  /**
   * Remove attribute if and only if the property value for   
   * obamaCollaborator is Philanthropy
   */
  @Override
  public boolean needOp(OracleVertexBase v)
  {
    String type = v.getProperty("obamaCollaborator");
    return type != null &amp;&amp; type.equals("philanthropy");
  }

  @Override
  public String getAttributeKeyName(OracleVertexBase v)
  {
    return "obamaCollaborator";
  }

  /**
   * Define the property's value. In this case can be empty
   */
  @Override
  public Object getAttributeKeyValue(OracleVertexBase v)
  {
    return " ";
  }
}

/**
 * Implementation of a EdgeOpCallback to remove the "obamaFeud" property
 * from all connections in a feud with Barack Obama that have a business role
 */
private static class BusinessFeudsEdgeOpCallback implements EdgeOpCallback
{
  public static BusinessFeudsEdgeOpCallback getInstance()
  {
    return new BusinessFeudsEdgeOpCallback();
  }

  /**
   * Remove attribute if and only if the property value for obamaFeud is       
   * business
   */
  @Override
  public boolean needOp(OracleEdgeBase e)
  {
    String type = e.getProperty("obamaFeud");
    return type != null &amp;&amp; type.equals("business");
  }

 @Override
 public String getAttributeKeyName(OracleEdgeBase e)
 {
   return "obamaFeud";
 }

 /**
  * Define the property's value. In this case can be empty
  */
  @Override
  public Object getAttributeKeyValue(OracleEdgeBase e)
  {
    return " ";
  }
}
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-DE1C0716-45F4-4396-BE5E-A23AC8104296"></a>
<h4 id="BDSPA-GUID-DE1C0716-45F4-4396-BE5E-A23AC8104296" class="sect4"><span class="enumeration_section">5.4.2.8</span> Getting Property Graph Metadata</h4>
<div>
<p>You can get graph metadata and statistics, such as all graph names in the database; for each graph, getting the minimum/maximum vertex ID, the minimum/maximum edge ID, vertex property names, edge property names, number of splits in graph vertex, and the edge table that supports parallel table scans.</p>
<p>The following code fragment gets the metadata and statistics of the existing property graphs stored in the back-end database (either Oracle NoSQL Database or Apache HBase). The arguments required vary for each database.</p>
<pre dir="ltr">
// Get all graph names in the database
List&lt;String&gt; graphNames = OraclePropertyGraphUtils.getGraphNames(dbArgs);

for (String graphName : graphNames) {
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args, 
graphName);

System.err.println("\n Graph name: " + graphName);
System.err.println(" Total vertices: " + 
 <span class="bold">opg.countVertices(dop)</span>);
 
System.err.println(" Minimum Vertex ID: " + 
 <span class="bold">opg.getMinVertexID(dop)</span>);
System.err.println(" Maximum Vertex ID: " + 
 <span class="bold">opg.getMaxVertexID(dop)</span>);

Set&lt;String&gt; propertyNamesV = new HashSet&lt;String&gt;();
<span class="bold">opg.getVertexPropertyNames(dop, 0 /* timeout,0 no timeout */,
 propertyNamesV);</span>

System.err.println(" Vertices property names: " + 
getPropertyNamesAsString(propertyNamesV));

System.err.println("\n\n Total edges: " + <span class="bold">opg.countEdges(dop)</span>);
System.err.println(" Minimum Edge ID: " + <span class="bold">opg.getMinEdgeID(dop)</span>);
System.err.println(" Maximum Edge ID: " + <span class="bold">opg.getMaxEdgeID(dop)</span>);

Set&lt;String&gt; propertyNamesE = new HashSet&lt;String&gt;();
<span class="bold">opg.getEdgePropertyNames(dop, 0 /* timeout,0 no timeout */, 
 propertyNamesE);</span>

System.err.println(" Edge property names: " +
getPropertyNamesAsString(propertyNamesE));

System.err.println("\n\n Table Information: ");
System.err.println("Vertex table number of splits: " + 
 (<span class="bold">opg.getVertexTableSplits()</span>));
System.err.println("Edge table number of splits: " + 
 (<span class="bold">opg.getEdgeTableSplits()</span>));
}
</pre></div>
</div>
</div>
<a id="BDSPA218"></a>
<div class="props_rev_3"><a id="GUID-A25C4F9E-E84D-4585-AF70-CE244F8AB547"></a>
<h3 id="BDSPA-GUID-A25C4F9E-E84D-4585-AF70-CE244F8AB547" class="sect3"><span class="enumeration_section">5.4.3</span> Opening and Closing a Property Graph Instance</h3>
<div>
<p>When describing a property graph, use these Oracle Property Graph classes to open and close the property graph instance properly:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OraclePropertyGraph.getInstance</code>: Opens an instance of an Oracle property graph. This method has two parameters, the connection information and the graph name. The format of the connection information depends on whether you use HBase or Oracle NoSQL Database as the backend database.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.clearRepository</code>: Removes all vertices and edges from the property graph instance.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.shutdown</code>: Closes the graph instance.</p>
</li>
</ul>
<p>In addition, you must use the appropriate classes from the Oracle NoSQL Database or HBase APIs.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-24BD2A9F-DCB9-4CCB-ADC6-6C0F59037BE6">Using Oracle NoSQL Database</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-D11C4646-7854-4647-B046-339FFA11788D">Using Apache HBase</a><br /></li>
</ul>
</div>
<a id="BDSPA219"></a>
<div class="props_rev_3"><a id="GUID-24BD2A9F-DCB9-4CCB-ADC6-6C0F59037BE6"></a>
<h4 id="BDSPA-GUID-24BD2A9F-DCB9-4CCB-ADC6-6C0F59037BE6" class="sect4"><span class="enumeration_section">5.4.3.1</span> Using Oracle NoSQL Database</h4>
<div>
<p>For Oracle NoSQL Database, the <code class="codeph">OraclePropertyGraph.getInstance</code> method uses the KV store name, host computer name, and port number for the connection:</p>
<pre dir="ltr">
String kvHostPort = "cluster02:5000";
String kvStoreName = "kvstore";
String kvGraphName = "my_graph";

// Use NoSQL Java API
KVStoreConfig kvconfig = new KVStoreConfig(kvStoreName, kvHostPort);

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(kvconfig, kvGraphName);
opg.clearRepository(); 
//     .
//     .  Graph description
//     .
// Close the graph instance
opg.shutdown();
</pre>
<p>If the in-memory analyst functions are required for your application, then it is recommended that you use <code class="codeph">GraphConfigBuilder</code> to create a graph <code class="codeph">config</code> for Oracle NoSQL Database, and instantiates <code class="codeph">OraclePropertyGraph</code> with the <code class="codeph">config</code> as an argument.</p>
<p>As an example, the following code snippet constructs a graph <code class="codeph">config</code>, gets an <code class="codeph">OraclePropertyGraph</code> instance, loads some data into that graph, and gets an in-memory analyst.</p>
<pre dir="ltr">
  import oracle.pgx.config.*;
  import oracle.pgx.api.*;
  import oracle.pgx.common.types.*;

    ...
 
    String[] hhosts = new String[1];
    hhosts[0]          = "my_host_name:5000"; // need customization
    String szStoreName =  "kvstore";          // need customization
    String szGraphName = "my_graph";
    int dop            =  8;
 
    PgNosqlGraphConfig cfg = GraphConfigBuilder.forPropertyGraphNosql()
                                                     .setName(szGraphName)
                                                     .setHosts(Arrays.asList(hhosts))
                                                     .setStoreName(szStoreName)
                                                     .addEdgeProperty("lbl", PropertyType.STRING, "lbl")
                                                     .addEdgeProperty("weight", PropertyType.DOUBLE, "1000000")
                                                     .build();
 
    OraclePropertyGraph opg = OraclePropertyGraph.getInstance(cfg);  
 
    String szOPVFile = "../../data/connections.opv";
    String szOPEFile = "../../data/connections.ope";
 
    // perform a parallel data load
    OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
    opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
 
    ...
    PgxSession session = Pgx.createSession("session-id-1");
    PgxGraph g = session.readGraphWithProperties(cfg);

    Analyst analyst = session.createAnalyst();
    ...
</pre></div>
</div>
<a id="BDSPA220"></a>
<div class="props_rev_3"><a id="GUID-D11C4646-7854-4647-B046-339FFA11788D"></a>
<h4 id="BDSPA-GUID-D11C4646-7854-4647-B046-339FFA11788D" class="sect4"><span class="enumeration_section">5.4.3.2</span> Using Apache HBase</h4>
<div>
<p>For Apache HBase, the <code class="codeph">OraclePropertyGraph.getInstance</code> method uses the Hadoop nodes and the Apache HBase port number for the connection:</p>
<pre dir="ltr">
String hbQuorum = "bda01node01.example.com, bda01node02.example.com, bda01node03.example.com";
String hbClientPort = "2181"
String hbGraphName = "my_graph";
 
// Use HBase Java APIs
Configuration conf = HBaseConfiguration.create();
  conf.set("hbase.zookeeper.quorum", hbQuorum);
  conf.set("hbase.zookeper.property.clientPort", hbClientPort);
HConnection conn = HConnectionManager.createConnection(conf);
 
// Open the property graph
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(conf, conn, hbGraphName);
opg.clearRepository(); 
//     .
//     .  Graph description
//     .
// Close the graph instance
opg.shutdown();
// Close the HBase connection
conn.close();
</pre>
<p>If the in-memory analyst functions are required for your application, then it is recommended that you use <code class="codeph">GraphConfigBuilder</code> to create a graph <code class="codeph">config</code>, and instantiates <code class="codeph">OraclePropertyGraph</code> with the <code class="codeph">config</code> as an argument.</p>
<p>As an example, the following code snippet sets the configuration for in memory analytics, constructs a graph config for Apache HBase, instantiates an <code class="codeph">OraclePropertyGraph</code> instance, gets an in-memory analyst, and counts the number of triangles in the graph.</p>
<pre dir="ltr">
    confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;(); 
    confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false); 
    confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop + 2); 
    confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, 8); // &lt;= # of physical cores 
    confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2); 
    confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);// no timeout set 
    confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);  // no timeout set 
    ServerInstance instance = Pgx.getInstance();
    instance.startEngine(confPgx); 
 
int iClientPort = Integer.parseInt(hbClientPort);
int splitsPerRegion = 2;
 
PgHbaseGraphConfig cfg = GraphConfigBuilder.forPropertyGraphHbase()
                           .setName(hbGraphName)
                           .setZkQuorum(hbQuorum)
                           .setZkClientPort(iClientPort)
                           .setZkSessionTimeout(60000)
                           .setMaxNumConnections(dop)
                           .setSplitsPerRegion(splitsPerRegion)
                           .addEdgeProperty("lbl", PropertyType.STRING, "lbl")
                           .addEdgeProperty("weight", PropertyType.DOUBLE, "1000000")
                           .build();

PgxSession session = Pgx.createSession("session-id-1");
PgxGraph g = session.readGraphWithProperties(cfg);
Analyst analyst = session.createAnalyst();

long triangles = analyst.countTriangles(g, false);
</pre></div>
</div>
</div>
<a id="BDSPA221"></a>
<div class="props_rev_3"><a id="GUID-E0DAB9AE-5962-41AF-9B73-F390AF6189DC"></a>
<h3 id="BDSPA-GUID-E0DAB9AE-5962-41AF-9B73-F390AF6189DC" class="sect3"><span class="enumeration_section">5.4.4</span> Creating Vertices</h3>
<div>
<p>To create a vertex, use these Oracle Property Graph methods:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OraclePropertyGraph.addVertex</code>: Adds a vertex instance to a graph.</p>
</li>
<li>
<p><code class="codeph">OracleVertex.setProperty</code>: Assigns a key-value property to a vertex.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.commit</code>: Saves all changes to the property graph instance.</p>
</li>
</ul>
<p>The following code fragment creates two vertices named <code class="codeph">V1</code> and <code class="codeph">V2</code>, with properties for age, name, weight, height, and sex in the <code class="codeph">opg</code> property graph instance. The <code class="codeph">v1</code> properties set the data types explicitly.</p>
<pre dir="ltr">
// Create vertex v1 and assign it properties as key-value pairs
Vertex v1 = opg.addVertex(1l);
  v1.setProperty("age",  Integer.valueOf(31));
  v1.setProperty("name", "Alice");
  v1.setProperty("weight", Float.valueOf(135.0f));
  v1.setProperty("height", Double.valueOf(64.5d));
  v1.setProperty("female", Boolean.TRUE);
  
Vertex v2 = opg.addVertex(2l);
  v2.setProperty("age",  27);
  v2.setProperty("name", "Bob");
  v2.setProperty("weight", Float.valueOf(156.0f));
  v2.setProperty("height", Double.valueOf(69.5d));
  v2.setProperty("female", Boolean.FALSE); 
</pre></div>
</div>
<a id="BDSPA222"></a>
<div class="props_rev_3"><a id="GUID-B29900B4-6D97-41EF-B863-0CF17196234F"></a>
<h3 id="BDSPA-GUID-B29900B4-6D97-41EF-B863-0CF17196234F" class="sect3"><span class="enumeration_section">5.4.5</span> Creating Edges</h3>
<div>
<p>To create an edge, use these Oracle Property Graph methods:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OraclePropertyGraph.addEdge</code>: Adds an edge instance to a graph.</p>
</li>
<li>
<p><code class="codeph">OracleEdge.setProperty</code>: Assigns a key-value property to an edge.</p>
</li>
</ul>
<p>The following code fragment creates two vertices (<code class="codeph">v1</code> and <code class="codeph">v2</code>) and one edge (<code class="codeph">e1</code>).</p>
<pre dir="ltr">
// Add vertices v1 and v2
Vertex v1 = opg.addVertex(1l);
v1.setProperty("name", "Alice");
v1.setProperty("age", 31);

Vertex v2 = opg.addVertex(2l);  
v2.setProperty("name", "Bob");
v2.setProperty("age", 27);

// Add edge e1
Edge e1 = opg.addEdge(1l, v1, v2, "knows");
e1.setProperty("type", "friends");
</pre></div>
</div>
<a id="BDSPA223"></a>
<div class="props_rev_3"><a id="GUID-BFD2302B-C94B-47BC-A1AE-1BE4459BBBDD"></a>
<h3 id="BDSPA-GUID-BFD2302B-C94B-47BC-A1AE-1BE4459BBBDD" class="sect3"><span class="enumeration_section">5.4.6</span> Deleting Vertices and Edges</h3>
<div>
<p>You can remove vertex and edge instances individually, or all of them simultaneously. Use these methods:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OraclePropertyGraph.removeEdge</code>: Removes the specified edge from the graph.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.removeVertex</code>: Removes the specified vertex from the graph.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.clearRepository</code>: Removes all vertices and edges from the property graph instance.</p>
</li>
</ul>
<p>The following code fragment removes edge <code class="codeph">e1</code> and vertex <code class="codeph">v1</code> from the graph instance. The adjacent edges will also be deleted from the graph when removing a vertex. This is because every edge must have an beginning and ending vertex. After removing the beginning or ending vertex, the edge is no longer a valid edge.</p>
<pre dir="ltr">
// Remove edge e1
opg.removeEdge(e1);

// Remove vertex v1
opg.removeVertex(v1);
</pre>
<p>The <code class="codeph">OraclePropertyGraph.clearRepository</code> method can be used to remove all contents from an <code class="codeph">OraclePropertyGraph</code> instance. However, use it with care because this action cannot be reversed.</p>
</div>
</div>
<div class="props_rev_3"><a id="GUID-64E7B0BF-315E-45CE-ACD5-2566B33A7501"></a>
<h3 id="BDSPA-GUID-64E7B0BF-315E-45CE-ACD5-2566B33A7501" class="sect3"><span class="enumeration_section">5.4.7</span> Reading a Graph from a Database into an Embedded In-Memory Analyst</h3>
<div>
<p>You can read a graph from Apache HBase or Oracle NoSQL Database into an in-memory analyst that is embedded in the same client Java application (a single JVM). For the following Apache HBase example:</p>
<ul style="list-style-type: disc;">
<li>
<p>A correct <code class="codeph">java.io.tmpdir</code> setting is required.</p>
</li>
<li>
<p><code class="codeph">dop + 2</code> is a workaround for a performance issue before Release 1.1.2. Effective with Release 1.1.2, you can instead specify a <code class="codeph">dop</code> value directly in the configuration settings.</p>
</li>
</ul>
<pre dir="ltr">
int dop = 8;                    // need customization
Map&lt;PgxConfig.Field, Object&gt; confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;();
confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false);
confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop + 2);   // use dop directly with release 1.1.2 or newer
confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, dop); // &lt;= # of physical cores
confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2);
confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);  // no timeout set
confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);  // no timeout set

PgHbaseGraphConfig cfg = GraphConfigBuilder.forPropertyGraphHbase()
                          .setName("mygraph")
                          .setZkQuorum("localhost") // quorum, need customization
                          .setZkClientPort(2181)
                          .addNodeProperty("name", PropertyType.STRING, "default_name")
                          .build();

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(cfg);
ServerInstance localInstance = Pgx.getInstance();
localInstance.startEngine(confPgx);
PgxSession session = localInstance.createSession("session-id-1"); // Put your session description here.

Analyst analyst = session.createAnalyst();

// The following call will trigger a read of graph data from the database
PgxGraph pgxGraph = session.readGraphWithProperties(opg.getConfig());

long triangles = analyst.countTriangles(pgxGraph, false);
System.out.println("triangles " + triangles);

// Remove edge e1
opg.removeEdge(e1);

// Remove vertex v1
opg.removeVertex(v1);
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-5043DDBF-C215-4453-936B-FE0D24DE1D82"></a>
<h3 id="BDSPA-GUID-5043DDBF-C215-4453-936B-FE0D24DE1D82" class="sect3"><span class="enumeration_section">5.4.8</span> Specifying Labels for Vertices</h3>
<div>
<p>As explained in <a href="using-property-graphs-big-data.htm#GUID-E69FDE0A-ED35-4DA6-B4D7-AFC65479DDBD">What Are Property Graphs?</a>, the database and data access layer do not provide labels for vertices. However, you can treat the value of a designated vertex property as one or more labels. Such a transformation is relevant only to the in-memory analyst.</p>
<p>In the following example, a property "<code class="codeph">country</code>" is specified in a call to <code class="codeph">setUseVertexPropertyValueAsLabel()</code>, and the comma delimiter "<code class="codeph">,</code>" is specified in a call to <code class="codeph">setPropertyValueDelimiter()</code>. These two together imply that values of the <code class="codeph">country</code> vertex property will be treated as vertex labels separated by a comma. For example, if vertex X has a string value <code class="codeph">"US"</code> for its country property, then its vertex label will be <code class="codeph">US</code>; and if vertex Y has a string value <code class="codeph">"UK,CN"</code>, then it will have two labels: <code class="codeph">UK</code> and <code class="codeph">CN</code>.</p>
<pre dir="ltr">
GraphConfigBuilder.forPropertyGraph... 
   .setName("&lt;your_graph_name&gt;")
   ...
  .setUseVertexPropertyValueAsLabel("country")
  .setPropertyValueDelimiter(",")
  .build();
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-ECB7B9A0-038B-451A-AAAB-9F8815AE2602"></a>
<h3 id="BDSPA-GUID-ECB7B9A0-038B-451A-AAAB-9F8815AE2602" class="sect3"><span class="enumeration_section">5.4.9</span> Building an In-Memory Graph</h3>
<div>
<p>In addition to <a href="using-in-memory-analyst.htm#GUID-147E545D-CB0B-479A-8D7F-D36CF2064A45">Reading Graph Data into Memory</a>, you can create an in-memory graph programmatically. This can simplify development when the size of graph is small or when the content of the graph is highly dynamic. The key Java class is <code class="codeph">GraphBuilder</code>, which can accumulate a set of vertices and edges added with the <code class="codeph">addVertex</code> and <code class="codeph">addEdge</code> APIs. After all changes are made, an in-memory graph instance (<code class="codeph">PgxGraph</code>) can be created by the <code class="codeph">GraphBuilder</code>.</p>
<p>The following Java code snippet illustrates a graph construction flow. Note that there are no explicit calls to <code class="codeph">addVertex</code>, because any vertex that does not already exist will be added dynamically as its adjacent edges are created.</p>
<pre dir="ltr">
import oracle.pgx.api.*;

PgxSession session = Pgx.createSession("example");
GraphBuilder&lt;Integer&gt; builder = session.newGraphBuilder();

builder.addEdge(0, 1, 2);
builder.addEdge(1, 2, 3);
builder.addEdge(2, 2, 4);
builder.addEdge(3, 3, 4);
builder.addEdge(4, 4, 2);

PgxGraph graph = builder.build();
</pre>
<p>To construct a graph with vertex properties, you can use <code class="codeph">setProperty</code> against the vertex objects created.</p>
<pre dir="ltr">
PgxSession session = Pgx.createSession("example");
GraphBuilder&lt;Integer&gt; builder = session.newGraphBuilder();

builder.addVertex(1).setProperty("double-prop", 0.1);
builder.addVertex(2).setProperty("double-prop", 2.0);
builder.addVertex(3).setProperty("double-prop", 0.3);
builder.addVertex(4).setProperty("double-prop", 4.56789);

builder.addEdge(0, 1, 2);
builder.addEdge(1, 2, 3);
builder.addEdge(2, 2, 4);
builder.addEdge(3, 3, 4);
builder.addEdge(4, 4, 2);

PgxGraph graph = builder.build();
</pre>
<p>To use long integers as vertex and edge identifiers, specify <code class="codeph">IdType.LONG</code> when getting a new instance of <code class="codeph">GraphBuilder</code>. For example:</p>
<pre dir="ltr">
import oracle.pgx.common.types.IdType;
GraphBuilder&lt;Long&gt; builder = session.newGraphBuilder(IdType.LONG);
</pre>
<p>During edge construction, you can directly use vertex objects that were previously created in a call to <code class="codeph">addEdge</code>.</p>
<pre dir="ltr">
v1 = builder.addVertex(1l).setProperty("double-prop", 0.5)
v2 = builder.addVertex(2l).setProperty("double-prop", 2.0)

builder.addEdge(0, v1, v2)
</pre>
<p>As with vertices, edges can have properties. The following example sets the edge label by using <code class="codeph">setLabel</code>:</p>
<pre dir="ltr">
builder.addEdge(4, v4, v2).setProperty("edge-prop", "edge_prop_4_2").setLabel("label")
</pre></div>
</div>
<a id="BDSPA224"></a>
<div class="props_rev_3"><a id="GUID-EE2C73EA-2185-4BD7-B1F8-974D455F41D3"></a>
<h3 id="BDSPA-GUID-EE2C73EA-2185-4BD7-B1F8-974D455F41D3" class="sect3"><span class="enumeration_section">5.4.10</span> Dropping a Property Graph</h3>
<div>
<p>To drop a property graph from the database, use the <code class="codeph">OraclePropertyGraphUtils.dropPropertyGraph</code> method. This method has two parameters, the connection information and the graph name.</p>
<p>The format of the connection information depends on whether you use HBase or Oracle NoSQL Database as the backend database. It is the same as the connection information you provide to <code class="codeph">OraclePropertyGraph.getInstance</code>.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-275733B0-B0A1-4255-BB60-93EDF0B98DBC">Using Oracle NoSQL Database</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-8851ED84-932C-47F6-A514-691F58ABE9FC">Using Apache HBase</a><br /></li>
</ul>
</div>
<a id="BDSPA225"></a>
<div class="props_rev_3"><a id="GUID-275733B0-B0A1-4255-BB60-93EDF0B98DBC"></a>
<h4 id="BDSPA-GUID-275733B0-B0A1-4255-BB60-93EDF0B98DBC" class="sect4"><span class="enumeration_section">5.4.10.1</span> Using Oracle NoSQL Database</h4>
<div>
<p>For Oracle NoSQL Database, the <code class="codeph">OraclePropertyGraphUtils.dropPropertyGraph</code> method uses the KV store name, host computer name, and port number for the connection. This code fragment deletes a graph named <code class="codeph">my_graph</code> from Oracle NoSQL Database.</p>
<pre dir="ltr">
String kvHostPort = "cluster02:5000";
String kvStoreName = "kvstore";
String kvGraphName = "my_graph";

// Use NoSQL Java API
KVStoreConfig kvconfig = new KVStoreConfig(kvStoreName, kvHostPort);

// Drop the graph
OraclePropertyGraphUtils.dropPropertyGraph(kvconfig, kvGraphName);
</pre></div>
</div>
<a id="BDSPA226"></a>
<div class="props_rev_3"><a id="GUID-8851ED84-932C-47F6-A514-691F58ABE9FC"></a>
<h4 id="BDSPA-GUID-8851ED84-932C-47F6-A514-691F58ABE9FC" class="sect4"><span class="enumeration_section">5.4.10.2</span> Using Apache HBase</h4>
<div>
<p>For Apache HBase, the <code class="codeph">OraclePropertyGraphUtils.dropPropertyGraph</code> method uses the Hadoop nodes and the Apache HBase port number for the connection. This code fragment deletes a graph named <code class="codeph">my_graph</code> from Apache HBase.</p>
<pre dir="ltr">
String hbQuorum = "bda01node01.example.com, bda01node02.example.com, bda01node03.example.com";
String hbClientPort = "2181";
String hbGraphName = "my_graph";
 
// Use HBase Java APIs
Configuration conf = HBaseConfiguration.create();
    conf.set("hbase.zookeeper.quorum", hbQuorum);
    conf.set("hbase.zookeper.property.clientPort", hbClientPort);
 
// Drop the graph
OraclePropertyGraphUtils.dropPropertyGraph(conf, hbGraphName);
</pre></div>
</div>
</div>
</div>
<a id="BDSPA227"></a>
<div class="props_rev_3"><a id="GUID-727847CA-F6C9-40BD-B9BA-7FA48AF7D804"></a>
<h2 id="BDSPA-GUID-727847CA-F6C9-40BD-B9BA-7FA48AF7D804" class="sect2"><span class="enumeration_section">5.5</span> Managing Text Indexing for Property Graph Data</h2>
<div>
<p>Indexes in Oracle Big Data Spatial and Graph allow fast retrieval of elements by a particular key/value or key/text pair. These indexes are created based on an element type (vertices or edges), a set of keys (and values), and an index type.</p>
<p>Two types of indexing structures are supported by Oracle Big Data Spatial and Graph: manual and automatic.</p>
<ul style="list-style-type: disc;">
<li>
<p>Automatic text indexes provide automatic indexing of vertices or edges by a set of property keys. Their main purpose is to enhance query performance on vertices and edges based on particular key/value pairs.</p>
</li>
<li>
<p>Manual text indexes enable you to define multiple indexes over a designated set of vertices and edges of a property graph. You must specify what graph elements go into the index.</p>
</li>
</ul>
<p>Oracle Big Data Spatial and Graph provides APIs to create manual and automatic text indexes over property graphs for Oracle NoSQL Database and Apache HBase. Indexes are managed using the available search engines, Apache Lucene and SolrCloud. The rest of this section focuses on how to create text indexes using the property graph capabilities of the Data Access Layer.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-4705E3D2-D1AF-4ABC-A02A-DB19ADF997DB">Configuring a Text Index for Property Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-125EAC04-D4A5-4DF2-B839-26136F07374E">Using Automatic Indexes for Property Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-9860595A-3EA6-47C6-8C1C-51274E679D31">Using Manual Indexes for Property Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-74356147-A4EE-40B2-83DF-8BB0B2A4670F">Executing Search Queries Over Property Graph Text Indexes</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969">Handling Data Types</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A">Uploading a Collection's SolrCloud Configuration to Zookeeper</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-0DA1EF5E-18DE-4500-91C2-AF501ADC6168">Updating Configuration Settings on Text Indexes for Property Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-C574CB79-D84E-4011-95B1-62A696E0A87C">Using Parallel Query on Text Indexes for Property Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-E64FB9A9-B342-4C8E-AC05-5CF649E3B71A">Using Native Query Objects on Text Indexes for Property Graph Data</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-D5A410DB-7B39-4E62-AB87-709EB71D1BF0">Using Native Query Results on Text Indexes for Property Graph Data</a><br /></li>
</ul>
</div>
<div class="props_rev_3"><a id="GUID-4705E3D2-D1AF-4ABC-A02A-DB19ADF997DB"></a>
<h3 id="BDSPA-GUID-4705E3D2-D1AF-4ABC-A02A-DB19ADF997DB" class="sect3"><span class="enumeration_section">5.5.1</span> Configuring a Text Index for Property Graph Data</h3>
<div>
<p>The configuration of a text index is defined using an <code class="codeph">OracleIndexParameters</code> object. This object includes information about the index, such as search engine, location, number of directories (or shards) , and degree of parallelism.</p>
<p>By default, text indexes are configured based on the&nbsp;<code class="codeph">OracleIndexParameters</code>&nbsp;associated with the property graph using the method&nbsp;<code class="codeph">opg.setDefaultIndexParameters(indexParams)</code>. The initial creation of the automatic index delimits the configuration and text search engine for future indexed keys.</p>
<p>Indexes can also be created by specifying a different set of parameters. The following code fragment creates an automatic text index over an existing property graph using a Lucene engine with a physical directory.</p>
<pre dir="ltr">
// Create an OracleIndexParameters object to get Index configuration (search engine, etc).
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(args)  
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex("name", Vertex.class, indexParams.getParameters());
</pre>
<p>If you want to modify the initial configuration of a text index, you may need first to drop the existing graph and recreate the index using the new configuration.</p>
<ul style="list-style-type: disc;">
<li>
<p>Configuring Text Indexes Using the Apache Lucene Search Engine</p>
</li>
<li>
<p>Configuring Text Indexes using the SolrCloud Search Engine</p>
</li>
</ul>
<div class="section">
<p class="subhead3">Configuring Text Indexes Using the Apache Lucene Search Engine</p>
<p>A text index using Apache Lucene Search engine uses a <code class="codeph">LuceneIndexParameters</code> configuration object. The configuration parameters for indexes using a Lucene Search engine include:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Number of directories:</span> Integer specifying the number of Apache Lucene directories to use for the automatic index. Using multiple directories provides storage and performance scalability. The default value is set to 1.</p>
</li>
<li>
<p><span class="bold">Batch Size:</span> Integer specifying the batch size to use for document batching in Apache Lucene. The default batch size used is 10000.</p>
</li>
<li>
<p><span class="bold">Commit Batch Size:</span> Integer specifying the number of document to add into the Apache Lucene index before a commit operation is executed. The default commit batch size used is 500000.</p>
</li>
<li>
<p><span class="bold">Data type handling flag:</span> Boolean specifying if Apache Lucene data types handling is enabled. Enabling data types handling fasten up lookups over numeric and date time data types.</p>
</li>
<li>
<p><span class="bold">Directory names:</span> String array specifying the base path location where the Apache Lucene directories will be created.</p>
</li>
</ul>
<p>The following code fragment creates the configuration for a text index using Apache Lucene Search Engine with a physical directory.</p>
<pre dir="ltr">
OracleIndexParameters indexParams = 
      OracleIndexParameters.buildFS(4, 4, 10000, 50000, true, 
                                   "/home/data/text-index");
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Configuring Text Indexes using the SolrCloud Search Engine</p>
<p>A text index using SolrCloud Search engine uses a <code class="codeph">SolrIndexParameters</code> object behind the scenes to identify the SolrCloud host name, the number of shards, and replication factor used during the index construction. The configuration parameters for indexes using a SolrCloud Search engine include:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Configuration name:</span> Name of the Apache Zookeeper directory where the SolrCloud configuration files for Oracle Property Graph are stored. Example: <span class="italic">opgconfig</span>. The configuration files include the required field&rsquo;s schema (schema.xml) and storage settings (solrconfig.xml).</p>
</li>
<li>
<p>Server URL: the SolrCloud server URL used to connect to the SolrCloud service. Example: <span class="italic">http://localhost:2181/solr</span></p>
</li>
<li>
<p><span class="bold">SolrCloud Node Set:</span> Hostnames of the nodes in the SolrCloud service where the collection&rsquo;s shards will be stored. Example: <span class="italic">node01:8983_solr,node02:8983_solr,node03:8983_solr</span>. If the value is set to null, then the collection will be created using all the SolrCloud nodes available in the service.</p>
</li>
<li>
<p>Zookeeper Timeout: Positive integer representing the timeout (in seconds) used to wait for a Zookeeper connection.</p>
</li>
<li>
<p><span class="bold">Number of shards:</span> Number of shards to create for the text index collection. If the SolrCloud configuration is using an HDFS directory, the number of shards must not exceed the number of SolrCloud nodes specified in the SolrCloud node set.</p>
</li>
<li>
<p><span class="bold">Replication factor:</span> Replication factor used in the SolrCloud collection. The default value is set to <span class="italic">1</span>.</p>
</li>
<li>
<p><span class="bold">Maximum shards per node</span>: Maximum number of shards that can be created on each SolrCloud node. Note that this value must not be smaller than the number of shards divided by the number of nodes in the SolrCloud Node set.</p>
</li>
<li>
<p><span class="bold">DOP:</span> Degree of parallelism to use when reading the vertices (or edges) from the property graph and indexing the key/value pairs. The default value is set to <span class="italic">1</span>.</p>
</li>
<li>
<p><span class="bold">Batch Size:</span> Integer specifying the batch size to use for document batching in Apache SolrCloud. The default batch size used is 10000.</p>
</li>
<li>
<p><span class="bold">Commit Batch Size:</span> Integer specifying the number of documents to add into the Apache SolrCloud index before a commit operation is executed. The default commit batch size used is 500000 (five hundred thousand).</p>
</li>
<li>
<p><span class="bold">Write timeout:</span> Timeout (in seconds) used to wait for an index operation to be completed. If the index operation was unsuccessful due to a communication error, the operation will be tried repeatedly as needed until the timeout is reached or the operation completes.</p>
</li>
</ul>
<p>The following code fragment creates the configuration for a text index using SolrCloud.</p>
<pre dir="ltr">
String configName = "opgconfig";
String solrServerUrl = "nodea:2181/solr"
String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                     "nodec:8983_solr,noded:8983_solr";
 
int zkTimeout = 15;
int numShards = 4;
int replicationFactor = 1;
int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
</pre>
When using SolrCloud, you must first load a collection's configuration for the text indexes into Apache Zookeeper, as described in&nbsp;<a href="using-property-graphs-big-data.htm#GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A">Uploading a Collection's SolrCloud Configuration to Zookeeper</a>.</div>
<!-- class="section" --></div>
</div>
<a id="BDSPA228"></a>
<div class="props_rev_3"><a id="GUID-125EAC04-D4A5-4DF2-B839-26136F07374E"></a>
<h3 id="BDSPA-GUID-125EAC04-D4A5-4DF2-B839-26136F07374E" class="sect3"><span class="enumeration_section">5.5.2</span> Using Automatic Indexes for Property Graph Data</h3>
<div>
<p>An automatic text index provides automatic indexing of vertices or edges by a set of property keys. Its main purpose is to speed up lookups over vertices and edges based on particular key/value pair. If an automatic index for the given key is enabled, then a key/value pair lookup will be performed as a text search against the index instead of executing a database lookup.</p>
<p>When describing an automatic index over a property graph, use these Oracle property graph methods to create, remove, and manipulate an automatic index:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OraclePropertyGraph.createKeyIndex(String key, Class elementClass, Parameter[] parameters)</code>: Creates an automatic index for all elements of type <code class="codeph">elementClass</code> by the given property key. The index is configured based on the specified parameters.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.createKeyIndex(String[] keys, Class elementClass, Parameter[] parameters)</code>: Creates an automatic index for all elements of type <code class="codeph">elementClass</code> by using a set of property keys. The index is configured based on the specified parameters.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.dropKeyIndex(String key, Class elementClass)</code>: Drops the automatic index for all elements of type <code class="codeph">elementClass</code> for the given property key.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.dropKeyIndex(String[] keys, Class elementClass)</code>: Drops the automatic index for all elements of type <code class="codeph">elementClass</code> for the given set of property keys.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.getAutoIndex(Class elementClass)</code>: Gets an index instance of the automatic index for type <code class="codeph">elementClass</code>.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.getIndexedKeys(Class elementClass)</code>: Gets the set of indexed keys currently used in an automatic index for all elements of type <code class="codeph">elementClass</code>.</p>
</li>
</ul>
<p>The supplied examples <code class="codeph">ExampleNoSQL6</code> and <code class="codeph">ExampleHBase6</code> create a property graph from an input file, create an automatic text index on vertices, and execute some text search queries using Apache Lucene.</p>
<p>The following code fragment creates an automatic index over an existing property graph's vertices with these property keys: name, role, religion, and country. The automatic text index will be stored under four subdirectories under the <code class="codeph">/home/data/text-index</code> directory. Apache Lucene data types handling is enabled. This example uses a DOP (parallelism) of 4 for re-indexing tasks.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
      args,  szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
// number of connections to database, batch size, commit size, 
// enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(<span class="bold">4, 4, 10000, 50000, true,</span> 
             <span class="bold">"/home/data/text-index "</span>);
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class);
</pre>
<p>By default, indexes are configured based on the <code class="codeph">OracleIndexParameters</code> associated with the property graph using the method <code class="codeph">opg.setDefaultIndexParameters(indexParams</code>).</p>
<p>Indexes can also be created by specifying a different set of parameters. This is shown in the following code snippet.</p>
<pre dir="ltr">
// Create an OracleIndexParameters object to get Index configuration (search engine, etc).
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(args)  
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex("name", Vertex.class, indexParams.getParameters());
</pre>
<p>The code fragment in the next example executes a query over all vertices to find all matching vertices with the key/value pair <code class="codeph">name:Barack Obama</code>. This operation will execute a lookup into the text index.</p>
<p>Additionally, wildcard searches are supported by specifying the parameter <code class="codeph">useWildCards</code> in the <code class="codeph">getVertices</code> API call. Wildcard search is only supported when automatic indexes are enabled for the specified property key. For details on text search syntax using Apache Lucene, see <a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html" target="_blank"><code class="codeph">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</code></a>.</p>
<pre dir="ltr">
// Find all vertices with name Barack Obama. 
    Iterator&lt;Vertices&gt; vertices = opg.getVertices("name", "Barack Obama").iterator();
    System.out.println("----- Vertices with name Barack Obama -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
 
   // Find all vertices with name including keyword "Obama"
   // Wildcard searching is supported.
    boolean useWildcard = true;
    Iterator&lt;Vertices&gt; vertices = opg.getVertices("name", "*Obama*").iterator();
    System.out.println("----- Vertices with name *Obama* -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
</pre>
<p>The preceding code example produces output like the following:</p>
<pre dir="ltr">
----- Vertices with name Barack Obama-----
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 1
 
----- Vertices with name *Obama* -----
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 1
</pre>
<div class="infoboxnotealso" id="GUID-125EAC04-D4A5-4DF2-B839-26136F07374E__GUID-D9D22FA9-FCFA-492F-BBD9-8705D49B8FC3">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-property-graphs-big-data.htm#GUID-74356147-A4EE-40B2-83DF-8BB0B2A4670F">Executing Search Queries Over Property Graph Text Indexes</a></p>
</li>
<li>
<p><a href="using-property-graphs-big-data.htm#GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C" title="The software installation includes a directory of example programs, which you can use to learn about creating and manipulating property graphs.">Exploring the Sample Programs</a></p>
</li>
</ul>
</div>
</div>
</div>
<a id="BDSPA229"></a>
<div class="props_rev_3"><a id="GUID-9860595A-3EA6-47C6-8C1C-51274E679D31"></a>
<h3 id="BDSPA-GUID-9860595A-3EA6-47C6-8C1C-51274E679D31" class="sect3"><span class="enumeration_section">5.5.3</span> Using Manual Indexes for Property Graph Data</h3>
<div>
<p>Manual indexes provide support to define multiple indexes over the vertices and edges of a property graph. A manual index requires you to manually put, get, and remove elements from the index.</p>
<p>When describing a manual index over a property graph, use these Oracle property graph methods to add, remove, and manipulate a manual index:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">OraclePropertyGraph.createIndex(String name, Class elementClass, Parameter[] parameters)</code>: Creates a manual index with the specified name for all elements of type elementClass.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.dropIndex(String name)</code>: Drops the given manual index.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.getIndex(String name, Class elementClass)</code>: Gets an index instance of the given manual index for type elementClass.</p>
</li>
<li>
<p><code class="codeph">OraclePropertyGraph.getIndices()</code>: Gets an array of index instances for all manual indexes created in the property graph.</p>
</li>
</ul>
<p>The supplied examples <code class="codeph">ExampleNoSQL7</code> and <code class="codeph">ExampleHBase7</code> create a property graph from an input file, create a manual text index on edges, put some data into the index, and execute some text search queries using Apache SolrCloud.</p>
<p>When using SolrCloud, you must first load a collection's configuration for the text indexes into Apache Zookeeper, as described in <a href="using-property-graphs-big-data.htm#GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A">Uploading a Collection's SolrCloud Configuration to Zookeeper</a>.</p>
<p>The following code fragment creates a manual text index over an existing property graph using four shards, one shard per node, and a replication factor of 1. The number of shards corresponds to the number of nodes in the SolrCloud cluster.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args, 
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
   // number of connections to database, batch size, commit size, 
         // write timeout (in secs)
             String configName = "opgconfig";
             String solrServerUrl = "nodea:2181/solr"
             String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                                  "nodec:8983_solr,noded:8983_solr";
 
         int zkTimeout = 15;
         int numShards = 4;
         int replicationFactor = 1;
         int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
 
// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
          }
</pre>
<p>The next code fragment executes a query over the manual index to get all edges with the key/value pair c<code class="codeph">ollaboratesWith:Beyonce</code>. Additionally, wildcards search can be supported by specifying the parameter <code class="codeph">useWildCards</code> in the get API call.</p>
<pre dir="ltr">
// Find all edges with collaboratesWith Beyonce. 
   // Wildcard searching is supported using true parameter.
    edges = index.get("collaboratesWith", "Beyonce").iterator();
    System.out.println("----- Edges with name Beyonce -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
 
// Find all vertices with name including Bey*. 
   // Wildcard searching is supported using true parameter.
    edges = index.get("collaboratesWith", "*Bey*", true).iterator();
    System.out.println("----- Edges with collaboratesWith Bey* -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: " + countE);
</pre>
<p>The preceding code example produces output like the following:</p>
<pre dir="ltr">
----- Edges with name Beyonce -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
 
----- Edges with collaboratesWith Bey* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
</pre>
<div class="infoboxnotealso" id="GUID-9860595A-3EA6-47C6-8C1C-51274E679D31__XREFEXECUTINGSEARCHQUERIESOVERPROPE-3BE6AD6A">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="using-property-graphs-big-data.htm#GUID-74356147-A4EE-40B2-83DF-8BB0B2A4670F">Executing Search Queries Over Property Graph Text Indexes</a></p>
</li>
<li>
<p><a href="using-property-graphs-big-data.htm#GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C" title="The software installation includes a directory of example programs, which you can use to learn about creating and manipulating property graphs.">Exploring the Sample Programs</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="props_rev_3"><a id="GUID-74356147-A4EE-40B2-83DF-8BB0B2A4670F"></a>
<h3 id="BDSPA-GUID-74356147-A4EE-40B2-83DF-8BB0B2A4670F" class="sect3"><span class="enumeration_section">5.5.4</span> Executing Search Queries Over Property Graph Text Indexes</h3>
<div>
<p>You can execute text search queries over automatic and manual text indexes. These capabilities vary from querying based on a particular key/value pair, to executing a text search over a single or multiple keys (with extended query options as wildcards, fuzzy searches, and range queries).</p>
<ul style="list-style-type: disc;">
<li>
<p>Executing Search Queries Over a Text Index Using Apache Lucene</p>
</li>
<li>
<p>Executing Search Queries Over a Text Index Using SolrCloud</p>
</li>
</ul>
<div class="section">
<p class="subhead3">Executing Search Queries Over a Text Index Using Apache Lucene</p>
<p>The following code fragment creates an automatic index using Apache Lucene, and executes a query over the text index by specifying a particular key/value pair.</p>
<pre dir="ltr">
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
               OraclePropertyGraphDataLoader.getInstance();

opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
// number of connections to database, batch size, commit size, 
// enable datatypes, location)
OracleIndexParameters indexParams = 
            OracleIndexParameters.buildFS(4, 4, 10000, 50000, true, 
                                          "/home/data/text-index ");
opg.setDefaultIndexParameters(indexParams);

// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
while (edges.hasNext()) {
  Edge edge = edges.next();
  Vertex vIn = edge.getVertex(Direction.IN);
  index.put("collaboratesWith", vIn.getProperty("name"), edge);
  index.put("country", vIn.getProperty("country"), edge);
}
 
// Wildcard searching is supported using true parameter.
Iterator&lt;Edge&gt; edges = index.get("country", "United States").iterator();
System.out.println("----- Edges with query: " + queryExpr + " -----");
long countE = 0;
while (edges.hasNext()) {
  System.out.println(edges.next());
  countE++;
}
System.out.println("Edges found: "+ countE);
</pre>
<p>In this case, the text index will produce a search query out of the key and value objects. Also note that if the <code class="codeph">useWildcards</code> flag is not specified or enabled, then results retrieved will include only exact matches. If the value object is a numeric or date-time value, the produced query will be an inclusive range query where the lower and upper limit are defined by the value. Only numeric or date-time matches will be retrieved.</p>
<p>If the value is a string, then all matching key/value pairs will be retrieved regardless of their data type. The resulting text query of this type of queries is a Boolean query with a set of optional search terms, one for each supported data type. For more information about data type handling, see <a href="using-property-graphs-big-data.htm#GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969">Handling Data Types</a>.</p>
<p>Thus, the previous code example produces a query expression&nbsp;<span class="italic">country1:"United States" OR country9:"United States" OR &hellip; OR countryE:"United States"</span>&nbsp;(if Lucene's data type handling is enabled), or<span class="italic">&nbsp;country:"1United States" OR country:"2United States" OR &hellip; OR country:"EUnited States"</span> (if Lucene's data type handling is disabled).</p>
<p>If a String value object has wildcards enabled, the value must be written using Apache Lucene Syntax. For information about text search syntax using Apache Lucene, see: <a href="https://lucene.apache.org/core/2_9_4/queryparsersyntax.html" target="_blank">https://lucene.apache.org/core/2_9_4/queryparsersyntax.html</a></p>
<p>You can filter the date type of the matching key/value pairs by specifying the data type class to execute the query against. The following code fragment executes a query over the text index using a single key/value pair with String data type only. The following code produces a query expression&nbsp;<span class="italic">country1:"United States"</span>&nbsp;(if Lucene's data type handling is enabled), or&nbsp;<span class="italic">country:"1United States"</span> (if Lucene's data type handling is disabled).</p>
<pre dir="ltr">
// Wildcard searching is supported using true parameter.
Iterator&lt;Edge&gt; edges = index.get("country", "United States", true, String.class).iterator();

System.out.println("----- Edges with query: " + queryExpr + " -----");
long countE = 0;
while (edges.hasNext()) {
  System.out.println(edges.next());
  countE++;
}
System.out.println("Edges found: "+ countE);
</pre>
<p>When dealing with Boolean operators, each subsequent key/value pair must append the data type's prefix/suffix so the query can find proper matches. Utilities are provided to help users write their own Lucene text search queries using the query syntax and data type identifiers required by the automatic and manual text indexes.</p>
<p>The method <code class="codeph">buildSearchTerm(key, value, dtClass)</code>&nbsp;in&nbsp;<code class="codeph">LuceneIndex</code>&nbsp;creates a query expression of the form&nbsp;<span class="italic">field:query_expr</span>&nbsp;by adding the data type identifier to the key (or value) and transforming the value into the required string representation based on the given data type and Apache Lucene's data type handling configuration.</p>
<p>The following code fragment uses the&nbsp;<code class="codeph">buildSearchTerm</code>&nbsp;method to produce a query expression&nbsp;<span class="italic">country1:United*</span>&nbsp;(if Lucene's data type handling is enabled), or&nbsp;<span class="italic">country:1United*</span>&nbsp;(if Lucene's data type handling is disabled) used in the previous examples:</p>
<pre dir="ltr">
String szQueryStrCountry = index.buildSearchTerm("country", 
                                  "United*", String.class);
</pre>
<p>To deal with the key and values as individual objects to construct a different Lucene query like a <code class="codeph">WildcardQuery</code>, the methods&nbsp;<code class="codeph">appendDatatypesSuffixToKey(key, dtClass)</code>&nbsp;and&nbsp;<code class="codeph">appendDatatypesSuffixToValue(value, dtClass)</code>&nbsp;in <code class="codeph">LuceneIndex</code> will append the appropriate data type identifiers and transform the value into the required Lucene string representation based on the given data type.</p>
<p>The following code fragment uses the <code class="codeph">appendDatatypesSuffixToKey</code>&nbsp;method to generate the field name required in a Lucene text query. If Lucene&rsquo;s data type handling is enabled, the string returned will append the String data type identifier as a suffix of the key (<code class="codeph">country1</code>). In any other case, the retrieved string will be the original key (<code class="codeph">country</code>).</p>
<pre dir="ltr">
String key = index.appendDatatypesSuffixToKey("country", String.class);
</pre>
<p>The next code fragment uses the&nbsp;appendDatatypesSuffixToValue&nbsp;method to generate the query body expression required in a Lucene text query. If Lucene&rsquo;s data type handling is disabled, the string returned will append the String data type identifier as a prefix of the key (1United*). In all other cases, the string returned will be the string representation of the value (United*).</p>
<pre dir="ltr">
String value = index.appendDatatypesSuffixToValue("United*", String.class);
</pre>
<p><code class="codeph">LuceneIndex</code>&nbsp;also supports generating a Term object using the method&nbsp;<code class="codeph">buildSearchTermObject(key, value, dtClass)</code>. Term objects are commonly used among different types of Lucene Query objects to constrain the fields and values of the documents to be retrieved. The following code fragment shows how to create a <code class="codeph">WildcardQuery</code> object using the&nbsp;<code class="codeph">buildSearchTermObject</code>&nbsp;method.</p>
<pre dir="ltr">
Term term = index.buildSearchTermObject("country", "United*", String.class);  
Query query = new WildcardQuery(term);
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Executing Search Queries Over a Text Index Using SolrCloud</p>
<p>The following code fragment creates an automatic index using SolrCloud, and executes a query over the text index by specifying a particular key/value pair.</p>
<pre dir="ltr">
// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
// number of connections to database, batch size, commit size, 
// write timeout (in secs)
String configName = "opgconfig";
String solrServerUrl = "nodea:2181/solr"
String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                     "nodec:8983_solr,noded:8983_solr";
 
int zkTimeout = 15;
int numShards = 4;
int replicationFactor = 1;
int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class); 

// Create manual indexing on above properties for all vertices
OracleIndex&lt;Vertex&gt; index = ((OracleIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);
 
Iterator&lt;Vertex&gt; vertices = index.get("country", "United States").iterator();
System.out.println("----- Vertices with query: " + queryExpr + " -----");
countV = 0;
while (vertices.hasNext()) {
  System.out.println(vertices.next());
  countV++;
}
System.out.println("Vertices found: "+ countV);
</pre>
<p>In this case, the text index will produce a search out of the value object. Also note that if the <code class="codeph">useWildcards</code> flag is not specified or enabled, then results retrieved will include only exact matches. If the value object is a numeric or date time value, the produced query will be an inclusive range query where the lower and upper limit is defined by the value. Only numeric or date-time matches will be retrieved.</p>
<p>If the value is a string, then all matching key/value pairs will be retrieved regardless of their data type. The resulting text query of this type of queries is a Boolean query with a set of optional search terms, one for each supported data type. For more information about data type handling, see <a href="using-property-graphs-big-data.htm#GUID-74356147-A4EE-40B2-83DF-8BB0B2A4670F___3.6.5_HANDLING_DATA">Handling Data Types</a>.</p>
<p>Thus, the previous code example produces a query expression&nbsp;<span class="italic">country_str:"United States" OR country_ser:"United States" OR &hellip; OR country_json:"United States"</span>.</p>
<p>Using a String value object with wildcards enabled requires that the value is written using Apache Lucene Syntax. For information about text search syntax using Apache Lucene, see <a href="using-property-graphs-big-data.htm#GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969">Handling Data Types</a></p>
<p>You can filter the date type of the matching key/value pairs by specifying the data type class to execute the query against. The following code fragment executes a query over the text index using a single key/value pair with String data type only. The following code produces a query expression&nbsp;<span class="italic">country_str:"United States".</span></p>
<pre dir="ltr">
// Wildcard searching is supported using true parameter.
Iterator&lt;Edge&gt; edges = index.get("country", "United States", true, String.class).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre>
<p>When dealing with Boolean operators, each subsequent key/value pair must append the data type's prefix/suffix so the query can find proper matches. A set of utilities is provided to help users write their own SolrCloud text search queries using the query syntax and data type identifiers required by the automatic and manual text indexes.</p>
<p>The method <code class="codeph">buildSearchTerm(key, value, dtClass)</code>&nbsp;in&nbsp;<code class="codeph">SolrIndex</code>&nbsp;creates a query expression of the form&nbsp;<span class="italic">field:query_expr</span>&nbsp;by adding the data type identifier to the key (or value) and transforming the value into the required string representation using the data type formats required by the index.</p>
<p>The following code fragment uses the&nbsp;<code class="codeph">buildSearchTerm</code>&nbsp;method to produce a query expression&nbsp;<span class="italic">country_str:United*</span>&nbsp;used in the previous example:</p>
<pre dir="ltr">
String szQueryStrCountry = index.buildSearchTerm("country", 
                                  "United*", String.class);
</pre>
<p>To deal with the key and values as individual objects to construct a different SolrClud query like a <code class="codeph">WildcardQuery</code>, the methods&nbsp;<code class="codeph">appendDatatypesSuffixToKey(key, dtClass)</code>&nbsp;and&nbsp;<code class="codeph">appendDatatypesSuffixToValue(value, dtClass)</code>&nbsp;in&nbsp;<code class="codeph">SolrIndex</code>&nbsp;will append the appropriate data type identifiers and transform the key and value into the required SolrCloud string representation based on the given data type.</p>
<p>The following code fragment uses the <code class="codeph">appendDatatypesSuffixToKey</code>&nbsp;method to generate the field name required in a SolrCloud text query. The retrieved string will append the String data type identifier as a suffix of the key (<code class="codeph">country_str</code>).</p>
<pre dir="ltr">
String key = index.appendDatatypesSuffixToKey("country", String.class);
</pre>
<p>The next code fragment uses the&nbsp;<code class="codeph">appendDatatypesSuffixToValue</code>&nbsp;method to generate the query body expression required in a SolrCloud text query. The string returned will be the string representation of the value (<code class="codeph">United*</code>).</p>
<pre dir="ltr">
String value = index.appendDatatypesSuffixToValue("United*", String.class);
</pre></div>
<!-- class="section" --></div>
</div>
<a id="BDSPA230"></a>
<div class="props_rev_3"><a id="GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969"></a>
<h3 id="BDSPA-GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969" class="sect3"><span class="enumeration_section">5.5.5</span> Handling Data Types</h3>
<div>
<p>Oracle's property graph support indexes and stores an element's Key/Value pairs based on the value data type. The main purpose of handling data types is to provide extensive query support like numeric and date range queries.</p>
<p>By default, searches over a specific key/value pair are matched up to a query expression based on the value's data type. For example, to find vertices with the key/value pair <code class="codeph">age:30</code>, a query is executed over all age fields with a data type integer. If the value is a query expression, you can also specify the data type class of the value to find by calling the API <code class="codeph">get(String key, Object value, Class dtClass, Boolean useWildcards)</code>. If no data type is specified, the query expression will be matched to all possible data types.</p>
<p>When dealing with Boolean operators, each subsequent key/value pair must append the data type's prefix/suffix so the query can find proper matches. The following topics describe how to append this prefix/suffix for Apache Lucene and SolrCloud.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA">Appending Data Type Identifiers on Apache Lucene</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363">Appending Data Type Identifiers on SolrCloud</a><br /></li>
</ul>
</div>
<a id="BDSPA232"></a><a id="BDSPA231"></a>
<div class="props_rev_3"><a id="GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA"></a>
<h4 id="BDSPA-GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA" class="sect4"><span class="enumeration_section">5.5.5.1</span> Appending Data Type Identifiers on Apache Lucene</h4>
<div>
<p>When Lucene's data types handling is enabled, you must append the proper data type identifier as a suffix to the key in the query expression. This can be done by executing a <code class="codeph">String.concat()</code> operation to the key. If Lucene's data types handling is disabled, you must insert the data type identifier as a prefix in the value String. <a href="using-property-graphs-big-data.htm#GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA__CEGECEDC" title="Apache Lucene Data Type Identifiers">Table 5-2</a> shows the data type identifiers available for text indexing using Apache Lucene (see also the Javadoc for <code class="codeph">LuceneIndex</code>).</p>
<div class="tblformal" id="GUID-65E00C95-FE6A-46F0-9F19-FE2CC2FB40FA__CEGECEDC">
<p class="titleintable">Table 5-2 Apache Lucene Data Type Identifiers</p>
<table class="cellalignment333" title="Apache Lucene Data Type Identifiers" summary="Apache Lucene Data Type Identifiers">
<thead>
<tr class="cellalignment324">
<th class="cellalignment334" id="d28904e4230">Lucene Data Type Identifier</th>
<th class="cellalignment335" id="d28904e4233">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4238" headers="d28904e4230">
<p>TYPE_DT_STRING</p>
</td>
<td class="cellalignment337" headers="d28904e4238 d28904e4233">
<p>String</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4245" headers="d28904e4230">
<p>TYPE_DT_BOOL</p>
</td>
<td class="cellalignment337" headers="d28904e4245 d28904e4233">
<p>Boolean</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4252" headers="d28904e4230">
<p>TYPE_DT_DATE</p>
</td>
<td class="cellalignment337" headers="d28904e4252 d28904e4233">
<p>Date</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4259" headers="d28904e4230">
<p>TYPE_DT_FLOAT</p>
</td>
<td class="cellalignment337" headers="d28904e4259 d28904e4233">
<p>Float</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4266" headers="d28904e4230">
<p>TYPE_DT_DOUBLE</p>
</td>
<td class="cellalignment337" headers="d28904e4266 d28904e4233">
<p>Double</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4273" headers="d28904e4230">
<p>TYPE_DT_INTEGER</p>
</td>
<td class="cellalignment337" headers="d28904e4273 d28904e4233">
<p>Integer</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4280" headers="d28904e4230">
<p>TYPE_DT_LONG</p>
</td>
<td class="cellalignment337" headers="d28904e4280 d28904e4233">
<p>Long</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4287" headers="d28904e4230">
<p>TYPE_DT_CHAR</p>
</td>
<td class="cellalignment337" headers="d28904e4287 d28904e4233">
<p>Character</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4294" headers="d28904e4230">
<p>TYPE_DT_SHORT</p>
</td>
<td class="cellalignment337" headers="d28904e4294 d28904e4233">
<p>Short</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4301" headers="d28904e4230">
<p>TYPE_DT_BYTE</p>
</td>
<td class="cellalignment337" headers="d28904e4301 d28904e4233">
<p>Byte</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4308" headers="d28904e4230">
<p>TYPE_DT_SPATIAL</p>
</td>
<td class="cellalignment337" headers="d28904e4308 d28904e4233">
<p>Spatial</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4316" headers="d28904e4230">
<p>TYPE_DT_SERIALIZABLE</p>
</td>
<td class="cellalignment337" headers="d28904e4316 d28904e4233">
<p>Serializable</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The following code fragment creates a manual index on edges using Lucene's data type handling, adds data, and later executes a query over the manual index to get all edges with the key/value pair <code class="codeph">collaboratesWith:Beyonce AND country1:United*</code> using wildcards.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,               
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Specify Index Directory parameters (number of directories, 
   // number of connections to database, batch size, commit size, 
         // enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(<span class="bold">4, 4, 10000, 50000, true, 
            "/home/data/text-index "</span>);
opg.setDefaultIndexParameters(indexParams);
// Create manual indexing on above properties for all edges
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
             index.put("country", vIn.getProperty("country"), edge);
          }
 
// Wildcard searching is supported using true parameter.
    String key = "country";
    key = key.concat(String.valueOf(oracle.pg.text.lucene.LuceneIndex.TYPE_DT_STRING));
   
    String queryExpr = "Beyonce AND " + key + ":United*";
    edges = index.get("collaboratesWith", queryExpr, true /*UseWildcard*/).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre>
<p>The preceding code example might produce output like the following:</p>
<pre dir="ltr">
----- Edges with name Beyonce AND country1:United* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
</pre>
<p>The following code fragment creates an automatic index on vertices, disables Lucene's data type handling, adds data, and later executes a query over the manual index from a previous example to get all vertices with the key/value pair <code class="codeph">country:United* AND role:1*political*</code> using wildcards.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,               
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create an automatic index using Apache Lucene engine. 
// Specify Index Directory parameters (number of directories, 
   // number of connections to database, batch size, commit size, 
         // enable datatypes, location)
OracleIndexParameters indexParams = 
     OracleIndexParameters.buildFS(<span class="bold">4, 4, 10000, 50000, false, "/ home/data/text-index "</span>);
opg.setDefaultIndexParameters(indexParams);
    
// specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class);
 
// Wildcard searching is supported using true parameter.
    String value = "*political*";
    value = String.valueOf(LuceneIndex.TYPE_DT_STRING) + value;
String queryExpr = "United* AND role:" + value;
    
 
vertices = opg.getVertices("country", queryExpr,  true /*useWildcard*/).iterator();
    System.out.println("----- Vertices with query: " + queryExpr + " -----");
    countV = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      countV++;
    }
    System.out.println("Vertices found: " + countV);
</pre>
<p>The preceding code example might produce output like the following:</p>
<pre dir="ltr">
----- Vertices with query: United* and role:1*political* -----
Vertex ID 30 {name:str:Jerry Brown, role:str:political authority, occupation:str:34th and 39th governor of California, country:str:United States, political party:str:Democratic, religion:str:roman catholicism}
Vertex ID 24 {name:str:Edward Snowden, role:str:political authority, occupation:str:system administrator, country:str:United States, religion:str:buddhism}
Vertex ID 22 {name:str:John Kerry, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:68th United States Secretary of State, religion:str:Catholicism}
Vertex ID 21 {name:str:Hillary Clinton, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:67th United States Secretary of State, religion:str:Methodism}
Vertex ID 19 {name:str:Kirsten Gillibrand, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:junior United States Senator from New York, religion:str:Methodism}
Vertex ID 13 {name:str:Ertharin Cousin, role:str:political authority, country:str:United States, political party:str:Democratic}
Vertex ID 11 {name:str:Eric Holder, role:str:political authority, country:str:United States, political party:str:Democratic, occupation:str:United States Deputy Attorney General}
Vertex ID 1 {name:str:Barack Obama, role:str:political authority, occupation:str:44th president of United States of America, country:str:United States, political party:str:Democratic, religion:str:Christianity}
Vertices found: 8
</pre></div>
</div>
<a id="BDSPA234"></a><a id="BDSPA233"></a>
<div class="props_rev_3"><a id="GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363"></a>
<h4 id="BDSPA-GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363" class="sect4"><span class="enumeration_section">5.5.5.2</span> Appending Data Type Identifiers on SolrCloud</h4>
<div>
<p>For Boolean operations on SolrCloud text indexes, you must append the proper data type identifier as suffix to the key in the query expression. This can be done by executing a <code class="codeph">String.concat()</code> operation to the key. <a href="using-property-graphs-big-data.htm#GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363__CEGGAEJA" title="SolrCloud Data Type Identifiers">Table 5-3</a> shows the data type identifiers available for text indexing using SolrCloud (see the Javadoc for <code class="codeph">SolrIndex</code>).</p>
<div class="tblformal" id="GUID-08F1EF7C-069B-4D27-93F1-31DDFF267363__CEGGAEJA">
<p class="titleintable">Table 5-3 SolrCloud Data Type Identifiers</p>
<table class="cellalignment333" title="SolrCloud Data Type Identifiers" summary="SolrCloud Data Type Identifiers">
<thead>
<tr class="cellalignment324">
<th class="cellalignment334" id="d28904e4420">Solr Data Type Identifier</th>
<th class="cellalignment335" id="d28904e4423">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4428" headers="d28904e4420">
<p>TYPE_DT_STRING</p>
</td>
<td class="cellalignment337" headers="d28904e4428 d28904e4423">
<p>String</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4435" headers="d28904e4420">
<p>TYPE_DT_BOOL</p>
</td>
<td class="cellalignment337" headers="d28904e4435 d28904e4423">
<p>Boolean</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4442" headers="d28904e4420">
<p>TYPE_DT_DATE</p>
</td>
<td class="cellalignment337" headers="d28904e4442 d28904e4423">
<p>Date</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4449" headers="d28904e4420">
<p>TYPE_DT_FLOAT</p>
</td>
<td class="cellalignment337" headers="d28904e4449 d28904e4423">
<p>Float</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4456" headers="d28904e4420">
<p>TYPE_DT_DOUBLE</p>
</td>
<td class="cellalignment337" headers="d28904e4456 d28904e4423">
<p>Double</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4463" headers="d28904e4420">
<p>TYPE_DT_INTEGER</p>
</td>
<td class="cellalignment337" headers="d28904e4463 d28904e4423">
<p>Integer</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4470" headers="d28904e4420">
<p>TYPE_DT_LONG</p>
</td>
<td class="cellalignment337" headers="d28904e4470 d28904e4423">
<p>Long</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4477" headers="d28904e4420">
<p>TYPE_DT_CHAR</p>
</td>
<td class="cellalignment337" headers="d28904e4477 d28904e4423">
<p>Character</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4484" headers="d28904e4420">
<p>TYPE_DT_SHORT</p>
</td>
<td class="cellalignment337" headers="d28904e4484 d28904e4423">
<p>Short</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4491" headers="d28904e4420">
<p>TYPE_DT_BYTE</p>
</td>
<td class="cellalignment337" headers="d28904e4491 d28904e4423">
<p>Byte</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4498" headers="d28904e4420">
<p>TYPE_DT_SPATIAL</p>
</td>
<td class="cellalignment337" headers="d28904e4498 d28904e4423">
<p>Spatial</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment336" id="d28904e4506" headers="d28904e4420">
<p>TYPE_DT_SERIALIZABLE</p>
</td>
<td class="cellalignment337" headers="d28904e4506 d28904e4423">
<p>Serializable</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The following code fragment creates a manual index on edges using SolrCloud, adds data, and later executes a query over the manual index to get all edges with the key/value pair <code class="codeph">collaboratesWith:Beyonce AND country1:United*</code> using wildcards.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(args,       
                                                          szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = 
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 
    
// Create a manual text index using SolrCloud// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set, 
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,  
   // number of connections to database, batch size, commit size, 
         // write timeout (in secs)
             String configName = "opgconfig";
             String solrServerUrl = "nodea:2181/solr";
             String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +  
                                  "nodec:8983_solr,noded:8983_solr";
 
         int zkTimeout = 15;
         int numShards = 4;
         int replicationFactor = 1;
         int maxShardsPerNode = 1;
 
OracleIndexParameters indexParams = 
                 OracleIndexParameters.buildSolr(configName, 
                                       solrServerUrl, 
                                       solrNodeSet, 
                                       zkTimeout,
                                       numShards,
                                       replicationFactor,
                                       maxShardsPerNode,
                                       4,
                                       10000,
                                       500000,
                                       15);
opg.setDefaultIndexParameters(indexParams);
    
// Create manual indexing on above properties for all vertices
OracleIndex&lt;Edge&gt; index = ((OracleIndex&lt;Edge&gt;) opg.createIndex("myIdx", Edge.class));
 
Vertex v1 = opg.getVertices("name", "Barack Obama").iterator().next();
 
Iterator&lt;Edge&gt; edges
                = v1.getEdges(Direction.OUT, "collaborates").iterator();
 
          while (edges.hasNext()) {
             Edge edge = edges.next();
             Vertex vIn = edge.getVertex(Direction.IN);
             index.put("collaboratesWith", vIn.getProperty("name"), edge);
             index.put("country", vIn.getProperty("country"), edge);
          }
 
// Wildcard searching is supported using true parameter.
    String key = "country";
    key = key.concat(oracle.pg.text.solr.SolrIndex.TYPE_DT_STRING);
   
    String queryExpr = "Beyonce AND " + key + ":United*";
    edges = index.get("collaboratesWith", queryExpr, true /** UseWildcard*/).iterator();
    System.out.println("----- Edges with query: " + queryExpr + " -----");
    countE = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      countE++;
    }
    System.out.println("Edges found: "+ countE);
</pre>
<p>The preceding code example might produce output like the following:</p>
<pre dir="ltr">
----- Edges with name Beyonce AND country_str:United* -----
Edge ID 1000 from Vertex ID 1 {country:str:United States, name:str:Barack Obama, occupation:str:44th president of United States of America, political party:str:Democratic, religion:str:Christianity, role:str:political authority} =[collaborates]=&gt; Vertex ID 2 {country:str:United States, music genre:str:pop soul , name:str:Beyonce, role:str:singer actress} edgeKV[{weight:flo:1.0}]
Edges found: 1
</pre></div>
</div>
</div>
<a id="BDSPA235"></a>
<div class="props_rev_3"><a id="GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A"></a>
<h3 id="BDSPA-GUID-9C965F50-F769-4C67-8123-56E8BC36FD4A" class="sect3"><span class="enumeration_section">5.5.6</span> Uploading a Collection's SolrCloud Configuration to Zookeeper</h3>
<div>
<p>Before using SolrCloud text indexes on Oracle Big Data Spatial and Graph property graphs, you must upload a collection's configuration to Zookeeper. This can be done using the ZkCli tool from one of the SolrCloud cluster nodes.</p>
<p>A predefined collection configuration directory can be found in <code class="codeph">dal/opg-solr-config</code> under the installation home. The following shows an example on how to upload the PropertyGraph configuration directory.</p>
<ol>
<li>
<p>Copy dal/opg-solr-config under the installation home into /tmp directory on one of the Solr cluster nodes. For example:</p>
<pre dir="ltr">
scp &ndash;r dal/opg-solr-config user@solr-node:/tmp
</pre></li>
<li>
<p>Execute the following command line like the following example using the ZkCli tool on the same node:</p>
<pre dir="ltr">
$SOLR_HOME/bin/zkcli.sh -zkhost 127.0.0.1:2181/solr -cmd upconfig &ndash;confname opgconfig -confdir /tmp/opg-solr-config
</pre></li>
</ol>
</div>
</div>
<a id="BDSPA458"></a>
<div class="props_rev_3"><a id="GUID-0DA1EF5E-18DE-4500-91C2-AF501ADC6168"></a>
<h3 id="BDSPA-GUID-0DA1EF5E-18DE-4500-91C2-AF501ADC6168" class="sect3"><span class="enumeration_section">5.5.7</span> Updating Configuration Settings on Text Indexes for Property Graph Data</h3>
<div>
<p>Oracle's property graph support manages manual and automatic text indexes through integration with Apache Lucene and SolrCloud. At creation time, you must create an <code class="codeph">OracleIndexParameters</code> object specifying the search engine and other configuration settings to be used by the text index. After a text index for property graph is created, these configuration settings cannot be changed. For automatic indexes, all vertex index keys are managed by a single text index, and all edge index keys are managed by a different text index using the configuration specified when the first vertex or edge key is indexed.</p>
<p>If you need to change the configuration settings, you must first disable the current index and create it again using a new <code class="codeph">OracleIndexParameters</code> object. The following code fragment creates two automatic Apache Lucene-based indexes (on vertices and edges) over an existing property graph, disables them, and recreates them to use SolrCloud.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
      args,  szGraphName);
 
String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
 
// Do parallel data loading
OraclePropertyGraphDataLoader opgdl =
OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop);
 
// Create an automatic index using Apache Lucene.
// Specify Index Directory parameters (number of directories,
// number of connections to database, batch size, commit size,
// enable datatypes, location)
OracleIndexParameters luceneIndexParams =
     OracleIndexParameters.buildFS(4, 4, 10000, 50000, true,
             "/home/oracle/text-index ");
 
// Specify indexed keys
String[] indexedKeys = new String[4];
indexedKeys[0] = "name";
indexedKeys[1] = "role";
indexedKeys[2] = "religion";
indexedKeys[3] = "country";
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class, luceneIndexParams.getParameters());
 
// Create auto indexing on weight for all edges
opg.createKeyIndex("weight", Edge.class, luceneIndexParams.getParameters());
 
// Disable auto indexes to change parameters
opg.getOracleIndexManager().disableVertexAutoIndexer();
opg.getOracleIndexManager().disableEdgeAutoIndexer();
 
 
// Recreate text indexes using SolrCloud
// Specify Index Directory parameters: configuration name, Solr Server URL, Solr Node set,
// replication factor, zookeeper timeout (secs),
// maximum number of shards per node,
// number of connections to database, batch size, commit size,
// write timeout (in secs)
String configName = "opgconfig";
String solrServerUrl = "nodea:2181/solr";
String solrNodeSet = "nodea:8983_solr,nodeb:8983_solr," +
   "nodec:8983_solr,noded:8983_solr";
 
int zkTimeout = 15;
int numShards = 4;
int replicationFactor = 1;
int maxShardsPerNode = 1;
 
OracleIndexParameters solrIndexParams =
OracleIndexParameters.buildSolr(configName,
                                solrServerUrl,
                                solrNodeSet,
                                zkTimeout,
                                numShards,
                                replicationFactor,
                                maxShardsPerNode,
                                4,
                                10000,
                                500000,
                                15);
 
// Create auto indexing on above properties for all vertices
opg.createKeyIndex(indexedKeys, Vertex.class, solrIndexParams.getParameters());
 
// Create auto indexing on weight for all edges
opg.createKeyIndex("weight", Edge.class, solrIndexParams.getParameters());
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-C574CB79-D84E-4011-95B1-62A696E0A87C"></a>
<h3 id="BDSPA-GUID-C574CB79-D84E-4011-95B1-62A696E0A87C" class="sect3"><span class="enumeration_section">5.5.8</span> Using Parallel Query on Text Indexes for Property Graph Data</h3>
<div>
<p>Text indexes in Oracle Big Data Spatial and Graph allow executing text queries over millions of vertices and edges by a particular key/value or key/text pair using parallel query execution.</p>
<p>Parallel text querying is an optimized solution taking advantage of the distribution of the data in the index among shards in SolrCloud (or subdirectories in Apache Lucene), so each one is queried using separate index connection. This involves multiple threads and connections to SolrCloud (or Apache Lucene) search engines to increase performance on read operations and retrieve multiple elements from the index. Note that this approach will not rank the matching results based on their score.</p>
<p>Parallel text query will produce an array where each element holds all the vertices (or edges) with an attribute matching the given K/V pair from a shard. The subset of shards queried will be delimited by the given start sub-directory ID and the size of the connections array provided. This way, the subset will consider shards in the range of [start, start - 1 + size of connections array]. Note that an integer ID (in the range of [0, N - 1]) is assigned to all the shards in index with N shards.</p>
<div class="section">
<p class="subhead3"><span class="bold">Parallel Text Query Using Apache Lucene</span></p>
<p>You can use parallel text query using Apache Lucene by calling the method <code class="codeph">getPartitioned</code> in <code class="codeph">LuceneIndex</code>, specifying an array of connections to set of subdirectories (<code class="codeph">SearcherManager</code> objects), the key/value pair to search, and the starting subdirectory ID. Each connection needs to be linked to the appropriate subdirectory, as each subdirectory is independent of the rest of the subdirectories in the index.</p>
<p>The following code fragment generates an automatic text index using the Apache Lucene Search engine, and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">LuceneIndex</code> class is controlled by the total number of subdirectories and the number of connections used.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create an automatic index
OracleIndexParameters indexParams 
= OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name for vertices");
opg.createKeyIndex("name", Vertex.class);

// Get the LuceneIndex object 
SearcherManager[] conns = new SearcherManager[dop];
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);


long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets a connection object from subdirectory split to 
//(split + conns.length)
for (int idx = 0; idx &lt; conns.length; idx++) { 
<span class="bold">conns[idx] = index.getOracleSearcherManager(idx + split);</span> 
}

// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr 
= <span class="bold">index.getPartitioned(conns /* connections */, 
 "name"/* key */, 
 "*" /* value */, 
 true /* wildcards */, 
 split /* start split ID */);
</span>
lCount = countFromIterables(iterAr); /* Consume iterables in parallel */

// Do not close the connections to the subdirectories after completion,
// because those connections are used by the LuceneIndex object itself.
}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parallel Text Search Using SolrCloud</p>
<p>You can use parallel text query using SolrCloud by calling the method <code class="codeph">getPartitioned</code> in <code class="codeph">SolrIndex</code>, specifying an array of connections to SolrCloud (<code class="codeph">CloudSolrServer</code> objects), the key/value pair to search, and the starting shard ID.</p>
<p>The following code fragment generates an automatic text index using the SolrCloud Search engine and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">SolrIndex</code> class is controlled by the total number of shards in the index and the number of connections used.</p>
<pre dir="ltr">
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout /* zookeeper timeout in seconds */,
 numShards /* total number of shards */,
 replicationFactor /* Replication factor */,
 maxShardsPerNode /* maximum number of shardsper node*/,
 4 /* dop used for scan */,
 10000 /* batch size before commit*/,
 500000 /* commit size before SolrCloud commit*/,
 15 /* write timeout in seconds */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name for vertices");
opg.createKeyIndex("name", Vertex.class);

// Get the SolrIndex object 
SearcherManager[] conns = new SearcherManager[dop];
<span class="bold">SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);</span>

// Open an array of connections to handle connections to SolrCloud needed for parallel text search
CloudSolrServer[] conns = new CloudSolrServer[dop];


<span class="bold">for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx] = index.getCloudSolrServer(15 /* write timeout in 
secs*/);
}
</span>
// Iterate to cover all the shards in the index
long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr = <span class="bold">index.getPartitioned(conns /* connections */, 
 "name"/* key */, 
 "*" /* value */, 
 true /* wildcards */, 
 split /* start split ID */);</span>

lCount = countFromIterables(iterAr); /* Consume iterables in parallel */
}

// Close the connections to the subdirectories after completed
for (int idx = 0; idx &lt; conns.length; idx++) { 
conns[idx].shutdown();
} 

// Count results
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" --></div>
</div>
<div class="props_rev_3"><a id="GUID-E64FB9A9-B342-4C8E-AC05-5CF649E3B71A"></a>
<h3 id="BDSPA-GUID-E64FB9A9-B342-4C8E-AC05-5CF649E3B71A" class="sect3"><span class="enumeration_section">5.5.9</span> Using Native Query Objects on Text Indexes for Property Graph Data</h3>
<div>
<p>Using Query objects directly is for advanced users, enabling them to take full advantage of the underlying query capabilities of the text search engine (Apache Lucene or SolrCloud). For example, you can add constraints to text searches, such as adding a boost to the matching scores and adding sorting clauses.</p>
<p>Using text searches with Query objects will produce an Iterable object holding all the vertices (or edges) with an attribute (or set of attributes) matching the text query while satisfying the constraints. This approach will automatically rank the results based on their matching score.</p>
<p>To build the clauses in the query body, you may need to consider the data type used by the key/value pair to be matched, as well as the configuration of the search engine used. For more information about building a search term, see <a href="using-property-graphs-big-data.htm#GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969">Handling Data Types</a>.</p>
<div class="section">
<p class="subhead3"><span class="bold">Using Native Query Objects with Apache Lucene</span></p>
<p>You can use native query objects using Apache Lucene by calling the method <code class="codeph">get(Query)</code> in <code class="codeph">LuceneIndex</code>. You can also use parallel text query with native query objects by calling the method <code class="codeph">getPartitioned(SearcherManager[], Query, int)</code> in <code class="codeph">LuceneIndex</code> specifying an array of connections to a set of subdirectories (<code class="codeph">SearcherManager</code> objects), the Lucene query object, and the starting subdirectory ID. Each connection must be linked to the appropriate subdirectory, because each subdirectory is independent of the rest of the subdirectories in the index.</p>
<p>The following code fragment generates an automatic text index using Apache Lucene Search engine, creates a Lucene Query, and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">LuceneIndex</code> class is controlled by the total number of subdirectories and the number of connections used.</p>
<pre dir="ltr">
import oracle.pg.text.lucene.LuceneIndex;
import org.apache.lucene.search.*;
import org.apache.lucene.index.*;

...

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

// Create an automatic index
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name and country properties for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the LuceneIndex object 
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
Term term = index.buildSearchTermObject("name", "Beyo*", String.class);
Query queryBey = new WildcardQuery(term);

// Add another condition to query all the vertices whose country is 
//"United States"
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

Query queryCountry = new PhraseQuery();
StringTokenizer st = new StringTokenizer(value);
while (st.hasMoreTokens()) {
  queryCountry.add(new Term(key, st.nextToken()));
};

//Concatenate queries
BooleanQuery bQuery = new BooleanQuery();
bQuery.add(queryBey, BooleanClause.Occur.MUST);
bQuery.add(queryCountry, BooleanClause.Occur.MUST);

long lCount = 0;
SearcherManager[] conns = new SearcherManager[dop];
for (int split = 0; split &lt; index.getTotalShards(); split += conns.length) {
  // Gets a connection object from subdirectory split to 
  //(split + conns.length). Skip the cache so we clone the connection and
  // avoid using the connection used by the index.
  for (int idx = 0; idx &lt; conns.length; idx++) { 
    conns[idx] = index.getOracleSearcherManager(idx + split, 
                                      true /* skip looking in the cache*/                 
); 
  }

  // Gets elements from split to split + conns.length
  Iterable&lt;Vertex&gt;[] iterAr = index.getPartitioned(conns /* connections */, 
                                                   bQuery,  
                                                   split /* start split ID */);

  lCount = countFromIterables(iterAr); /* Consume iterables in parallel */

  // Do not close the connections to the sub-directories after completed,
  // as those connections are used by the index itself

}

// Count all vertices
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Using Native Query Objects withSolrCloud</p>
<p>You can directly use native query objects against SolrCloud by calling the method <code class="codeph">get(SolrQuery)</code> in <code class="codeph">SolrIndex</code>. You can also use parallel text query with native query objects by calling the method <code class="codeph">getPartitioned(CloudSolrServer[],SolrQuery,int)</code> in <code class="codeph">SolrIndex</code> specifying an array of connections to SolrCloud (<code class="codeph">CloudSolrServer</code> objects), the <code class="codeph">SolrQuery</code> object, and the starting shard ID.</p>
<p>The following code fragment generates an automatic text index using the Apache SolrCloud Search engine, creates a <code class="codeph">SolrQuery</code> object, and executes a parallel text query. The number of calls to the <code class="codeph">getPartitioned</code> method in the <code class="codeph">SolrIndex</code> class is controlled by the total number of subdirectories and the number of connections used.</p>
<pre dir="ltr">
import oracle.pg.text.solr.*;
import org.apache.solr.client.solrj.*;

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 args, szGraphName);

// Clear existing vertices/edges in the property graph 
opg.clearRepository(); 

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// This object will handle parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop); 

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout          /* zookeeper timeout in seconds */,
 numShards          /* total number of shards */,
 replicationFactor  /* Replication factor */,
 maxShardsPerNode   /* maximum number of shardsper node*/,
 4                  /* dop used for scan */,
 10000              /* batch size before commit*/,
 500000             /* commit size before SolrCloud commit*/,
 15                 /* write timeout in seconds */
);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the SolrIndex object 
SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
String szQueryStrBey = index.buildSearchTerm("name", "Beyo*", String.class);
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

String szQueryStrCountry = key + ":" + value;
Solrquery query = new SolrQuery(szQueryStrBey + " AND " + szQueryStrCountry);

//Query using get operation
index.get(query);

// Open an array of connections to handle connections to SolrCloud needed 
// for parallel text search
CloudSolrServer[] conns = new CloudSolrServer[dop];

for (int idx = 0; idx &lt; conns.length; idx++) {
conns[idx] = index.getCloudSolrServer(15 /* write timeout in 
secs*/);
}

// Iterate to cover all the shards in the index
long lCount = 0;
for (int split = 0; split &lt; index.getTotalShards(); 
 split += conns.length) {
// Gets elements from split to split + conns.length
Iterable&lt;Vertex&gt;[] iterAr = index.getPartitioned(conns /* connections */, 
 query, 
 split /* start split ID */);

lCount = countFromIterables(iterAr); /* Consume iterables in parallel */
}

// Close the connections to SolCloud after completion
for (int idx = 0; idx &lt; conns.length; idx++) { 
  conns[idx].shutdown();
}

// Count results
System.out.println("Vertices found using parallel query: " + lCount);
</pre></div>
<!-- class="section" --></div>
</div>
<div class="props_rev_3"><a id="GUID-D5A410DB-7B39-4E62-AB87-709EB71D1BF0"></a>
<h3 id="BDSPA-GUID-D5A410DB-7B39-4E62-AB87-709EB71D1BF0" class="sect3"><span class="enumeration_section">5.5.10</span> Using Native Query Results on Text Indexes for Property Graph Data</h3>
<div>
<p>Using native query results directly into property graph data enables users to take full advantage of the querying capabilities of the text search engine (Apache Lucene or SolrCloud). This way, users can execute different type of queries (like Faceted queries) on the text engine and parse the retrieved results into vertices (or edges) objects.</p>
<p>Using text searches with Query results will produce an <code class="codeph">Iterable</code> object holding all the vertices (or edges) from the given result object. This approach will automatically rank the results based on their result set order.</p>
<p>To execute the search queries directly into Apache Lucene or SolrCloud index, you may need to consider the data type used by the key/value pair to be matched, as well as the configuration of the search engine used. For more information about building a search term, see <a href="using-property-graphs-big-data.htm#GUID-9FAEC54C-52D2-4656-8E2A-5F4CFC34F969">Handling Data Types</a>.</p>
<ul style="list-style-type: disc;">
<li>
<p>Using Native Query Results with Apache Lucene</p>
</li>
<li>
<p>Using Native Query Results with SolrCloud</p>
</li>
</ul>
<div class="section">
<p class="subhead3">Using Native Query Results with Apache Lucene</p>
<p>You can use native query results using Apache Lucene by calling the method&nbsp;<code class="codeph">get(TopDocs)</code>&nbsp;in&nbsp;<code class="codeph">LuceneIndex</code>. A <code class="codeph">TopDocs</code> object provides a set of Documents matching a text search query over a specific Apache Lucene directory. <code class="codeph">LuceneIndex</code> will produce an <code class="codeph">Iterable</code> object holding all the vertices (or edges) from the documents found in the <code class="codeph">TopDocs</code> object.</p>
<p>Oracle property graph text indexes using Apache Lucene are created using multiple Apache Lucene directories. Indexed vertices and edges are spread among the directories to enhance storage scalability and query performance. If you need to execute a query against all the data in the property graph&rsquo;s text index, execute the query against each Apache Lucene directory. You can easily get the <code class="codeph">IndexSearcher</code> object associated to a directory by using the API <code class="codeph">getOracleSearcher in LuceneIndex</code>.</p>
<p>The following code fragment generates an automatic text index using the Apache Lucene Search engine, creates a Lucene Query and executes it against an <code class="codeph">IndexSearcher</code> object to get a <code class="codeph">TopDocs</code> object. Later, an <code class="codeph">Iterable</code> object of vertices is created from the given result object.</p>
<pre dir="ltr">
import oracle.pg.text.lucene.LuceneIndex;
import org.apache.lucene.search.*;
import org.apache.lucene.index.*;

...

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 &hellip;);

// Create an automatic index
OracleIndexParameters indexParams = OracleIndexParameters.buildFS(dop /* number of directories */,
dop /* number of connections
used when indexing */,
10000 /* batch size before commit*/,
500000 /* commit size before Lucene commit*/,
true /* enable datatypes */,
"./lucene-index" /* index location */);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name and country properties for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the LuceneIndex object 
LuceneIndex&lt;Vertex&gt; index = (LuceneIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
Term term = index.buildSearchTermObject("name", "Beyo*", String.class);
Query queryBey = new WildcardQuery(term);

// Add another condition to query all the vertices whose country is 
//"United States"
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

Query queryCountry = new PhraseQuery();
StringTokenizer st = new StringTokenizer(value);
while (st.hasMoreTokens()) {
  queryCountry.add(new Term(key, st.nextToken()));
};

//Concatenate queries
BooleanQuery bQuery = new BooleanQuery();
bQuery.add(queryBey, BooleanClause.Occur.MUST);
bQuery.add(queryCountry, BooleanClause.Occur.MUST);


// Get the IndexSearcher object needed to execute the query. 
// The index searcher object is mapped to a single Apache Lucene directory
<span class="bold">SearcherManager searcherMgr = 
         index.getOracleSearcherManager(0, true /* skip looking in the cache*/); 
IndexSearcher indexSearcher = searcherMgr.acquire();
// search for the first 1000 results in the current index directory 0
TopDocs docs = index.search(bQuery, 1000); 

long lCount = 0;
Iterable&lt;Vertex&gt; it = index.get(docs);
</span>
while (it.hasNext()) {
  System.out.println(it.next());
  lCount++;
}
System.out.println("Vertices found: "+ lCount);
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Using Native Query Results with SolrCloud</p>
<p>You can use native query results using SolrCloud by calling the method&nbsp;<code class="codeph">get(QueryResponse)</code>&nbsp;in&nbsp;<code class="codeph">SolrIndex</code>. A <code class="codeph">QueryResponse</code> object provides a set of Documents matching a text search query over a specific <code class="codeph">SolrCloud</code> collection. <code class="codeph">SolrIndex</code> will produce an <code class="codeph">Iterable</code> object holding all the vertices (or edges) from the documents found in the <code class="codeph">QueryResponse</code> object.</p>
<p>The following code fragment generates an automatic text index using the Apache SolrCloud Search engine, creates a&nbsp;<code class="codeph">SolrQuery</code>&nbsp;object, and executes it against a <code class="codeph">CloudSolrServer</code> object to get a <code class="codeph">QueryResponse</code> object. Later, an <code class="codeph">Iterable</code> object of vertices is created from the given result object.</p>
<pre dir="ltr">
import oracle.pg.text.solr.*;
import org.apache.solr.client.solrj.*;

OraclePropertyGraph opg = OraclePropertyGraph.getInstance(
 &hellip;);

String configName = "opgconfig";
String solrServerUrl = args[4];//"localhost:2181/solr"
String solrNodeSet = args[5]; //"localhost:8983_solr";
 
int zkTimeout = 15; // zookeeper timeout in seconds
int numShards = Integer.parseInt(args[6]); // number of shards in the index
int replicationFactor = 1; // replication factor
int maxShardsPerNode = 1; // maximum number of shards per node
 
// Create an automatic index using SolrCloud
OracleIndexParameters indexParams = 
 OracleIndexParameters.buildSolr(configName, 
 solrServerUrl, 
 solrNodeSet, 
 zkTimeout          /* zookeeper timeout in seconds */,
 numShards          /* total number of shards */,
 replicationFactor  /* Replication factor */,
 maxShardsPerNode   /* maximum number of shardsper node*/,
 4                  /* dop used for scan */,
 10000              /* batch size before commit*/,
 500000             /* commit size before SolrCloud commit*/,
 15                 /* write timeout in seconds */
);

opg.setDefaultIndexParameters(indexParams);

// Create auto indexing on name property for all vertices
System.out.println("Create automatic index on name and country for vertices");
String[] indexedKeys = new String[2];
indexedKeys[0]="name";
indexedKeys[1]="country";
opg.createKeyIndex(indexedKeys, Vertex.class);

// Get the SolrIndex object 
SolrIndex&lt;Vertex&gt; index = (SolrIndex&lt;Vertex&gt;) opg.getAutoIndex(Vertex.class);

// Search first for Key name with property value Beyon* using only string 
//data types
String szQueryStrBey = index.buildSearchTerm("name", "Beyo*", String.class);
String key = index.appendDatatypesSuffixToKey("country", String.class);
String value = index.appendDatatypesSuffixToValue("United States", String.class);

String szQueryStrCountry = key + ":" + value;
Solrquery query = new SolrQuery(szQueryStrBey + " AND " + szQueryStrCountry);

<span class="bold">CloudSolrServer conn = index.getCloudSolrServer(15 /* write timeout in 
secs*/);

//Query using get operation
QueryResponse qr = conn.query(query, SolrRequest.METHOD.POST);
Iterable&lt;Vertex&gt; it = index.get(qr);
</span>
long lCount = 0;

while (it.hasNext()) {
  System.out.println(it.next());
  lCount++;
}

System.out.println("Vertices found: "+ lCount);
</pre></div>
<!-- class="section" --></div>
</div>
</div>
<div class="props_rev_3"><a id="GUID-25432BC8-B8EA-494E-8A6A-5C19ECD6760F"></a>
<h2 id="BDSPA-GUID-25432BC8-B8EA-494E-8A6A-5C19ECD6760F" class="sect2"><span class="enumeration_section">5.6</span> Querying Property Graph Data Using PGQL</h2>
<div>
<p>Oracle Big Data Spatial and Graph supports a rich set of graph pattern matching capabilities.</p>
<p>It provides a SQL-like declarative language called <span class="bold">PGQL</span> (Property Graph Query Language), which allows you to express a graph query pattern that consists of vertices and edges, and constraints on the properties of the vertices and edges. For detailed information, see the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>PGQL specification: <a href="https://docs.oracle.com/cd/E56133_01/latest/reference/pgql-specification.html" target="_blank">https://docs.oracle.com/cd/E56133_01/latest/reference/pgql-specification.html</a></p>
</li>
</ul>
<p>An example property graph query is as follows. It defines a graph pattern inspired by the famous ancient proverb: <span class="italic">The enemy of my enemy is my friend</span>. In this example, variables <code class="codeph">x</code>, <code class="codeph">y</code>, <code class="codeph">z</code> are used for vertices, and variables <code class="codeph">e1</code>, <code class="codeph">e2</code> are used for edges. There is a constraint on the edge label, and the query returns (projects) the value of the <code class="codeph">name</code> property of vertices <code class="codeph">x</code> and <code class="codeph">y</code>.</p>
<pre dir="ltr">
SELECT x.name, z.name
WHERE
  x -[e1:'feuds']-&gt; y,
  y -[e2:'feuds']-&gt; z
</pre>
<p>For the preceding query to run successfully, set the required flags to read the edge labels, in addition to vertex/edge properties, when constructing the in-memory graph. An example graph configuration for Oracle NoSQL Database is as follows:</p>
<pre dir="ltr">
cfg = GraphConfigBuilder.setName(...) <span class="bold">.hasEdgeLabel(true).setLoadEdgeLabel(true)</span> .addEdgeProperty(...).build();
</pre>
<p>You can run the query either in a Groovy shell environment or from Java. For example, to run the preceding query from the Groovy shell for Apache HBase or Oracle NoSQL Database, you can first read the graph from the database into the in-memory analyst, get an in-memory graph, and invoke the <code class="codeph">queryPgql</code> function.</p>
<pre dir="ltr">
// Read graph data from a backend database into memory
// Note that opg is an instance of OraclePropertyGraph class
opg-hbase&gt; G = session.readGraphWithProperties(<span class="bold">opg.getConfig()</span>);
opg-hbase&gt; 

resultSet = G.<span class="bold">queryPgql</span>("SELECT x.name, z.name WHERE x -[e1 WITH label = 'feuds']-&gt; y,  y -[e2 WITH label = 'feuds']-&gt; z")
</pre>
<p>To get the type and variable name of the first projected variable in the result set, you can enter the following:</p>
<pre dir="ltr">
opg-hbase&gt; resultElement = resultElements.get(0)
opg-hbase&gt; type = resultElement.getElementType() // STRING
opg-hbase&gt; varName = resultElement.getVarName() // x.name
</pre>
<p>You can also iterate over the result set. For example:</p>
<pre dir="ltr">
opg-hbase&gt; resultSet.getResults().each { \
       // the variable 'it' is implicitly declared to references each PgqlResult instance
     }
</pre>
<p>Finally, you can display (print) results. For example, to display the first 10 rows:</p>
<pre dir="ltr">
opg-hbase&gt; resultSet.print(10) // print the first 10 results
</pre>
<div class="infoboxnotealso" id="GUID-25432BC8-B8EA-494E-8A6A-5C19ECD6760F__GUID-3B1A6C2A-FF4C-401A-9814-496A2A91BC90">
<p class="notep1">See Also:</p>
<p><a href="using-in-memory-analyst.htm#GUID-96D9C0AA-CE52-48E6-A09E-D97E872A79A1" title="You can issue a pattern-matching query against an in-memory graph, and then work with the results of that query.">Using Pattern-Matching Queries with Graphs</a> for examples of using PGQL to issue pattern-matching queries against in-memory graphs</p>
</div>
</div>
</div>
<div class="props_rev_3"><a id="GUID-EFECEBBB-6BD6-4A63-B962-DB5AD7EB4C03"></a>
<h2 id="BDSPA-GUID-EFECEBBB-6BD6-4A63-B962-DB5AD7EB4C03" class="sect2"><span class="enumeration_section">5.7</span> Using Apache Spark with Property Graph Data</h2>
<div>
<p>Apache Spark lets you process large amounts of data efficiently, and it comes with a set of libraries for processing data:&nbsp;SQL,&nbsp;MLlib, Spark Streaming, and&nbsp;DataFrames, Apache Spark can read data from different sources, such as HDFS, Oracle NoSQL Database, and Apache HBase.</p>
<p>A set of helper methods is provided for running Apache Spark jobs against graph data stored in Oracle NoSQL Database or Apache HBase. This way, you can easily load a graph into an Apache Spark-based application in order to query the information using Spark SQL or to run functions provided in MLlib.</p>
<p>The interface <code class="codeph">SparkUtilsBase</code> provides a set of methods to gather all the information of a vertex (or edge) stored in the vertex and edge tables. This information includes a vertex (or edge) identifier, its property names and values, as well as label, incoming and outgoing vertices for edges only. <code class="codeph">SparkUtils</code> uses Spark version 1.6 (included in CDH 5.7 and 5.9).</p>
<p><code class="codeph">SparkUtilsBase</code> includes the following methods to transform the data from the backend tables into graph information:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">getGraphElementReprOnDB(dbObj)</code>: Obtains the database representation of a vertex (or an edge) stored in a backend database.</p>
</li>
<li>
<p><code class="codeph">getElementID(Object graphElementReprOnDB)</code>: Obtains the graph element (vertex or edge) ID.</p>
</li>
<li>
<p><code class="codeph">getPropertyValue(Object graphElementReprOnDB, String key)</code>: Gets the property value of a graph element for a given property key.</p>
</li>
<li>
<p><code class="codeph">getPropertyNames(Object graphElementReprOnDB)</code>: Returns the set of property names from a given graph element representation from the back-end database.</p>
</li>
<li>
<p><code class="codeph">isElementForVertex(Object graphElementReprOnDB)</code>: Verifies if the given graph element object obtained from a database result is a representation of a vertex.</p>
</li>
<li>
<p><code class="codeph">isElementForEdge(Object graphElementReprOnDB)</code>: Verifies if the given graph element object obtained from a database result is a representation of a vertex.</p>
</li>
<li>
<p><code class="codeph">getInVertexID(Object graphElementReprOnDB)</code>: Obtains the incoming vertex ID from database representation of an edge.</p>
</li>
<li>
<p><code class="codeph">getOutVertexID(Object graphElementReprOnDB)</code>: Obtains the outgoing vertex ID from database representation of an edge.</p>
</li>
<li>
<p><code class="codeph">getEdgeLabel(Object graphElementReprOnDB)</code>: Obtains the edge label from database representation of an edge.</p>
</li>
</ul>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-B3E02E68-8C7B-4DFC-BA26-E2F0CD4C42AE">Using Apache Spark with Property Graph Data in Apache HBase</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-CFD8B97A-B9C3-48C1-A1DB-4E3D42441B1B">Integrating Apache Spark with Property Graph Data Stored in Oracle NoSQL Database</a><br /></li>
</ul>
</div>
<div class="props_rev_3"><a id="GUID-B3E02E68-8C7B-4DFC-BA26-E2F0CD4C42AE"></a>
<h3 id="BDSPA-GUID-B3E02E68-8C7B-4DFC-BA26-E2F0CD4C42AE" class="sect3"><span class="enumeration_section">5.7.1</span> Using Apache Spark with Property Graph Data in Apache HBase</h3>
<div>
<p>The <code class="codeph">oracle.pg.hbase.SparkUtils</code> class includes methods to gather the information about a vertex (or an edge) represented as a row in the &lt;graph_name&gt;<span class="bold">VT.</span> (or &lt;graph_name&gt;<span class="bold">GE.</span>) tables stored in Apache HBase. In Apache HBase, when scanning a table, each row has a corresponding <code class="codeph">org.apache.hadoop.hbase.client.Result</code> object.</p>
<p>To use <code class="codeph">SparkUtils</code> to run an Apache Spark job against a property graph, you must first load the graph data into two Apache Spark RDD objects. This requires you to create <code class="codeph">sc</code>, a Spark context of your application. The following example creates a Spark context object:</p>
<pre dir="ltr">
import org.apache.spark.SparkContext.*;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import oracle.pg.hbase.SparkUtils; 
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.io.ImmutableBytesWritable;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.mapreduce.TableInputFormat;
import org.apache.hadoop.conf.Configuration;

SparkContext sc = new SparkContext(new SparkConf().setAppName("Example")
                                                  .setMaster("spark://localhost:7077"));
</pre>
<p>Using this context, you can easily get an RDD out of a Hadoop file by invoking the <code class="codeph">newAPIHadoopRDD</code> method.&nbsp;To do so, you must first create the&nbsp;Hadoop Configuration objects to access the vertices and edges tables stored in Apache HBase. A Configuration&nbsp;object specifies the parameters used to connect to Apache HBase, such as the Zookeeper quorum, Zookeper Client port, and table name. This Configuration object is used by the&nbsp;<code class="codeph">newAPIHadoopRDD</code> together with the <code class="codeph">InputFormat</code> and the classes of its keys and values. The result of this method will be an RDD of type <code class="codeph">RDD[(ImmutableBytesWritable, Result)]</code>.</p>
<p>The following example creates a Configuration object to connect to Apache HBase and read the vertex table of the graph. Assume that <code class="codeph">socialNetVT.</code> is the name of the Apache HBase table containing information about the vertices of a graph. Later you will use this configuration to get an RDD from the vertex table:</p>
<pre dir="ltr">
Configuration hBaseConfVertices = HBaseConfiguration.create();
hBaseConfVertices.set(TableInputFormat.INPUT_TABLE, "socialNetVT.")
hBaseConfVertices.set("hbase.zookeeper.quorum", "node041,node042,node043")
hBaseConfVertices.set("hbase.zookeeper.port", "2181")

JavaPairRDD&lt;ImmutableBytesWritable,Result&gt; bytesResultVertices = 
sc.newAPIHadoopRDD(hBaseConfVertices, 
                   TableInputFormat.class,
                   ImmutableBytesWritable.class, 
                    Result.class)
</pre>
<p>Similarly, the following example creates a Configuration object to connect to the edge table stored in Apache HBase and get an RDD for the table's rows. Note that socialNetGE. is the name of the table containing the edges definition.</p>
<pre dir="ltr">
Configuration hBaseConfEdges = HBaseConfiguration.create();
hBaseConfEdges.set(TableInputFormat.INPUT_TABLE, "socialNetGE.")
hBaseConfEdges.set("hbase.zookeeper.quorum", "node041,node042,node043")
hBaseConfEdges.set("hbase.zookeeper.port", "2181")

JavaPairRDD&lt;ImmutableBytesWritable,Result&gt; bytesResultEdges = 
sc.newAPIHadoopRDD(hbaseConfEdges, 
                   TableInputFormat.class,
                   ImmutableBytesWritable.class,
                   Result.class)
</pre>
<p>Each Result object contains the attributes of each node and edge of graph, so you must apply some transformation to these RDDs in order to extract that information. <code class="codeph">oracle.pg.hbase.SparkUtils</code> implements several methods that help you define such transformations.</p>
<p>For example, you can define transformations&nbsp;extracting each vertex attribute value from a Result object to create an object instance of <code class="codeph">MyVertex</code>, a Java bean class storing ID and name of a vertex. The following example defines method <code class="codeph">res2vertex</code> that uses <code class="codeph">SparkUtils</code> for extracting the identifier and name key/value pairs from a given Result object representing a vertex.</p>
<pre dir="ltr">
public static MyVertex res2vertex(Result res) throws Exception
{
SparkUtils su = SparkUtils.getInstance();
        Object dbRepr = su.getGraphElementReprOnDB(res);
        long id = su.getElementId(dbRepr);
        String name = (String)su.getPropertyValue(dbRepr, "name");
        return new MyVertex(id,name);
}
</pre>
<p>The method <code class="codeph">getGraphElemetReprOnDB</code> returns a graph element representation stored in Apache HBase and throws an <code class="codeph">IllegalArgumentException</code> exception if its parameter is null or a non-instance of corresponding class. This representation is database specific (available only on Apache HBase) and the return value should only be consumed by other APIs defined in the interface. For the case of Apache HBase, <code class="codeph">dbRepr</code> is a non-null instance of <code class="codeph">Result</code> class. Once you have a database representation object, you can pass it as a parameter of any of the other methods defined in the interface.</p>
<p>The method <code class="codeph">getElementId</code> returns the ID of a vertex and method <code class="codeph">getPropertyValue</code> retrieves attribute value <code class="codeph">name</code> from object <code class="codeph">dbRepr.</code>. Exceptions <code class="codeph">IOException</code> and <code class="codeph">java.text.ParseException</code> are thrown if incorrect parameters are passed in.</p>
<p>The following example defines a method <code class="codeph">res2edge</code> that uses <code class="codeph">SparkUtils</code> to extract the identifier, label, and incoming/outgoing vertices from a given Result object representing an edge.</p>
<pre dir="ltr">
public static MyEdge res2Edge( Result res) throws Exception
{
SparkUtils su = SparkUtils.getInstance();
        Object dbRepr = su.getGraphElementReprOnDB(res);
        long rowId    = su.getElementId(dbRepr);
        String label  = (String)su.getEdgeLabel(dbRepr);
        long inVertex = (long)su.getInVertexId(dbRepr);
        long outVertex = (long)su.getOutVertexId(dbRepr);
        return new MyEdge(rowId,inVertex,outVertex,label);
}
</pre>
<p>Once you have these transformations, you can map them on the values set of <code class="codeph">bytesResultVertices</code> and <code class="codeph">bytesResultEdges</code>. For example:</p>
<pre dir="ltr">
JavaRDD&lt;Result&gt; resultVerticesRDD = bytesResult.values();
JavaRDD&lt;Vertex&gt; nodesRDD = resultVerticesRDD.map(result -&gt;  MyConverters.res2vertex(result));
JavaRDD&lt;Result&gt; resultEdgesRDD = bytesResultEdges.values();
JavaRDD&lt;Edge&gt; edgesRDD = resultEdgesRDD.map(result -&gt; MyConverters.res2Edge(result));
</pre>
<p>In your Spark application, you can then start working on nodesRDD and edgesRDD. For example, you can create corresponding data frames to execute a Spark SQL query. The following example creates a SQL Context, gets two data frames from the nodesRDD and edgesRDD, and runs a query to get all friends of a vertex with ID 1:</p>
<pre dir="ltr">
SQLContext sqlCtx = new SQLContext(sc);
DataFrame verticesDF = sqlCtx.createDataFrame(verticesRDD);
verticesDF.registerTempTable("VERTICES_TABLE");

DataFrame edgesDF = sqlCtx.createDataFrame(edgesRDD);
edgesDF.registerTempTable("EDGES_TABLE");

sqlCtx.sql("select name from (select target from EDGES_TABLE WHERE source = 1) REACHABLE
left join VERTICES_TABLE on VERTICES_TABLE.id = REACHABLE.target ").show();
</pre>
<p id="GUID-B3E02E68-8C7B-4DFC-BA26-E2F0CD4C42AE___GOBACK-78D3C0AB">Note that case classes <code class="codeph">MyVertex</code> and <code class="codeph">MyEdge</code> play an important role here because Spark uses them to find the data frame&rsquo;s column names.</p>
<p>In addition to reading out graph data directly from Apache HBase and performing operations on the graph in Apache Spark, you can use the in-memory analyst to analyze graph data in Apache Spark, as explained in <a href="using-in-memory-analyst.htm#GUID-286D11B2-5A66-4072-808D-8FA569DDCC4A" title="The property graph feature in Oracle Big Data Spatial and Graph enables integration of in-memory analytics and Apache Spark.">Using the In-Memory Analyst to Analyze Graph Data in Apache Spark</a>.</p>
</div>
</div>
<div class="props_rev_3"><a id="GUID-CFD8B97A-B9C3-48C1-A1DB-4E3D42441B1B"></a>
<h3 id="BDSPA-GUID-CFD8B97A-B9C3-48C1-A1DB-4E3D42441B1B" class="sect3"><span class="enumeration_section">5.7.2</span> Integrating Apache Spark with Property Graph Data Stored in Oracle NoSQL Database</h3>
<div>
<p>The <code class="codeph">oracle.pg.nosql.SparkUtils</code> class includes methods to gather the information of a vertex (or an edge) represented as a row in the &lt;graph_name&gt;<span class="bold">VT_</span> (or &lt;graph_name&gt;<span class="bold">GE_</span>) tables stored in Oracle NoSQL Database. In Oracle NoSQL Database, when a table is scanned, each row in the table has a corresponding oracle.kv.table.Row object.</p>
<p>To use <code class="codeph">SparkUtils</code> to run an Apache Spark job against a property graph, you must first load the graph data into two Apache Spark RDD objects. This requires you to create <code class="codeph">sc</code>, a Spark context of your application. The following example describes how to create a Spark context object:</p>
<pre dir="ltr">
import java.io.*;
import org.apache.spark.SparkContext.*;
import org.apache.spark.sql.SQLContext;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaPairRDD;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.sql.DataFrame;
import oracle.kv.hadoop.table.TableInputFormat;
import oracle.kv.table.PrimaryKey;
import oracle.kv.table.Row;
import org.apache.hadoop.conf.Configuration;

SparkConf sparkConf = new SparkConf().setAppName("Testing SparkUtils").setMaster(&ldquo;local&rdquo;);
                        
JavaSparkContext sc = new JavaSparkContext(sparkConf);  
</pre>
<p>Using this context, you can easily get an RDD out of a Hadoop file by invoking the <code class="codeph">newAPIHadoopRDD</code> method.&nbsp;To create RDDs, you must first create the&nbsp;Hadoop Configuration objects to access the vertices and edges tables stored in Oracle NoSQL Database. This Configuration object is used by the&nbsp;<code class="codeph">newAPIHadoopRDD</code> together with the <code class="codeph">InputFormat</code> and the classes of its keys and values. The result of this method will be an RDD of type <code class="codeph">RDD[(PrimaryKey, Row)]</code>.</p>
<p>The following example creates a Configuration object to connect to Oracle NoSQL Database and read the vertex table of the graph. Assume that <code class="codeph">socialNetVT_</code> is the name of the table containing the vertices information of a graph. Later, you will use this configuration to get an RDD from the vertex table.</p>
<pre dir="ltr">
   Configuration noSQLNodeConf = new Configuration();
   noSQLNodeConf.set("oracle.kv.kvstore", "kvstore");
   noSQLNodeConf.set("oracle.kv.tableName", &ldquo;socialNetVT_&rdquo;);
   noSQLNodeConf.set("oracle.kv.hosts", "localhost:5000");
</pre>
<p>Similarly, the following example creates a Configuration object to connect to the edge table stored in Oracle NoSQL Database and get an RDD for the table's rows. Note that <code class="codeph">socialNetGE_</code> is the name of the table containing the edges data.</p>
<pre dir="ltr">
  Configuration noSQLEdgeConf = new Configuration();
  noSQLEdgeConf.set("oracle.kv.kvstore", "kvstore");
  noSQLEdgeConf.set("oracle.kv.tableName", &ldquo;socialNetGE_&rdquo;);
  noSQLEdgeConf.set("oracle.kv.hosts", "localhost:5000"); 

JavaPairRDD&lt;PrimaryKey,Row&gt; bytesResultVertices = sc.newAPIHadoopRDD(noSQLNodeConf,
            oracle.kv.hadoop.table.TableInputFormat.class,PrimaryKey.class, Row.class);
                                                                               
JavaPairRDD&lt;PrimaryKey,Row&gt; bytesResultEdges = sc.newAPIHadoopRDD(noSQLEdgeConf,
            oracle.kv.hadoop.table.TableInputFormat.class,
            PrimaryKey.class, Row.class);
</pre>
<p>Because a Row object may contain one or multiple attributes of a vertex or an edge of the graph, you must apply some transformations to these RDDs in order to get the relevant information out. <code class="codeph">oracle.pg.nosql.SparkUtils</code> implements several methods that help you define such transformations.</p>
<p>For example, you can define a transformation&nbsp;that extracts vertex property values from a Result object and creates an object instance of <code class="codeph">MyVertex</code>, a Java bean class storing the ID and name of a vertex. The following example defines the method <code class="codeph">res2vertex</code> that uses <code class="codeph">SparkUtils</code> for extracting the identifier and name key/value pairs from a given Row object representing a vertex.</p>
<pre dir="ltr">
public static MyVertex res2vertex(Row res) throws Exception
{
        SparkUtils su = SparkUtils.getInstance();
        Object dbRepr = su.getGraphElementReprOnDB(res);
        long id = su.getElementId(dbRepr);
        String name = (String)su.getPropertyValue(dbRepr, "name");
        return new MyVertex(id,name);
}
</pre>
<p>The method <code class="codeph">getGraphElemetReprOnDB</code> returns a graph element representation stored in Oracle NoSQL Database and throws an <code class="codeph">IllegalArgumentException</code> exception in case its parameter is null or a non-instance of a corresponding class. This representation is database-specific, and the return value should only be consumed by other APIs defined in the interface. For Oracle NoSQL Database, <code class="codeph">dbRepr</code> is a non-null instance of the <code class="codeph">Row</code> class. After you have a database representation object, you can pass it as a parameter of any of the other methods defined in the interface.</p>
<p>The method <code class="codeph">getElementId</code> returns the ID of a vertex, and the method <code class="codeph">getPropertyValue</code> retrieves attribute value &ldquo;name&rdquo; from object <code class="codeph">dbRepr</code>. Exceptions <code class="codeph">IOException</code> and <code class="codeph">java.text.ParseException</code> are thrown when incorrect parameters are passed in.</p>
<p>Similarly, you can define a transformation to create an object instance of <code class="codeph">MyEdge</code> from a Row object, using a Java bean class that stores the ID, label, and incoming/outgoing vertices ID values. The following example defines a method <code class="codeph">res2edge</code> that uses <code class="codeph">SparkUtils</code> to extract the identifier, label and in/out vertex IDs from a given Row object representing an edge.</p>
<pre dir="ltr">
public static MyEdge res2Edge( Row res) throws Exception
{
        SparkUtils su = SparkUtils.getInstance();
        Object dbRepr = su.getGraphElementReprOnDB(res);
        long rowId    = su.getElementId(dbRepr);
        String label  = (String)su.getEdgeLabel(dbRepr);
        long inVertex = (long)su.getInVertexId(dbRepr);
        long outVertex = (long)su.getOutVertexId(dbRepr);
        return new MyEdge(rowId,inVertex,outVertex,label);
}
</pre>
<p>After you have these transformations, you can map them on the values set of <code class="codeph">bytesResultVertices</code> and <code class="codeph">bytesResultEdges</code>:</p>
<pre dir="ltr">
JavaRDD&lt;Row&gt; resultVerticesRDD = bytesResult.values();
JavaRDD&lt;Vertex&gt; nodesRDD = resultVerticesRDD.map(result -&gt;  MyConverters.res2vertex(result));
JavaRDD&lt;Row&gt; resultEdgesRDD = bytesResultEdges.values();
JavaRDD&lt;Edge&gt; edgesRDD = resultEdgesRDD.map(result -&gt; MyConverters.res2Edge(result));
</pre>
<p>After the preceding steps, you can start working on <code class="codeph">nodesRDD</code> and <code class="codeph">edgesRDD</code>. For example, you can create corresponding data frames to execute Spark SQL queries. The following example creates a SQL Context, gets two data frames from the <code class="codeph">nodesRDD</code> and <code class="codeph">edgesRDD</code>, and runs a query to get all friends of a vertex with ID 1:</p>
<pre dir="ltr">
SQLContext sqlCtx = new SQLContext(sc);
DataFrame verticesDF = sqlCtx.createDataFrame(verticesRDD);
verticesDF.registerTempTable("VERTICES_TABLE");

DataFrame edgesDF = sqlCtx.createDataFrame(edgesRDD);
edgesDF.registerTempTable("EDGES_TABLE");

sqlCtx.sql("select name from (select target from EDGES_TABLE WHERE source = 1) REACHABLE
left join VERTICES_TABLE on VERTICES_TABLE.id = REACHABLE.target ").show();
</pre>
<p>Note that case classes <code class="codeph">MyVertex</code> and <code class="codeph">MyEdge</code> play an important role here, because Spark uses them in order to determine the data frame&rsquo;s column names.</p>
<p>In addition to reading out graph data directly from Oracle NoSQL Database and performing operations on the graph in Apache Spark, you can use the in-memory analyst to analyze graph data in Apache Spark, as explained in <a href="using-in-memory-analyst.htm#GUID-286D11B2-5A66-4072-808D-8FA569DDCC4A" title="The property graph feature in Oracle Big Data Spatial and Graph enables integration of in-memory analytics and Apache Spark.">Using the In-Memory Analyst to Analyze Graph Data in Apache Spark</a>.</p>
</div>
</div>
</div>
<div class="props_rev_3"><a id="GUID-924E8670-F550-41F9-884A-1998409A7544"></a>
<h2 id="BDSPA-GUID-924E8670-F550-41F9-884A-1998409A7544" class="sect2"><span class="enumeration_section">5.8</span> Support for Secure Oracle NoSQL Database</h2>
<div>
<p>Oracle Big Data Spatial and Graph property graph support works with both secure and non-secure Oracle NoSQL Database installations. This topic provides information about how to use property graph functions with a secure Oracle NoSQL Database setup.</p>
<p>It assumes that a secure Oracle NoSQL Database is already installed (a process explained in "Performing a Secure Oracle NoSQL Database Installation" in the <span class="italic">Oracle NoSQL Database Security Guide</span> at <a href="http://docs.oracle.com/cd/NOSQL/html/SecurityGuide/secure_installation.html" target="_blank"><code class="codeph">http://docs.oracle.com/cd/NOSQL/html/SecurityGuide/secure_installation.html</code></a>).</p>
<p>You must have the correct credentials to access the secure database. Create a user such as the following:</p>
<pre dir="ltr">
kv-&gt; plan create-user -name myusername -admin -wait
</pre>
<p>Grant this user the <code class="codeph">readwrite</code> and <code class="codeph">dbaadmin</code> roles. For example:</p>
<pre dir="ltr">
kv-&gt; plan grant -user myusername -role readwrite -wait
kv-&gt; plan grant -user myusername -role dbadmin -wait
</pre>
<p>When generating the <code class="codeph">login_properties.txt</code> from the file <code class="codeph">client.security</code>, make sure the user name is correct. For example:</p>
<pre dir="ltr">
oracle.kv.auth.username=myusername
</pre>
<p>On Oracle property graph client side, you must have the security-related files and libraries to interact with the secure Oracle NoSQL Database. First, copy these files (or directories) from <code class="codeph">KVROOT/security/</code> to the client side:</p>
<pre dir="ltr">
client.security
client.trust    
login.wallet/
login_properties.txt
</pre>
<p>If Oracle Wallet is used to hold passwords that are needed for accessing the secure database, copy these three libraries to the client side and set the class path correctly:</p>
<pre dir="ltr">
oraclepki.jar
osdt_cert.jar
osdt_core.jar
</pre>
<p>After configuring the database and Oracle property graph client side correctly, you can connect to a graph stored in Secure NoSQL Database using either one of the following two approaches.</p>
<ul style="list-style-type: disc;">
<li>
<p>Specify the login properties file, using a Java VM setting with the following format:</p>
<pre dir="ltr">
-Doracle.kv.security=/&lt;your-path&gt;/login_properties.txt
</pre>
<p>You can also set this Java VM property for applications deployed into a J2EE container (including in-memory analytics). For example, before starting WebLogic Server, you can set an environment variable in the following format to refer to the login properties configuration file:</p>
<pre dir="ltr">
setenv JAVA_OPTIONS "-Doracle.kv.security=/&lt;your-path&gt;/login_properties.txt"
</pre>
<p>Then you can call <code class="codeph">OraclePropertyGraph.getInstance(kconfig, szGraphName)</code> as usual to create an <code class="codeph">OraclePropertyGraph</code> instance.</p>
</li>
<li>
<p>Call <code class="codeph">OraclePropertyGraph.getInstance(kconfig, szGraphName, username, password, truStoreFile)</code>, where <code class="codeph">username</code> and <code class="codeph">password</code> are the correct credentials to access secure Oracle NoSQL Database, and <code class="codeph">truStoreFile</code> is the path to the client side trust store file <code class="codeph">client.trust</code>.</p>
<p>The following code fragment creates a property graph in a Secure Oracle NoSQL Database, loads the data, and then counts how many vertices and edges in the graph:</p>
<pre dir="ltr">
// This object will handle operations over the property graph 
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(kconfig,
szGraphName,
username,
password,
truStoreFile);

// Clear existing vertices/edges in the property graph 
opg.clearRepository();
opg.setQueueSize(100); // 100 elements

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";
// This object will handle parallel data loading over the property graph
System.out.println("Load data for graph " + szGraphName);
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop);
// Count all vertices
long countV = 0;
Iterator&lt;Vertex&gt; vertices = opg.getVertices().iterator();
while (vertices.hasNext()) {
vertices.next();
countV++;
}

System.out.println("Vertices found: " + countV);
// Count all edges
long countE = 0;
Iterator&lt;Edge&gt; edges = opg.getEdges().iterator();
while (edges.hasNext()) {
edges.next();
countE++;
}

System.out.println("Edges found: " + countE);
</pre></li>
</ul>
</div>
</div>
<div class="sect2"><a id="GUID-71095D2A-E20F-4FD2-9571-A36031995D8C"></a>
<h2 id="BDSPA-GUID-71095D2A-E20F-4FD2-9571-A36031995D8C" class="sect2"><span class="enumeration_section">5.9</span> Implementing Security on Graphs Stored in Apache HBase</h2>
<div>
<p>Kerberos authentication is recommended for Apache HBase to secure property graphs in Oracle Big Data Spatial and Graph.</p>
<p>Oracle's property graph support works with both secure and non-secure Cloudera Hadoop (CDH) cluster installations. This topic provides information about secure Apache HBase installations.</p>
<p>Kerberos authentication is recommended for Apache HBase to secure property graphs in Oracle Big Data Spatial and Graph.</p>
<p>This topic assumes that a secure Apache HBase is already configured with Kerberos, that the client machine has the Kerberos libraries installed and that you have the correct credentials. For detailed information, see "Configuring Kerberos Authentication for HBase" at: <a href="http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_sg_hbase_authentication.html" target="_blank"><code class="codeph">http://www.cloudera.com/content/cloudera/en/documentation/core/latest/topics/cdh_sg_hbase_authentication.html</code></a>. For information about how to set up your Kerberos cluster and clients, see the MIT Kerberos Documentation at <a href="http://web.mit.edu/kerberos/krb5-latest/doc/index.html" target="_blank"><code class="codeph">http://web.mit.edu/kerberos/krb5-latest/doc/index.html</code></a>.</p>
<p>On the client side, you must have a Kerberos credential to interact with the Kerberos-enabled HDFS daemons. Additionally, you need to modify the Kerberos configuration information (located in <code class="codeph">krb5.conf</code>) to include the realm and mappings of hostnames onto Kerberos realms used in the Secure CDH Cluster.</p>
<p>The following code fragment shows the realm and hostname mapping used in a Secure CDH cluster on BDA.COM:</p>
<pre dir="ltr">
[libdefaults]
 default_realm = EXAMPLE.COM
 dns_lookup_realm = false
 dns_lookup_kdc = false
 ticket_lifetime = 24h
 renew_lifetime = 7d
 forwardable = yes

[realms]
 EXAMPLE.COM = {
kdc = hostname1.example.com:88
kdc = hostname2.example.com:88
admin_server = hostname1.example.com:749
default_domain = example.com
 }
<span class="bold">BDA.COM = {
kdc = hostname1.bda.com:88
kdc = hostname2.bda.com:88
admin_server = hostname1.bda.com:749
default_domain = bda.com
 }
</span>
[domain_realm]
 .example.com = EXAMPLE.COM
 example.com = EXAMPLE.COM
 <span class="bold">.bda.com = BDA.COM
 bda.com = BDA.COM
</span>
</pre>
<p>After modifying <code class="codeph">krb5.conf</code>, you can connect to a graph stored in Apache HBase by using a Java Authentication and Authorization Service (JAAS) configuration file to provide your credentials to the application. This provides the same capabilities of the preceding example without having to modify a single line of your code in case you already have an application that uses an insecure Apache HBase installation.</p>
<p>To use property graph support for for HBase with a JAAS configuration, create a file with content in the following form, replacing the <code class="codeph">keytab</code> and <code class="codeph">principal</code> entries with your own information:</p>
<pre dir="ltr">
Client {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab=true
useTicketCache=true
keyTab="/path/to/your/keytab/user.keytab"
principal="your-user/your.fully.qualified.domain.name@YOUR.REALM";
};
</pre>
<p>The following code fragment shows an example JAAS file with the realm used in a Secure CDH cluster on BDA.COM:</p>
<pre dir="ltr">
Client {
com.sun.security.auth.module.Krb5LoginModule required
useKeyTab=true
useTicketCache=true
keyTab="/path/to/keytab/user.keytab"
principal="hbaseuser/hostname1@BDA.COM";
};
</pre>
<p>In order to run your Secure HBase application you must specify the JAAS configuration file you created by using the java.security.auth.login.config flag. You can run your application using a command in the following format:</p>
<pre dir="ltr">
java -Djava.security.auth.login.config=/path/to/your/jaas.conf/ -classpath ./classes/:../../lib/'*' YourJavaApplication
</pre>
<p>Then, you can call <code class="codeph">OraclePropertyGraph.getInstance(conf, hconn, szGraphName)</code> as usual to create an Oracle property graph.</p>
<p>Another option to use the Oracle Big Data Spatial and Graph property graph support on a secure Apache HBase installation is to use a secure HBase configuration. The following code fragment shows how to obtain a secure HBase configuration using prepareSecureConfig(). This API requires the security authentication setting used in Apache Hadoop and Apache HBase, as well as Kerberos credentials set to authenticate and obtain an authorized ticket.</p>
<p>The following code fragment creates a property graph in a Secure Apache HBase, loads the data, and then counts how many vertices and edges in the graph.</p>
<pre dir="ltr">
String szQuorum= "hostname1,hostname2,hostname3";
String szCliPort = "2181"; 
String szGraph = "SecureGraph";

<span class="bold">String hbaseSecAuth="kerberos";
String hadoopSecAuth="kerberos";
String hmKerberosPrincipal="hbase/_HOST@BDA.COM";
String rsKerberosPrincipal="hbase/_HOST@BDA.COM";
String userPrincipal = "hbase/hostname1@BDA.COM";
String keytab= "/path/to/your/keytab/hbase.keytab";
int dop= 8;</span>

Configuration conf = HBaseConfiguration.create();
conf.set("hbase.zookeeper.quorum", szQuorum);
conf.set("hbase.zookeeper.property.clientPort", szCliPort);

// Prepare the secure configuration providing the credentials in the keytab
conf = OraclePropertyGraph.prepareSecureConfig(conf, 
 hbaseSecAuth, 
 hadoopSecAuth, 
 hmKerberosPrincipal, 
 rsKerberosPrincipal, 
 userPrincipal, 
 keytab);
HConnection hconn = HConnectionManager.createConnection(conf);

OraclePropertyGraph opg=OraclePropertyGraph.getInstance(conf, hconn, szGraph);
opg.setInitialNumRegions(24);
opg.clearRepository();

String szOPVFile = "../../data/connections.opv";
String szOPEFile = "../../data/connections.ope";

// Do a parallel data loading
OraclePropertyGraphDataLoader opgdl = OraclePropertyGraphDataLoader.getInstance();
opgdl.loadData(opg, szOPVFile, szOPEFile, dop);
opg.commit();
</pre></div>
</div>
<a id="BDSPA373"></a>
<div class="props_rev_3"><a id="GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A"></a>
<h2 id="BDSPA-GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A" class="sect2"><span class="enumeration_section">5.10</span> Using the Groovy Shell with Property Graph Data</h2>
<div>
<p>The Oracle Big Data Spatial and Graph property graph support includes a built-in Groovy shell (based on the original Gremlin Groovy shell script). With this command-line shell interface, you can explore the Java APIs.</p>
<p>To start the Groovy shell, go to the <code class="codeph">dal/groovy</code> directory under the installation home (<code class="codeph">/opt/oracle/oracle-spatial-graph/property_graph</code> by default). For example:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/dal/groovy/
</pre>
<p>Included are the scripts <code class="codeph">gremlin-opg-nosql.sh</code> and <code class="codeph">gremlin-opg-hbase.sh</code>, for connecting to an Oracle NoSQL Database and an Apache HBase, respectively.</p>
<div class="infobox-note" id="GUID-6C6E8FA5-2B97-4AD9-BD95-7A4B848F735A__GUID-08B8E3DA-9227-4BF6-ABD3-7C3ABCC2CA38">
<p class="notep1">Note:</p>
To run some gremlin traversal examples, you must first do the following import operation:
<pre dir="ltr">
import com.tinkerpop.pipes.util.structures.*;
</pre></div>
<p>The following example connects to an Oracle NoSQL Database, gets an instance of <code class="codeph">OraclePropertyGraph</code> with graph name <code class="codeph">myGraph</code>, loads some example graph data, and gets the list of vertices and edges.</p>
<pre dir="ltr">
<span class="bold">$ ./gremlin-opg-nosql.sh</span>
 
opg-nosql&gt;
opg-nosql&gt; hhosts = new String[1];
==&gt;null
 
opg-nosql&gt; hhosts[0] = "bigdatalite:5000";
==&gt;bigdatalite:5000
 
opg-nosql&gt; cfg = GraphConfigBuilder.forPropertyGraphNosql().setName("myGraph").setHosts(Arrays.asList(hhosts)).setStoreName("mystore").addEdgeProperty("lbl", PropertyType.STRING, "lbl").addEdgeProperty("weight", PropertyType.DOUBLE, "1000000").build();
==&gt;{"db_engine":"NOSQL","loading":{},"format":"pg","name":"myGraph","error_handling":{},"hosts":["bigdatalite:5000"],"node_props":[],"store_name":"mystore","edge_props":[{"type":"string","name":"lbl","default":"lbl"},{"type":"double","name":"weight","default":"1000000"}]}
 
opg-nosql&gt; opg = OraclePropertyGraph.getInstance(cfg);
==&gt;oraclepropertygraph with name myGraph
 
opg-nosql&gt; opgdl = OraclePropertyGraphDataLoader.getInstance();
==&gt;oracle.pg.nosql.OraclePropertyGraphDataLoader@576f1cad
 
opg-nosql&gt; opgdl.loadData(opg, new FileInputStream("../../data/connections.opv"), new FileInputStream("../../data/connections.ope"), 1, 1, 0, null);
==&gt;null
 
opg-nosql&gt; opg.getVertices();
==&gt;Vertex ID 5 {country:str:Italy, name:str:Pope Francis, occupation:str:pope, religion:str:Catholicism, role:str:Catholic religion authority}
[... other output lines omitted for brevity ...]
 
opg-nosql&gt;  opg.getEdges();
==&gt;Edge ID 1139 from Vertex ID 64 {country:str:United States, name:str:Jeff Bezos, occupation:str:business man} =[leads]=&gt; Vertex ID 37 {country:str:United States, name:str:Amazon, type:str:online retailing} edgeKV[{weight:flo:1.0}]
[... other output lines omitted for brevity ...]
</pre>
<p>The following example customizes several configuration parameters for in-memory analytics. It connects to an Apache HBase, gets an instance of <code class="codeph">OraclePropertyGraph</code> with graph name <code class="codeph">myGraph</code>, loads some example graph data, gets the list of vertices and edges, gets an in-memory analyst, and execute one of the built-in analytics, triangle counting.</p>
<pre dir="ltr">
<span class="bold">$ ./gremlin-opg-hbase.sh</span>
opg-hbase&gt;
opg-hbase&gt; dop=2;   // degree of parallelism
==&gt;2
opg-hbase&gt; confPgx = new HashMap&lt;PgxConfig.Field, Object&gt;();
opg-hbase&gt; confPgx.put(PgxConfig.Field.ENABLE_GM_COMPILER, false);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_IO, dop + 2);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_ANALYSIS, 3);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.NUM_WORKERS_FAST_TRACK_ANALYSIS, 2);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.SESSION_TASK_TIMEOUT_SECS, 0);
==&gt;null
opg-hbase&gt; confPgx.put(PgxConfig.Field.SESSION_IDLE_TIMEOUT_SECS, 0);
==&gt;null
opg-hbase&gt; instance = Pgx.getInstance()
==&gt;null
opg-hbase&gt; instance.startEngine(confPgx) 
==&gt;null

opg-hbase&gt; cfg = GraphConfigBuilder.forPropertyGraphHbase() .setName("myGraph") .setZkQuorum("bigdatalite") .setZkClientPort(iClientPort) .setZkSessionTimeout(60000) .setMaxNumConnections(dop) .setLoadEdgeLabel(true) .setSplitsPerRegion(1) .addEdgeProperty("lbl", PropertyType.STRING, "lbl") .addEdgeProperty("weight", PropertyType.DOUBLE, "1000000") .build();
==&gt;{"splits_per_region":1,"max_num_connections":2,"node_props":[],"format":"pg","load_edge_label":true,"name":"myGraph","zk_client_port":2181,"zk_quorum":"bigdatalite","edge_props":[{"type":"string","default":"lbl","name":"lbl"},{"type":"double","default":"1000000","name":"weight"}],"loading":{},"error_handling":{},"zk_session_timeout":60000,"db_engine":"HBASE"}
 
opg-hbase&gt; opg = OraclePropertyGraph.getInstance(cfg);  
==&gt;oraclepropertygraph with name myGraph
 
 
opg-hbase&gt; opgdl = OraclePropertyGraphDataLoader.getInstance();
==&gt;oracle.pg.hbase.OraclePropertyGraphDataLoader@3451289b
 
opg-hbase&gt; opgdl.loadData(opg, "../../data/connections.opv", "../../data/connections.ope", 1, 1, 0, null);
==&gt;null
 
opg-hbase&gt; opg.getVertices();
==&gt;Vertex ID 78 {country:str:United States, name:str:Hosain Rahman, occupation:str:CEO of Jawbone}
...
 
opg-hbase&gt; opg.getEdges();
==&gt;Edge ID 1139 from Vertex ID 64 {country:str:United States, name:str:Jeff Bezos, occupation:str:business man} =[leads]=&gt; Vertex ID 37 {country:str:United States, name:str:Amazon, type:str:online retailing} edgeKV[{weight:flo:1.0}]
[... other output lines omitted for brevity ...]
 
opg-hbase&gt; session = Pgx.createSession("session-id-1");
opg-hbase&gt; g = session.readGraphWithProperties(cfg);
opg-hbase&gt; analyst = session.createAnalyst();
 
opg-hbase&gt;  triangles = analyst.countTriangles(false).get();
==&gt;22
</pre>
<p>For detailed information about the Java APIs, see the Javadoc reference information in <code class="codeph">doc/dal/</code> and <code class="codeph">doc/pgx/</code> under the installation home (<code class="codeph">/opt/oracle/oracle-spatial-graph/property_graph/</code> by default).</p>
</div>
</div>
<a id="BDSPA236"></a>
<div class="props_rev_3"><a id="GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C"></a>
<h2 id="BDSPA-GUID-6502D0F9-3A2C-4D21-A09C-17414D46928C" class="sect2"><span class="enumeration_section">5.11</span> Exploring the Sample Programs</h2>
<div>
<p>The software installation includes a directory of example programs, which you can use to learn about creating and manipulating property graphs.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-8123198B-CF83-4860-8F59-352431B3EE97">About the Sample Programs</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C">Compiling and Running the Sample Programs</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-995091E2-0002-4C92-A24A-A6B284118B71">About the Example Output</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3">Example: Creating a Property Graph</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-47690868-616C-4230-8DD5-BA7DAB129566">Example: Dropping a Property Graph</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778">Examples: Adding and Dropping Vertices and Edges</a><br /></li>
</ul>
</div>
<a id="BDSPA238"></a><a id="BDSPA237"></a>
<div class="props_rev_3"><a id="GUID-8123198B-CF83-4860-8F59-352431B3EE97"></a>
<h3 id="BDSPA-GUID-8123198B-CF83-4860-8F59-352431B3EE97" class="sect3"><span class="enumeration_section">5.11.1</span> About the Sample Programs</h3>
<div>
<p>The sample programs are distributed in an installation subdirectory named <code class="codeph">examples/dal</code>. The examples are replicated for HBase and Oracle NoSQL Database, so that you can use the set of programs corresponding to your choice of backend database. The following table describes the some of the programs.</p>
<div class="tblformal" id="GUID-8123198B-CF83-4860-8F59-352431B3EE97__PROPERTYGRAPHPROGRAMEXAMPLESSELECTE-1126E94E">
<p class="titleintable">Table 5-4 Property Graph Program Examples (Selected)</p>
<table class="cellalignment333" title="Property Graph Program Examples (Selected)" summary="Sample program descriptions. Column 1 is Program Name, and column 2 is Description.">
<thead>
<tr class="cellalignment324">
<th class="cellalignment338" id="d28904e6207">Program Name</th>
<th class="cellalignment339" id="d28904e6210">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment340" id="d28904e6215" headers="d28904e6207">
<p>ExampleNoSQL1</p>
<p>ExampleHBase1</p>
</td>
<td class="cellalignment341" headers="d28904e6215 d28904e6210">
<p>Creates a minimal property graph consisting of one vertex, sets properties with various data types on the vertex, and queries the database for the saved graph description.</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment340" id="d28904e6224" headers="d28904e6207">
<p>ExampleNoSQL2</p>
<p>ExampleHBase2</p>
</td>
<td class="cellalignment341" headers="d28904e6224 d28904e6210">
<p>Creates the same minimal property graph as Example1, and then deletes it.</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment340" id="d28904e6233" headers="d28904e6207">
<p>ExampleNoSQL3</p>
<p>ExampleHBase3</p>
</td>
<td class="cellalignment341" headers="d28904e6233 d28904e6210">
<p>Creates a graph with multiple vertices and edges. Deletes some vertices and edges explicitly, and other implicitly by deleting other, required objects. This example queries the database repeatedly to show the current list of objects.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="BDSPA240"></a><a id="BDSPA241"></a><a id="BDSPA239"></a>
<div class="props_rev_3"><a id="GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C"></a>
<h3 id="BDSPA-GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C" class="sect3"><span class="enumeration_section">5.11.2</span> Compiling and Running the Sample Programs</h3>
<div>
<p>To compile and run the Java source files:</p>
<ol>
<li>
<p>Change to the examples directory:</p>
<pre dir="ltr">
cd examples/dal
</pre></li>
<li>
<p>Use the Java compiler:</p>
<pre dir="ltr">
javac -classpath ../../lib/'*' filename.java
</pre>
<p>For example: <code class="codeph">javac -classpath ../../lib/'*' ExampleNoSQL1.java</code></p>
</li>
<li>
<p>Execute the compiled code:</p>
<pre dir="ltr">
java -classpath ../../lib/'*':./ filename args
</pre>
<p>The arguments depend on whether you are using Oracle NoSQL Database or Apache HBase to store the graph. The values are passed to <code class="codeph">OraclePropertyGraph.getInstance</code>.</p>
</li>
</ol>
<div class="section">
<p class="subhead3">Apache HBase Argument Descriptions</p>
</div>
<!-- class="section" -->
<div class="section">
<p>Provide these arguments when using the HBase examples:</p>
<ol>
<li>
<p><span class="italic">quorum</span>: A comma-delimited list of names identifying the nodes where HBase runs, such as <code class="codeph">"node01.example.com, node02.example.com, node03.example.com"</code>.</p>
</li>
<li>
<p><span class="italic">client_port</span>: The HBase client port number, such as <code class="codeph">"2181"</code>.</p>
</li>
<li>
<p><span class="italic">graph_name</span>: The name of the graph, such as <code class="codeph">"customer_graph"</code>.</p>
</li>
</ol>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Oracle NoSQL Database Argument Descriptions</p>
</div>
<!-- class="section" -->
<div class="section">
<p>Provide these arguments when using the NoSQL examples:</p>
<ol>
<li>
<p><span class="italic">host_name</span>: The cluster name and port number for Oracle NoSQL Database registration, such as <code class="codeph">"cluster02:5000"</code>.</p>
</li>
<li>
<p><span class="italic">store_name</span>: The name of the key-value store, such as <code class="codeph">"kvstore"</code></p>
</li>
<li>
<p><span class="italic">graph_name</span>: The name of the graph, such as <code class="codeph">"customer_graph"</code>.</p>
</li>
</ol>
</div>
<!-- class="section" --></div>
</div>
<a id="BDSPA243"></a><a id="BDSPA242"></a>
<div class="props_rev_3"><a id="GUID-995091E2-0002-4C92-A24A-A6B284118B71"></a>
<h3 id="BDSPA-GUID-995091E2-0002-4C92-A24A-A6B284118B71" class="sect3"><span class="enumeration_section">5.11.3</span> About the Example Output</h3>
<div>
<p>The example programs use <code class="codeph">System.out.println</code> to retrieve the property graph descriptions from the database where it is stored, either Oracle NoSQL Database or Apache HBase. The key name, data type, and value are delimited by colons. For example, <code class="codeph">weight:flo:30.0</code> indicates that the key name is <code class="codeph">weight</code>, the data type is <code class="codeph">float</code>, and the value is <code class="codeph">30.0.</code></p>
<p><a href="using-property-graphs-big-data.htm#GUID-995091E2-0002-4C92-A24A-A6B284118B71__CEGHEIAI" title="Property graph output data type abbreviations">Table 5-5</a> identifies the data type abbreviations used in the output.</p>
<div class="tblformal" id="GUID-995091E2-0002-4C92-A24A-A6B284118B71__CEGHEIAI">
<p class="titleintable">Table 5-5 Property Graph Data Type Abbreviations</p>
<table class="cellalignment333" title="Property Graph Data Type Abbreviations" summary="Property graph output data type abbreviations">
<thead>
<tr class="cellalignment324">
<th class="cellalignment342" id="d28904e6455">Abbreviation</th>
<th class="cellalignment342" id="d28904e6458">Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment343" id="d28904e6463" headers="d28904e6455">
<p>bol</p>
</td>
<td class="cellalignment343" headers="d28904e6463 d28904e6458">
<p>Boolean</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment343" id="d28904e6470" headers="d28904e6455">
<p>dat</p>
</td>
<td class="cellalignment343" headers="d28904e6470 d28904e6458">
<p>date</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment343" id="d28904e6477" headers="d28904e6455">
<p>dbl</p>
</td>
<td class="cellalignment343" headers="d28904e6477 d28904e6458">
<p>double</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment343" id="d28904e6484" headers="d28904e6455">
<p>flo</p>
</td>
<td class="cellalignment343" headers="d28904e6484 d28904e6458">
<p>float</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment343" id="d28904e6491" headers="d28904e6455">
<p>int</p>
</td>
<td class="cellalignment343" headers="d28904e6491 d28904e6458">
<p>integer</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment343" id="d28904e6498" headers="d28904e6455">
<p>ser</p>
</td>
<td class="cellalignment343" headers="d28904e6498 d28904e6458">
<p>serializable</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment343" id="d28904e6505" headers="d28904e6455">
<p>str</p>
</td>
<td class="cellalignment343" headers="d28904e6505 d28904e6458">
<p>string</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="BDSPA245"></a><a id="BDSPA244"></a>
<div class="props_rev_3"><a id="GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3"></a>
<h3 id="BDSPA-GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3" class="sect3"><span class="enumeration_section">5.11.4</span> Example: Creating a Property Graph</h3>
<div>
<p><code class="codeph">ExampleNoSQL1</code> and <code class="codeph">ExampleHBase1</code> create a minimal property graph consisting of one vertex. The code fragment in <a href="using-property-graphs-big-data.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3__BHBCBGCB">Example 5-5</a> creates a vertex named <code class="codeph">v1</code> and sets properties with various data types. It then queries the database for the saved graph description.</p>
<div class="example" id="GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3__BHBCBGCB">
<p class="titleinexample">Example 5-5 Creating a Property Graph</p>
<pre dir="ltr">
// Create a property graph instance named opg
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(<span class="italic">args</span>);
 
// Clear all vertices and edges from opg
    opg.clearRepository();

// Create vertex v1 and assign it properties as key-value pairs
    Vertex v1 = opg.addVertex(1l);
    v1.setProperty("age",  Integer.valueOf(18));
    v1.setProperty("name", "Name");
    v1.setProperty("weight", Float.valueOf(30.0f));
    v1.setProperty("height", Double.valueOf(1.70d));
    v1.setProperty("female", Boolean.TRUE);
 
// Save the graph in the database
    opg.commit();

// Display the stored vertex description
System.out.println("Fetch 1 vertex: " + opg.getVertices().iterator().next());
 
// Close the graph instance
    opg.shutdown();
</pre>
<p>The <code class="codeph">OraclePropertyGraph.getInstance</code> arguments (<span class="italic">args</span>) depend on whether you are using Oracle NoSQL Database or Apache HBase to store the graph. See <span class="q">"<a href="using-property-graphs-big-data.htm#GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C">Compiling and Running the Sample Programs</a>"</span>.</p>
<p><code class="codeph">System.out.println</code> displays the following output:</p>
<pre dir="ltr">
Fetch 1 vertex: Vertex ID 1 {age:int:18, name:str:Name, weight:flo:30.0, height:dbl:1.7, female:bol:true}
</pre>
<p>See the property graph support Javadoc (<code class="codeph">/opt/oracle/oracle-spatial-graph/property_graph/doc/pgx</code> by default) for the following:</p>
<pre dir="ltr">
OraclePropertyGraph.addVertex
OraclePropertyGraph.clearRepository
OraclePropertyGraph.getInstance
OraclePropertyGraph.getVertices
OraclePropertyGraph.shutdown
Vertex.setProperty
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA247"></a><a id="BDSPA246"></a>
<div class="props_rev_3"><a id="GUID-47690868-616C-4230-8DD5-BA7DAB129566"></a>
<h3 id="BDSPA-GUID-47690868-616C-4230-8DD5-BA7DAB129566" class="sect3"><span class="enumeration_section">5.11.5</span> Example: Dropping a Property Graph</h3>
<div>
<p>ExampleNoSQL2 and ExampleHBase2 create a graph like the one in <span class="q">"<a href="using-property-graphs-big-data.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3">Example: Creating a Property Graph</a>"</span>, and then drop it from the database.</p>
<p>The code fragment in <a href="using-property-graphs-big-data.htm#GUID-47690868-616C-4230-8DD5-BA7DAB129566__BHBBHIDF">Example 5-6</a> drops the graph. See <span class="q">"<a href="using-property-graphs-big-data.htm#GUID-D98C58FB-BBB2-4FEC-BE1B-EEEFD781A28C">Compiling and Running the Sample Programs</a>"</span> for descriptions of the <code class="codeph">OraclePropertyGraphUtils.dropPropertyGraph</code> arguments.</p>
<div class="example" id="GUID-47690868-616C-4230-8DD5-BA7DAB129566__BHBBHIDF">
<p class="titleinexample">Example 5-6 Dropping a Property Graph</p>
<pre dir="ltr">
// Drop the property graph from the database
OraclePropertyGraphUtils.dropPropertyGraph(<span class="italic">args</span>);

// Display confirmation that the graph was dropped
System.out.println("Graph " + <span class="italic">graph_name</span> + " dropped. ");
</pre>
<p><code class="codeph">System.out.println</code> displays the following output:</p>
<pre dir="ltr">
Graph <span class="italic">graph_name</span> dropped.
</pre>
<p>See the Javadoc for <code class="codeph">OraclePropertyGraphUtils.dropPropertyGraph</code>.</p>
</div>
<!-- class="example" --></div>
</div>
<a id="BDSPA249"></a><a id="BDSPA250"></a><a id="BDSPA251"></a><a id="BDSPA252"></a><a id="BDSPA248"></a>
<div class="props_rev_3"><a id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778"></a>
<h3 id="BDSPA-GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778" class="sect3"><span class="enumeration_section">5.11.6</span> Examples: Adding and Dropping Vertices and Edges</h3>
<div>
<p>ExampleNoSQL3 and ExampleHBase3 add and drop both vertices and edges.</p>
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCBCFH">
<p class="titleinexample">Example 5-7 Creating the Vertices</p>
<p>The code fragment in <a href="using-property-graphs-big-data.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCBCFH">Example 5-7</a> creates three vertices. It is a simple variation of <a href="using-property-graphs-big-data.htm#GUID-E4747521-F98B-4CF2-804C-AEFE5D52D9C3__BHBCBGCB">Example 5-5</a>.</p>
<pre dir="ltr">
// Create a property graph instance named opg
OraclePropertyGraph opg = OraclePropertyGraph.getInstance(<span class="italic">args</span>);
 
// Clear all vertices and edges from opg
    opg.clearRepository();

// Add vertices a, b, and c
    Vertex a = opg.addVertex(1l);
    a.setProperty("name", "Alice");
    a.setProperty("age", 31);
  
    Vertex b = opg.addVertex(2l);  
    b.setProperty("name", "Bob");
    b.setProperty("age", 27);
 
    Vertex c = opg.addVertex(3l);
    c.setProperty("name", "Chris");
    c.setProperty("age", 33);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHIGH">
<p class="titleinexample">Example 5-8 Creating the Edges</p>
<p>The code fragment in <a href="using-property-graphs-big-data.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHIGH">Example 5-8</a> uses vertices a, b, and c to create the edges.</p>
<pre dir="ltr">
// Add edges e1, e2, and e3
    Edge e1 = opg.addEdge(1l, a, b, "knows");
    e1.setProperty("type", "partners");
 
    Edge e2 = opg.addEdge(2l, a, c, "knows");
    e2.setProperty("type", "friends");
 
    Edge e3 = opg.addEdge(3l, b, c, "knows");
    e3.setProperty("type", "colleagues");
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHGCE">
<p class="titleinexample">Example 5-9 Deleting Edges and Vertices</p>
<p>The code fragment in <a href="using-property-graphs-big-data.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBCHGCE">Example 5-9</a> explicitly deletes edge <code class="codeph">e3</code> and vertex <code class="codeph">b</code>. It implicitly deletes edge <code class="codeph">e1</code>, which was connected to vertex <code class="codeph">b</code>.</p>
<pre dir="ltr">
 // Remove edge e3
    opg.removeEdge(e3);

// Remove vertex b and all related edges
    opg.removeVertex(b);
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBEIDEH">
<p class="titleinexample">Example 5-10 Querying for Vertices and Edges</p>
<p>This example queries the database to show when objects are added and dropped. The code fragment in <a href="using-property-graphs-big-data.htm#GUID-F75E613F-CC05-45F5-8C84-ABB16B1B7778__BHBEIDEH">Example 5-10</a> shows the method used.</p>
<pre dir="ltr">
// Print all vertices
    vertices = opg.getVertices().iterator();
    System.out.println("----- Vertices ----");
    vCount = 0;
    while (vertices.hasNext()) {
      System.out.println(vertices.next());
      vCount++;
    }
    System.out.println("Vertices found: " + vCount);
 
    // Print all edges
    edges = opg.getEdges().iterator();
    System.out.println("----- Edges ----");
    eCount = 0;
    while (edges.hasNext()) {
      System.out.println(edges.next());
      eCount++;
    }
    System.out.println("Edges found: " + eCount);
</pre>
<p>The examples in this topic may produce output like the following:</p>
<pre dir="ltr">
----- Vertices ----
Vertex ID 3 {name:str:Chris, age:int:33}
Vertex ID 1 {name:str:Alice, age:int:31}
Vertex ID 2 {name:str:Bob, age:int:27}
Vertices found: 3
----- Edges ----
Edge ID 2 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:friends}]
Edge ID 3 from Vertex ID 2 {name:str:Bob, age:int:27} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:colleagues}]
Edge ID 1 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 2 {name:str:Bob, age:int:27} edgeKV[{type:str:partners}]
Edges found: 3
 Remove edge Edge ID 3 from Vertex ID 2 {name:str:Bob, age:int:27} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:colleagues}]
----- Vertices ----
Vertex ID 1 {name:str:Alice, age:int:31}
Vertex ID 2 {name:str:Bob, age:int:27}
Vertex ID 3 {name:str:Chris, age:int:33}
Vertices found: 3
----- Edges ----
Edge ID 2 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:friends}]
Edge ID 1 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 2 {name:str:Bob, age:int:27} edgeKV[{type:str:partners}]
Edges found: 2
Remove vertex Vertex ID 2 {name:str:Bob, age:int:27}
----- Vertices ----
Vertex ID 1 {name:str:Alice, age:int:31}
Vertex ID 3 {name:str:Chris, age:int:33}
Vertices found: 2
----- Edges ----
Edge ID 2 from Vertex ID 1 {name:str:Alice, age:int:31} =[knows]=&gt; Vertex ID 3 {name:str:Chris, age:int:33} edgeKV[{type:str:friends}]
Edges found: 1
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="BDSPA254"></a>
<div class="props_rev_3"><a id="GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5"></a>
<h2 id="BDSPA-GUID-A4C6D6AD-AD74-48C7-805B-8AC7A9F2E2F5" class="sect2"><span class="enumeration_section">5.12</span> Oracle Flat File Format Definition</h2>
<div>
<p>A property graph can be defined in two flat files, specifically description files for the vertices and edges.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-5DA27116-5238-45AA-8D4F-78A66D320F5A">About the Property Graph Description Files</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71">Vertex File</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A">Edge File</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-A6950802-B4B6-4698-8513-ED7D05357F9B">Encoding Special Characters</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-A5A1666F-53CF-41DE-A814-1C70F44E70ED">Example Property Graph in Oracle Flat File Format</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B">Converting an Oracle Database Table to an Oracle-Defined Property Graph Flat File</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-C20DE69B-322D-4FBE-B132-507C784F4581">Converting CSV Files for Vertices and Edges to Oracle-Defined Property Graph Flat Files</a><br /></li>
</ul>
</div>
<a id="BDSPA255"></a>
<div class="props_rev_3"><a id="GUID-5DA27116-5238-45AA-8D4F-78A66D320F5A"></a>
<h3 id="BDSPA-GUID-5DA27116-5238-45AA-8D4F-78A66D320F5A" class="sect3"><span class="enumeration_section">5.12.1</span> About the Property Graph Description Files</h3>
<div>
<p>A pair of files describe a property graph:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">Vertex file</span>: Describes the vertices of the property graph. This file has an <code class="codeph">.opv</code> file name extension.</p>
</li>
<li>
<p><span class="bold">Edge file</span>: Describes the edges of the property graph. This file has an <code class="codeph">.ope</code> file name extension.</p>
</li>
</ul>
<p>It is recommended that these two files share the same base name. For example, <code class="codeph">simple.opv</code> and <code class="codeph">simple.ope</code> define a property graph.</p>
</div>
</div>
<a id="BDSPA257"></a><a id="BDSPA256"></a>
<div class="props_rev_3"><a id="GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71"></a>
<h3 id="BDSPA-GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71" class="sect3"><span class="enumeration_section">5.12.2</span> Vertex File</h3>
<div>
<p>Each line in a vertex file is a record that describes a vertex of the property graph. A record can describe one key-value property of a vertex, thus multiple records/lines are used to describe a vertex with multiple properties.</p>
<p>A record contains six fields separated by commas. Each record must contain five commas to delimit all fields, whether or not they have values:</p>
<p><span class="italic">vertex_ID, key_name, value_type, value, value, value</span></p>
<p><a href="using-property-graphs-big-data.htm#GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71__BHBCCEDI" title="Vertex file field descriptions. Columns are Field Number, Name, and Description.">Table 5-6</a> describes the fields composing a vertex file record.</p>
<div class="tblformal" id="GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71__BHBCCEDI">
<p class="titleintable">Table 5-6 Vertex File Record Format</p>
<table class="cellalignment333" title="Vertex File Record Format" summary="Vertex file field descriptions. Columns are Field Number, Name, and Description.">
<thead>
<tr class="cellalignment324">
<th class="cellalignment344" id="d28904e7035">Field Number</th>
<th class="cellalignment345" id="d28904e7038">Name</th>
<th class="cellalignment346" id="d28904e7041">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment347" id="d28904e7046" headers="d28904e7035">
<p>1</p>
</td>
<td class="cellalignment348" headers="d28904e7046 d28904e7038">
<p><span class="italic">vertex_ID</span></p>
</td>
<td class="cellalignment349" headers="d28904e7046 d28904e7041">
<p>An integer that uniquely identifies the vertex</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment347" id="d28904e7057" headers="d28904e7035">
<p>2</p>
</td>
<td class="cellalignment348" headers="d28904e7057 d28904e7038">
<p><span class="italic">key_name</span></p>
</td>
<td class="cellalignment349" headers="d28904e7057 d28904e7041">
<p>The name of the key in the key-value pair</p>
<p>If the vertex has no properties, then enter a space (<code class="codeph">%20</code>). This example describes vertex 1 with no properties:</p>
<pre dir="ltr">
1,%20,,,,
</pre></td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment347" id="d28904e7075" headers="d28904e7035">
<p>3</p>
</td>
<td class="cellalignment348" headers="d28904e7075 d28904e7038">
<p><span class="italic">value_type</span></p>
</td>
<td class="cellalignment349" headers="d28904e7075 d28904e7041">
<p>An integer that represents the data type of the value in the key-value pair:</p>
<ul class="simple" style="list-style-type: none;padding-left:0;">
<li><code class="codeph">1</code> String</li>
<li><code class="codeph">2</code> Integer</li>
<li><code class="codeph">3</code> Float</li>
<li><code class="codeph">4</code> Double</li>
<li><code class="codeph">5</code> Timestamp (date)</li>
<li><code class="codeph">6</code> Boolean</li>
<li><code class="codeph">7</code> Long integer</li>
<li><code class="codeph">8</code> Short integer</li>
<li><code class="codeph">9</code> Byte</li>
<li><code class="codeph">10</code> Char</li>
<li><code class="codeph">20</code> Spatial data, which can be geospatial coordinates, lines, polygons, or Well-Known Text (WKT) literals</li>
<li><code class="codeph">101</code> Serializable Java object</li>
</ul>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment347" id="d28904e7136" headers="d28904e7035">
<p>4</p>
</td>
<td class="cellalignment348" headers="d28904e7136 d28904e7038">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment349" headers="d28904e7136 d28904e7041">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is neither numeric nor timestamp (date)</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment347" id="d28904e7150" headers="d28904e7035">
<p>5</p>
</td>
<td class="cellalignment348" headers="d28904e7150 d28904e7038">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment349" headers="d28904e7150 d28904e7041">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is numeric</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment347" id="d28904e7164" headers="d28904e7035">
<p>6</p>
</td>
<td class="cellalignment348" headers="d28904e7164 d28904e7038">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment349" headers="d28904e7164 d28904e7041">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is a timestamp (date)</p>
<p>Use the Java <code class="codeph">SimpleDateFormat</code> class to identify the format of the date. This example describes the date format of <code class="codeph">2015-03-26T00:00:00.000-05:00</code>:</p>
<pre dir="ltr">
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX"); encode(sdf.format((java.util.Date) value));
</pre></td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><span class="bold">Required Grouping of Vertices</span>: A vertex can have multiple properties, and the vertex file includes a record (represented by a single line of text in the flat file) for each combination of a vertex ID and a property for that vertex. In the vertex file, all records for each vertex must be grouped together (that is, not have any intervening records for other vertices. You can accomplish this any way you want, but a convenient way is to sort the vertex file records in ascending (or descending) order by vertex ID. (Note, however, a vertex file is not required to have all records sorted by vertex ID; this is merely one way to achieve the grouping requirement.)</p>
<p>When building a vertex file in Oracle flat file format, it is important to verify that the vertex property name and value fields are correctly encoded (see especially <a href="using-property-graphs-big-data.htm#GUID-A6950802-B4B6-4698-8513-ED7D05357F9B">Encoding Special Characters</a>). To simplify the encoding, you can use the <code class="codeph">OraclePropertyGraphUtils.escape</code> Java API.</p>
<p>You can use the <code class="codeph">OraclePropertyGraphUtils.outputVertexRecord(os, vid, key, value)</code> utility method to serialize a vertex record directly in Oracle flat file format. With this method, you no longer need to worry about encoding of special characters. The method writes a new line of text in the given output stream describing the <span class="italic">key</span>/<span class="italic">value</span> property of the given vertex identified by <span class="italic">vid.</span></p>
<div class="example" id="GUID-4C3A57B8-7297-4F00-9EC9-F79149A1CE71__GUID-A238642D-AF51-465C-A958-0D763959DB32">
<p class="titleinexample">Example 5-11 Using OraclePropertyGraphUtils.outputVertexRecord</p>
<p>This example uses <code class="codeph">OraclePropertyGraphUtils.outputVertexRecord</code> to write two new lines for vertex 1.</p>
<pre dir="ltr">
String opv = "./example.opv"; 
OutputStream os = new FileOutputStream(opv);
int birthYear = 1961;
long vid = 1;
OraclePropertyGraphUtils.outputVertexRecord(os, vid, "name", "Barack Obama");
OraclePropertyGraphUtils.outputVertexRecord(os, vid, "birth year", birthYear);
os.flush();
os.close();
</pre>
<p>The first line in the generated output file describes the property name with value "Barack Obama", and the second line describes his birth year of 1961.</p>
<pre dir="ltr">
% cat example.opv
1,name,Barack%20Obama,,
1,birth%20year,2,,1961,
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA259"></a><a id="BDSPA258"></a>
<div class="props_rev_3"><a id="GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A"></a>
<h3 id="BDSPA-GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A" class="sect3"><span class="enumeration_section">5.12.3</span> Edge File</h3>
<div>
<p>Each line in an edge file is a record that describes an edge of the property graph. A record can describe one key-value property of an edge, thus multiple records are used to describe an edge with multiple properties.</p>
<p>A record contains nine fields separated by commas. Each record must contain eight commas to delimit all fields, whether or not they have values:</p>
<p><span class="italic">edge_ID, source_vertex_ID, destination_vertex_ID, edge_label, key_name, value_type, value, value, value</span></p>
<p><a href="using-property-graphs-big-data.htm#GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A__BHBBIECI" title="Edge file field descriptions. Columns are Field Number, Name, and Description.">Table 5-7</a> describes the fields composing an edge file record.</p>
<div class="tblformal" id="GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A__BHBBIECI">
<p class="titleintable">Table 5-7 Edge File Record Format</p>
<table class="cellalignment333" title="Edge File Record Format" summary="Edge file field descriptions. Columns are Field Number, Name, and Description.">
<thead>
<tr class="cellalignment324">
<th class="cellalignment350" id="d28904e7297">Field Number</th>
<th class="cellalignment351" id="d28904e7300">Name</th>
<th class="cellalignment352" id="d28904e7303">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7308" headers="d28904e7297">
<p>1</p>
</td>
<td class="cellalignment354" headers="d28904e7308 d28904e7300">
<p><span class="italic">edge_ID</span></p>
</td>
<td class="cellalignment355" headers="d28904e7308 d28904e7303">
<p>An integer that uniquely identifies the edge</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7319" headers="d28904e7297">
<p>2</p>
</td>
<td class="cellalignment354" headers="d28904e7319 d28904e7300">
<p><span class="italic">source_vertex_ID</span></p>
</td>
<td class="cellalignment355" headers="d28904e7319 d28904e7303">
<p>The <span class="italic">vertex_ID</span> of the outgoing tail of the edge.</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7333" headers="d28904e7297">
<p>3</p>
</td>
<td class="cellalignment354" headers="d28904e7333 d28904e7300">
<p><span class="italic">destination_vertex_ID</span></p>
</td>
<td class="cellalignment355" headers="d28904e7333 d28904e7303">
<p>The <span class="italic">vertex_ID</span> of the incoming head of the edge.</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7347" headers="d28904e7297">
<p>4</p>
</td>
<td class="cellalignment354" headers="d28904e7347 d28904e7300">
<p><span class="italic">edge_label</span></p>
</td>
<td class="cellalignment355" headers="d28904e7347 d28904e7303">
<p>The encoded label of the edge, which describes the relationship between the two vertices</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7358" headers="d28904e7297">
<p>5</p>
</td>
<td class="cellalignment354" headers="d28904e7358 d28904e7300">
<p><span class="italic">key_name</span></p>
</td>
<td class="cellalignment355" headers="d28904e7358 d28904e7303">
<p>The encoded name of the key in a key-value pair</p>
<p>If the edge has no properties, then enter a space (<code class="codeph">%20</code>). This example describes edge 100 with no properties:</p>
<pre dir="ltr">
100,1,2,likes,%20,,,,
</pre></td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7376" headers="d28904e7297">
<p>6</p>
</td>
<td class="cellalignment354" headers="d28904e7376 d28904e7300">
<p><span class="italic">value_type</span></p>
</td>
<td class="cellalignment355" headers="d28904e7376 d28904e7303">
<p>An integer that represents the data type of the value in the key-value pair:</p>
<ul class="simple" style="list-style-type: none;padding-left:0;">
<li><code class="codeph">1</code> String</li>
<li><code class="codeph">2</code> Integer</li>
<li><code class="codeph">3</code> Float</li>
<li><code class="codeph">4</code> Double</li>
<li><code class="codeph">5</code>Ttimestamp (date)</li>
<li><code class="codeph">6</code> Boolean</li>
<li><code class="codeph">7</code> Long integer</li>
<li><code class="codeph">8</code> Short integer</li>
<li><code class="codeph">9</code> Byte</li>
<li><code class="codeph">10</code> Char</li>
<li><code class="codeph">101</code> Serializable Java object</li>
</ul>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7432" headers="d28904e7297">
<p>7</p>
</td>
<td class="cellalignment354" headers="d28904e7432 d28904e7300">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment355" headers="d28904e7432 d28904e7303">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is neither numeric nor timestamp (date)</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7446" headers="d28904e7297">
<p>8</p>
</td>
<td class="cellalignment354" headers="d28904e7446 d28904e7300">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment355" headers="d28904e7446 d28904e7303">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is numeric</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment353" id="d28904e7460" headers="d28904e7297">
<p>9</p>
</td>
<td class="cellalignment354" headers="d28904e7460 d28904e7300">
<p><span class="italic">value</span></p>
</td>
<td class="cellalignment355" headers="d28904e7460 d28904e7303">
<p>The encoded, nonnull value of <span class="italic">key_name</span> when it is a timestamp (date)</p>
<p>Use the Java <code class="codeph">SimpleDateFormat</code> class to identify the format of the date. This example describes the date format of <code class="codeph">2015-03-26Th00:00:00.000-05:00</code>:</p>
<pre dir="ltr">
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'Th'HH:mm:ss.SSSXXX"); encode(sdf.format((java.util.Date) value));
</pre></td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p><span class="bold">Required Grouping of Edges</span>: An edge can have multiple properties, and the edge file includes a record (represented by a single line of text in the flat file) for each combination of an edge ID and a property for that edge. In the edge file, all records for each edge must be grouped together (that is, not have any intervening records for other edges. You can accomplish this any way you want, but a convenient way is to sort the edge file records in ascending (or descending) order by edge ID. (Note, however, an edge file is not required to have all records sorted by edge ID; this is merely one way to achieve the grouping requirement.)</p>
<p>When building an edge file in Oracle flat file format, it is important to verify that the edge property name and value fields are correctly encoded (see especially <a href="using-property-graphs-big-data.htm#GUID-A6950802-B4B6-4698-8513-ED7D05357F9B">Encoding Special Characters</a>). To simplify the encoding, you can use the <code class="codeph">OraclePropertyGraphUtils.escape</code> Java API.</p>
<p>You can use the <code class="codeph">OraclePropertyGraphUtils.outputEdgeRecord(os, eid, svid, dvid, label, key, value)</code> utility method to serialize an edge record directly in Oracle flat file format. With this method, you no longer need to worry about encoding of special characters. The method writes a new line of text in the given output stream describing the <span class="italic">key</span>/<span class="italic">value</span> property of the given edge identified by <span class="italic">eid</span>.</p>
<div class="example" id="GUID-4DB23F3E-FD23-4561-BE64-34A7ED2E732A__USINGORACLEPROPERTYGRAPHUTILS.OUTPU-B99D5FCB">
<p class="titleinexample">Example 5-12 Using OraclePropertyGraphUtils.outputEdgeRecord</p>
<p>This example uses <code class="codeph">OraclePropertyGraphUtils.outputEdgeRecord</code> to write two new lines for edge 100 between vertices 1 and 2 with label <code class="codeph">friendOf</code>.</p>
<pre dir="ltr">
String ope = "./example.ope"; 
OutputStream os = new FileOutputStream(ope);
int sinceYear = 2009;
long eid = 100;
long svid = 1;
long dvid = 2;
OraclePropertyGraphUtils.outputEdgeRecord(os, eid, svid, dvid, "friendOf", "since (year)", sinceYear);
OraclePropertyGraphUtils.outputEdgeRecord(os, eid, svid, dvid, "friendOf", "weight", 1);
os.flush();
os.close();
</pre>
<p>The first line in the generated output file describes the property &ldquo;since (year)" with value 2009, and the second line and the next line sets the edge weight to 1</p>
<pre dir="ltr">
% cat example.ope
100,1,2,friendOf,since%20(year),2,,2009,
100,1,2,friendOf,weight,2,,1,
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDSPA261"></a><a id="BDSPA260"></a>
<div class="props_rev_3"><a id="GUID-A6950802-B4B6-4698-8513-ED7D05357F9B"></a>
<h3 id="BDSPA-GUID-A6950802-B4B6-4698-8513-ED7D05357F9B" class="sect3"><span class="enumeration_section">5.12.4</span> Encoding Special Characters</h3>
<div>
<p>The encoding is UTF-8 for the vertex and edge files. <a href="using-property-graphs-big-data.htm#GUID-A6950802-B4B6-4698-8513-ED7D05357F9B__BHBEFDGC" title="Special character encoding">Table 5-8</a> lists the special characters that must be encoded as strings when they appear in a vertex or edge property (key-value pair) or an edge label. No other characters require encoding.</p>
<div class="tblformal" id="GUID-A6950802-B4B6-4698-8513-ED7D05357F9B__BHBEFDGC">
<p class="titleintable">Table 5-8 Special Character Codes in the Oracle Flat File Format</p>
<table class="cellalignment333" title="Special Character Codes in the Oracle Flat File Format" summary="Special character encoding">
<thead>
<tr class="cellalignment324">
<th class="cellalignment356" id="d28904e7590">Special Character</th>
<th class="cellalignment357" id="d28904e7593">String Encoding</th>
<th class="cellalignment357" id="d28904e7596">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment324">
<td class="cellalignment358" id="d28904e7601" headers="d28904e7590">
<p><code class="codeph">%</code></p>
</td>
<td class="cellalignment359" headers="d28904e7601 d28904e7593">
<p><code class="codeph">%25</code></p>
</td>
<td class="cellalignment359" headers="d28904e7601 d28904e7596">
<p>Percent</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment358" id="d28904e7613" headers="d28904e7590">
<p><code class="codeph">\t</code></p>
</td>
<td class="cellalignment359" headers="d28904e7613 d28904e7593">
<p><code class="codeph">%09</code></p>
</td>
<td class="cellalignment359" headers="d28904e7613 d28904e7596">
<p>Tab</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment358" id="d28904e7625" headers="d28904e7590">&nbsp;</td>
<td class="cellalignment359" headers="d28904e7625 d28904e7593">
<p><code class="codeph">%20</code></p>
</td>
<td class="cellalignment359" headers="d28904e7625 d28904e7596">
<p>Space</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment358" id="d28904e7637" headers="d28904e7590">
<p><code class="codeph">\n</code></p>
</td>
<td class="cellalignment359" headers="d28904e7637 d28904e7593">
<p><code class="codeph">%0A</code></p>
</td>
<td class="cellalignment359" headers="d28904e7637 d28904e7596">
<p>New line</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment358" id="d28904e7649" headers="d28904e7590">
<p><code class="codeph">\r</code></p>
</td>
<td class="cellalignment359" headers="d28904e7649 d28904e7593">
<p><code class="codeph">%0D</code></p>
</td>
<td class="cellalignment359" headers="d28904e7649 d28904e7596">
<p>Return</p>
</td>
</tr>
<tr class="cellalignment324">
<td class="cellalignment358" id="d28904e7661" headers="d28904e7590">
<p><code class="codeph">,</code></p>
</td>
<td class="cellalignment359" headers="d28904e7661 d28904e7593">
<p><code class="codeph">%2C</code></p>
</td>
<td class="cellalignment359" headers="d28904e7661 d28904e7596">
<p>Comma</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
<a id="BDSPA262"></a>
<div class="props_rev_3"><a id="GUID-A5A1666F-53CF-41DE-A814-1C70F44E70ED"></a>
<h3 id="BDSPA-GUID-A5A1666F-53CF-41DE-A814-1C70F44E70ED" class="sect3"><span class="enumeration_section">5.12.5</span> Example Property Graph in Oracle Flat File Format</h3>
<div>
<p>An example property graph in Oracle flat file format is as follows. In this example, there are two vertices (John and Mary), and a single edge denoting that John is a friend of Mary.</p>
<pre dir="ltr">
%cat simple.opv
1,age,2,,10,
1,name,1,John,,
2,name,1,Mary,,
2,hobby,1,soccer,,
 
%cat simple.ope
100,1,2,friendOf,%20,,,,
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B"></a>
<h3 id="BDSPA-GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B" class="sect3"><span class="enumeration_section">5.12.6</span> Converting an Oracle Database Table to an Oracle-Defined Property Graph Flat File</h3>
<div>
<p>You can convert Oracle Database tables that represent the vertices and edges of a graph into an Oracle-defined flat file format (<code class="codeph">.opv</code> and <code class="codeph">.ope</code> file extensions).</p>
<p>If you have graph data stored in Oracle Database tables, you can use Java API methods to convert that data into flat files, and later load the tables into Oracle Database as a property graph. This eliminates the need to take some other manual approach to generating the flat files from existing Oracle Database tables.</p>
<div class="section">
<p class="subhead3"><span class="bold">Converting a Table Storing Graph Vertices to an .opv File</span></p>
<p>You can convert an Oracle Database table that contains entities (that can be represented as vertices of a graph) to a property graph flat file in <code class="codeph">.opv</code> format.</p>
<p>For example, assume the following relational table: <code class="codeph">EmployeeTab (empID integer not null, hasName varchar(255), hasAge integer, hasSalary number)</code></p>
<p>Assume that this table has the following data:</p>
<pre dir="ltr">
101, Jean, 20, 120.0
102, Mary, 21, 50.0
103, Jack, 22, 110.0
&hellip;&hellip;
</pre>
<p>Each employee can be viewed as a vertex in the graph. The vertex ID could be the value of employeeID or an ID generated using some heuristics like hashing. The columns hasName, hasAge, and hasSalary can be viewed as attributes.</p>
<p>The Java method <code class="codeph">OraclePropertyGraphUtils.convertRDBMSTable2OP<span class="bold">V</span></code> and its Javadoc information are as follows:</p>
<pre dir="ltr">
/**
* conn: is an connect instance to the Oracle relational database
* rdbmsTableName: name of the RDBMS table to be converted
* vidColName is the name of an column in RDBMS table to be treated as vertex ID
* lVIDOffset is the offset will be applied to the vertex ID
* ctams defines how to map columns in the RDBMS table to the attributes
* dop degree of parallelism
* dcl an instance of DataConverterListener to report the progress and control the behavior when errors happen 
*/
OraclePropertyGraphUtils.convertRDBMSTable2OPV(
       Connection conn, 
       String rdbmsTableName, 
       String vidColName, 
       long lVIDOffset, 
       ColumnToAttrMapping[] ctams, 
       int dop, 
       OutputStream opvOS, 
       DataConverterListener dcl);
</pre>
<p>The following code snippet converts this table into an Oracle-defined vertex file (<code class="codeph">.opv</code>):</p>
<pre dir="ltr">
// location of the output file
String opv = "./EmployeeTab.opv"; 
OutputStream opvOS = new FileOutputStream(opv);
// an array of ColumnToAttrMapping objects; each object defines how to map a column in the RDBMS table to an attribute of the vertex in an Oracle Property Graph.
ColumnToAttrMapping[] ctams = new ColumnToAttrMapping[3];
// map column "hasName" to attribute "name" of type String
ctams[0] = ColumnToAttrMapping.getInstance("hasName", "name", String.class);
// map column "hasAge" to attribute "age" of type Integer
ctams[1] = ColumnToAttrMapping.getInstance("hasAge", "age", Integer.class);
// map column "hasSalary" to attribute "salary" of type Double
ctams[2] = ColumnToAttrMapping.getInstance("hasSalary", "salary",Double.class);
// convert RDBMS table "EmployeeTab" into opv file "./EmployeeTab.opv", column "empID" is the vertex ID column, offset 1000l will be applied to vertex ID, use ctams to map RDBMS columns to attributes, set DOP to 8
OraclePropertyGraphUtils.convertRDBMSTable2OPV(conn, "EmployeeTab", "empID", 1000l, ctams, 8, opvOS, (DataConverterListener) null);
</pre>
<div class="infobox-note" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-EFB41B19-4333-4E77-85C4-7C7737E9CD66">
<p class="notep1">Note:</p>
<p>The lowercase letter "l" as the last character in the offset value <code class="codeph">1000l</code> denotes that the value before it is a long integer.</p>
</div>
<p>The conversion result is as follows:</p>
<pre dir="ltr">
1101,name,1,Jean,,
1101,age,2,,20,
1101,salary,4,,120.0,
1102,name,1,Mary,,
1102,age,2,,21,
1102,salary,4,,50.0,
1103,name,1,Jack,,
1103,age,2,,22,
1103,salary,4,,110.0,
</pre>
<p>In this case, each row in table EmployeeTab is converted to one vertex with three attributes. For example, the row with data "101, Jean, 20, 120.0" is converted to a vertex with ID 1101 with attributes name/"Jean", age/20, salary/120.0. There is an offset between original empID 101 and vertex ID 1101 because an offset 1000l is applied. An offset is useful to avoid collision in ID values of graph elements.</p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3"><span class="bold">Converting a Table Storing Graph Edges to an .ope File</span></p>
<p>You can convert an Oracle Database table that contains entity relationships (that can be represented as edges of a graph) to a property graph flat filein <code class="codeph">.ope</code> format.</p>
<p>For example, assume the following relational table: <code class="codeph">EmpRelationTab (relationID integer not null, source integer not null, destination integer not null, relationType varchar(255), startDate date)</code></p>
<p>Assume that this table has the following data:</p>
<pre dir="ltr">
90001, 101, 102, manage, 10-May-2015
90002, 101, 103, manage, 11-Jan-2015
90003, 102, 103, colleague, 11-Jan-2015
&hellip;&hellip;
</pre>
<p>Each relation (row) can be viewed as an edge in a graph. Specifically, edge ID could be the same as relationID or an ID generated using some heuristics like hashing. The column relationType can be used to define edge labels, and the column startDate can be treated as an edge attribute.</p>
<p>The Java method <code class="codeph">OraclePropertyGraphUtils.convertRDBMSTable2OP<span class="bold">E</span></code> and its Javadoc information are as follows:</p>
<pre dir="ltr">
/**
* conn: is an connect instance to the Oracle relational database
* rdbmsTableName: name of the RDBMS table to be converted
* eidColName is the name of an column in RDBMS table to be treated as edge ID
* lEIDOffset is the offset will be applied to the edge ID
* svidColName is the name of an column in RDBMS table to be treated as source vertex ID of the edge
* dvidColName is the name of an column in RDBMS table to be treated as destination vertex ID of the edge
* lVIDOffset is the offset will be applied to the vertex ID
* bHasEdgeLabelCol a Boolean flag represents if the given RDBMS table has a column for edge labels; if true, use value of column elColName as the edge label; otherwise, use the constant string elColName as the edge label
* elColName is the name of an column in RDBMS table to be treated as edge labels
* ctams defines how to map columns in the RDBMS table to the attributes
* dop degree of parallelism
* dcl an instance of DataConverterListener to report the progress and control the behavior when errors happen 
*/
OraclePropertyGraphUtils.convertRDBMSTable2OPE(
        Connection conn, 
        String rdbmsTableName, 
        String eidColName, 
        long lEIDOffset, 
        String svidColName, 
        String dvidColName, 
        long lVIDOffset, 
        boolean bHasEdgeLabelCol, 
        String elColName, 
        ColumnToAttrMapping[] ctams, 
        int dop, 
        OutputStream opeOS, 
        DataConverterListener dcl);
</pre>
<p>The following code snippet converts this table into an Oracle-defined edge file (<code class="codeph">.ope</code>):</p>
<pre dir="ltr">
// location of the output file
String ope = "./EmpRelationTab.ope"; 
OutputStream opeOS = new FileOutputStream(ope);
// an array of ColumnToAttrMapping objects; each object defines how to map a column in the RDBMS table to an attribute of the edge in an Oracle Property Graph.
ColumnToAttrMapping[] ctams = new ColumnToAttrMapping[1];
// map column "startDate" to attribute "since" of type Date
ctams[0] = ColumnToAttrMapping.getInstance(&ldquo;startDate", &ldquo;since",Date.class);
// convert RDBMS table &ldquo;EmpRelationTab" into ope file &ldquo;./EmpRelationTab.opv", column &ldquo;relationID" is the edge ID column, offset 10000l will be applied to edge ID, the source and destination vertices of the edge are defined by columns &ldquo;source" and &ldquo;destination", offset 1000l will be applied to vertex ID, the RDBMS table has an column &ldquo;relationType" to be treated as edge labels, use ctams to map RDBMS columns to edge attributes, set DOP to 8
OraclePropertyGraphUtils.convertRDBMSTable2OPE(conn, &ldquo;EmpRelationTab", &ldquo;relationID", 10000l, &ldquo;source", &ldquo;destination", 1000l, true, &ldquo;relationType", ctams, 8, opeOS, (DataConverterListener) null);
</pre>
<div class="infobox-note" id="GUID-EFA9E4E7-F854-4224-8828-F8843DE91D8B__GUID-29C25198-B41F-4595-9EBB-0045D2DBA5BC">
<p class="notep1">Note:</p>
<p>The lowercase letter &ldquo;l" as the last character in the offset value <code class="codeph">10000l</code> denotes that the value before it is a long integer.</p>
</div>
<p>The conversion result is as follows:</p>
<pre dir="ltr">
100001,1101,1102,manage,since,5,,,2015-05-10T00:00:00.000-07:00
100002,1101,1103,manage,since,5,,,2015-01-11T00:00:00.000-07:00
100003,1102,1103,colleague,since,5,,,2015-01-11T00:00:00.000-07:00
</pre>
<p>In this case, each row in table EmpRelationTab is converted to a distinct edge with the attribute <code class="codeph">since</code>. For example, the row with data &ldquo;90001, 101, 102, manage, 10-May-2015" is converted to an edge with ID 100001 linking vertex 1101 to vertex 1102. This edge has attribute since/&ldquo;2015-05-10T00:00:00.000-07:00". There is an offset between original relationID &ldquo;90001" and edge ID &ldquo;100001" because an offset 10000l is applied. Similarly, an offset 1000l is applied to the source and destination vertex IDs.</p>
</div>
<!-- class="section" --></div>
</div>
<div class="props_rev_3"><a id="GUID-C20DE69B-322D-4FBE-B132-507C784F4581"></a>
<h3 id="BDSPA-GUID-C20DE69B-322D-4FBE-B132-507C784F4581" class="sect3"><span class="enumeration_section">5.12.7</span> Converting CSV Files for Vertices and Edges to Oracle-Defined Property Graph Flat Files</h3>
<div>
<p>Some applications use CSV (comma-separated value) format to encode vertices and edges of a graph. In this format, each record of the CSV file represents a single vertex or edge, with all its properties. You can convert a CSV file representing the vertices of a graph to Oracle-defined flat file format definition (<code class="codeph">.opv</code> for vertices, <code class="codeph">.ope</code> for edges).</p>
<p>The CSV file to be converted may include a header line specifying the column name and the type of the attribute that the column represents. If the header includes only the attribute names, then the converter will assume that the data type of the values will be String.</p>
<p>The Java APIs to convert CSV to OPV or OPE receive an <code class="codeph">InputStream</code> from which they read the vertices or edges (from CSV), and write them in the <code class="codeph">.opv</code> or <code class="codeph">.ope</code> format to an <code class="codeph">OutputStream</code>. The converter APIs also allow customization of the conversion process.</p>
<p>The following subtopics provide instructions for converting vertices and edges. The instructions for the first two are very similar, but with differences specific to vertices and edges.</p>
</div>
<div>
<ul class="ullinks">
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-FDF10DEC-5B03-4CFF-8E60-E8E04C29F297">Vertices: Converting a CSV File to Oracle-Defined Flat File Format (.opv)</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-42E0EDFA-D87C-42A8-A21E-C24821FD1CDB">Edges: Converting a CSV File to Oracle-Defined Flat File Format (.ope)</a><br /></li>
<li class="ulchildlink"><a href="using-property-graphs-big-data.htm#GUID-DA6B1A39-DAB7-4BC9-B0C4-4DBBA4E2E395">Vertices and Edges: Converting a Single CSV File Containing Both Vertices and Edges Data into a Pair of Graph Flat Files</a><br /></li>
</ul>
</div>
<div class="props_rev_3"><a id="GUID-FDF10DEC-5B03-4CFF-8E60-E8E04C29F297"></a>
<h4 id="BDSPA-GUID-FDF10DEC-5B03-4CFF-8E60-E8E04C29F297" class="sect4"><span class="enumeration_section">5.12.7.1</span> Vertices: Converting a CSV File to Oracle-Defined Flat File Format (.opv)</h4>
<div>
<p>If the CSV file does not include a header, you must specify a <code class="codeph">ColumnToAttrMapping</code> array describing all the attribute names (mapped to its values data types) in the same order in which they appear in the CSV file. Additionally, the entire columns from the CSV file must be described in the array, including special columns such as the ID for the vertices. If you want to specify the headers for the column in the first line of the same CSV file, then this parameter must be set to null.</p>
<p>To convert a CSV file representing vertices, you can use one of the <code class="codeph">convertCSV2OPV</code> APIs. The simplest of these APIs requires:</p>
<ul style="list-style-type: disc;">
<li>
<p>An <code class="codeph">InputStream</code> to read vertices from a CSV file</p>
</li>
<li>
<p>The name of the column that is representing the vertex ID (this column must appear in the CSV file)</p>
</li>
<li>
<p>An integer offset to add to the VID (an offset is useful to avoid collision in ID values of graph elements)</p>
</li>
<li>
<p>A <code class="codeph">ColumnToAttrMapping</code> array (which must be null if the headers are specified in the file)</p>
</li>
<li>
<p>Degree of parallelism (DOP)</p>
</li>
<li>
<p>An integer denoting offset (number of vertex records to skip) before converting</p>
</li>
<li>
<p>An <code class="codeph">OutputStream</code> in which the vertex flat file (.opv) will be written</p>
</li>
<li>
<p>An optional <code class="codeph">DataConverterListener</code> that can be used to keep track of the conversion progress and decide what to do if an error occurs</p>
</li>
</ul>
<p>Additional parameters can be used to specify a different format of the CSV file:</p>
<ul style="list-style-type: disc;">
<li>
<p>The delimiter character, which is used to separate tokens in a record. The default is the comma character ',&rsquo;.</p>
</li>
<li>
<p>The quotation character, which is used to quote String values so they can contain special characters, for example, commas. If a quotation character appears in the value of the String itself, it must be escaped either by duplication or by placing a backslash character '\' before it. Some examples are:</p>
<ul style="list-style-type: disc;">
<li>
<p>"""Hello, world"", the screen showed&hellip;"</p>
</li>
<li>
<p>"But Vader replied: \"No, I am your father.\""</p>
</li>
</ul>
</li>
<li>
<p>The Date format, which will be used to parse the date values. For the CSV conversion, this parameter can be null, but it is recommended to be specified if the CSV has a specific date format. Providing a specific date format helps performance, because that format will be used as the first option when trying to parse date values. Some example date formats are:</p>
<ul style="list-style-type: disc;">
<li>
<p>"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</p>
</li>
<li>
<p>"MM/dd/yyyy HH:mm:ss"</p>
</li>
<li>
<p>"ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"</p>
</li>
<li>
<p>"dddd, dd MMMM yyyy hh:mm:ss"</p>
</li>
<li>
<p>"yyyy-MM-dd"</p>
</li>
<li>
<p>"MM/dd/yyyy"</p>
</li>
</ul>
</li>
<li>
<p>A flag indicating if the CSV file contains String values with new line characters. If this parameter is set to true, all the Strings in the file that contain new lines or quotation characters as values must be quoted.</p>
<ul style="list-style-type: disc;">
<li>
<p>"The first lines of Don Quixote are:""In a village of La Mancha, the name of which I have no desire to call to mind""."</p>
</li>
</ul>
</li>
</ul>
<p>The following code fragment shows how to create a&nbsp;<code class="codeph">ColumnToAttrMapping</code> array and use the API to convert a CSV file into an <code class="codeph">.opv</code> file.</p>
<pre dir="ltr">
    String inputCSV             = "/path/mygraph-vertices.csv";
    String outputOPV            = "/path/mygraph.opv"; 
    ColumnToAttrMapping[] ctams = new ColumnToAttrMapping[4];
    ctams[0]                    = ColumnToAttrMapping.getInstance("VID",   Long.class);
    ctams[1]                    = ColumnToAttrMapping.getInstance("name",  String.class);
    ctams[2]                    = ColumnToAttrMapping.getInstance("score", Double.class);
    ctams[3]                    = ColumnToAttrMapping.getInstance("age",   Integer.class);
    String vidColumn            = "VID";

    isCSV = new FileInputStream(inputCSV);
    osOPV = new FileOutputStream(new File(outputOPV));
      
    // Convert Vertices
    OraclePropertyGraphUtilsBase.convertCSV2OPV(isCSV, vidColumn, 0, ctams, 1, 0, osOPV, null);
    isOPV.close();
    osOPV.close();
</pre>
<p>In this example, the CSV file to be converted must not include the header and contain four columns (the vertex ID, name, score, and age). An example CVS is as follows:</p>
<pre dir="ltr">
1,John,4.2,30
2,Mary,4.3,32
3,"Skywalker, Anakin",5.0,46
4,"Darth Vader",5.0,46
5,"Skywalker, Luke",5.0,53
</pre>
<p>The resulting <code class="codeph">.opv</code> file is as follows:</p>
<pre dir="ltr">
1,name,1,John,,
1,score,4,,4.2,
1,age,2,,30,
2,name,1,Mary,,
2,score,4,,4.3,
2,age,2,,32,
3,name,1,Skywalker%2C%20Anakin,,
3,score,4,,5.0,
3,age,2,,46,
4,name,1,Darth%20Vader,,
4,score,4,,5.0,
4,age,2,,46,
5,name,1,Skywalker%2C%20Luke,,
5,score,4,,5.0,
5,age,2,,53,
</pre>
<p><span class="bold">Another way to convert a CSV file containing vertices data</span> is to use the <code class="codeph">convertCSV2OPV</code> APIs that take a <code class="codeph">CSV2OPVConfig</code> object as one of the following input arguments:</p>
<ul style="list-style-type: disc;">
<li>
<p>An <code class="codeph">InputStream</code> to read vertices from a CSV file</p>
</li>
<li>
<p>A <code class="codeph">CSV2OPVConfig</code> object that specifies the configuration</p>
</li>
<li>
<p>An <code class="codeph">OutputStream</code> to write the vertex flat file (.opv) to</p>
</li>
</ul>
<p>The <code class="codeph">CSV2OPVConfig</code> class has different members, which can be set according to the desired tuning; this is equivalent to call the <code class="codeph">convertCSV2OPV</code> API with all the different configuration parameters.</p>
<p>The following code fragment shows how to create a&nbsp;<code class="codeph">CSV2OPVConfig</code> object and use the API to convert a CSV file into an <code class="codeph">.opv</code> file.</p>
<pre dir="ltr">
    String inputCSV             = "/path/mygraph-vertices.csv";
    String outputOPV            = "/path/mygraph.opv"; 

    ColumnToAttrMapping[] ctams = new ColumnToAttrMapping[4];
    ctams[0]                    = ColumnToAttrMapping.getInstance("VID",   Long.class);
    ctams[1]                    = ColumnToAttrMapping.getInstance("name",  String.class);
    ctams[2]                    = ColumnToAttrMapping.getInstance("score", Double.class);
    ctams[3]                    = ColumnToAttrMapping.getInstance("age",   Integer.class);

    InputStream isCSV = new FileInputStream(inputCSV);
    OutputStream osOPV = new FileOutputStream(new File(outputOPV));
    CSV2OPVConfig config = (CSV2OPVConfig) new CSV2OPVConfig()
    .setVidColumnName("VID")
    .setCtams(ctams)
    .setAllowExtraFields(false)
    .setDelimiterChar(',')
    .setQuotationChar('"');
    
    // Convert vertices
    OraclePropertyGraphCSVConverter.convertCSV2OPV(isCSV, config, osOPV);
    isCSV.close();
    osOPV.close();
</pre>
<p>If the <code class="codeph">CSV2OPVConfig</code> includes a <code class="codeph">ColumnToAttrMapping</code> array, then the input CSV must not include a header, because the mappings have already been defined in the <code class="codeph">ColumnToAttrMapping</code> array. Additionally, because the <code class="codeph">setAllowExtraFields</code> flag is set to <code class="codeph">false</code> in the <code class="codeph">CSV2OPVConfig</code>, the number of columns in the CSV file must match the length of the <code class="codeph">ColumnToAttrMapping</code> array (in the example, one for the vertex ID, the second one for name, third one for score, and the last one for age). An example CSV is:</p>
<pre dir="ltr">
1,John,4.2,30
2,Mary,4.3,32
3,"Skywalker, Anakin",5.0,46
4,"Darth Vader",5.0,46
5,"Skywalker, Luke",5.0,53
</pre>
<p>The resulting <code class="codeph">.opv</code> file is as follows:</p>
<pre dir="ltr">
1,name,1,John,,
1,score,4,,4.2,
1,age,2,,30,
2,name,1,Mary,,
2,score,4,,4.3,
2,age,2,,32,
3,name,1,Skywalker%2C%20Anakin,,
3,score,4,,5.0,
3,age,2,,46,
4,name,1,Darth%20Vader,,
4,score,4,,5.0,
4,age,2,,46,
5,name,1,Skywalker%2C%20Luke,,
5,score,4,,5.0,
5,age,2,,53,
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-42E0EDFA-D87C-42A8-A21E-C24821FD1CDB"></a>
<h4 id="BDSPA-GUID-42E0EDFA-D87C-42A8-A21E-C24821FD1CDB" class="sect4"><span class="enumeration_section">5.12.7.2</span> Edges: Converting a CSV File to Oracle-Defined Flat File Format (.ope)</h4>
<div>
<p>If the CSV file does not include a header, you must specify a <code class="codeph">ColumnToAttrMapping</code> array describing all the attribute names (mapped to its values data types) in the same order in which they appear in the CSV file. Additionally, the entire columns from the CSV file must be described in the array, including special columns such as the ID for the edges if it applies, and the START_ID, END_ID, and TYPE, which are required. If you want to specify the headers for the column in the first line of the same CSV file, then this parameter must be set to null.</p>
<p>To convert a CSV file representing vertices, you can use one of the <code class="codeph">convertCSV2OPE</code> APIs. The simplest of these APIs requires:</p>
<ul style="list-style-type: disc;">
<li>
<p>An <code class="codeph">InputStream</code> to read vertices from a CSV file</p>
</li>
<li>
<p>The name of the column that is representing the edge ID (this is optional in the CSV file; if it is not present, the line number will be used as the ID)</p>
</li>
<li>
<p>An integer offset to add to the EID (an offset is useful to avoid collision in ID values of graph elements)</p>
</li>
<li>
<p>Name of the column that is representing the source vertex ID (this column must appear in the CSV file)</p>
</li>
<li>
<p>Name of the column that is representing the destination vertex ID (this column must appear in the CSV file)</p>
</li>
<li>
<p>Offset to the VID (<code class="codeph">lOffsetVID</code>). This offset will be added on top of the original SVID and DVID values. (A variation of this API takes in two arguments (<code class="codeph">lOffsetSVID</code> and <code class="codeph">lOffsetDVID</code>): one offset for SVID, the other offset for DVID.)</p>
</li>
<li>
<p>A boolean flag indicating if the edge label column is present in the CSV file.</p>
</li>
<li>
<p>Name of the column that is representing the edge label (if this column is not present in the CSV file, then this parameter will be used as a constant for all edge labels)</p>
</li>
<li>
<p>A <code class="codeph">ColumnToAttrMapping</code> array (which must be null if the headers are specified in the file)</p>
</li>
<li>
<p>Degree of parallelism (DOP)</p>
</li>
<li>
<p>An integer denoting offset (number of edge records to skip) before converting</p>
</li>
<li>
<p>An <code class="codeph">OutputStream</code> in which the edge flat file (.ope) will be written</p>
</li>
<li>
<p>An optional <code class="codeph">DataConverterListener</code> that can be used to keep track of the conversion progress and decide what to do if an error occurs.</p>
</li>
</ul>
<p>Additional parameters can be used to specify a different format of the CSV file:</p>
<ul style="list-style-type: disc;">
<li>
<p>The delimiter character, which is used to separate tokens in a record. The default is the comma character ',&rsquo;.</p>
</li>
<li>
<p>The quotation character, which is used to quote String values so they can contain special characters, for example, commas. If a quotation character appears in the value of the String itself, it must be escaped either by duplication or by placing a backslash character '\' before it. Some examples are:</p>
<ul style="list-style-type: disc;">
<li>
<p>"""Hello, world"", the screen showed&hellip;"</p>
</li>
<li>
<p>"But Vader replied: \"No, I am your father.\""</p>
</li>
</ul>
</li>
<li>
<p>The Date format, which will be used to parse the date values. For the CSV conversion, this parameter can be null, but it is recommended to be specified if the CSV has a specific date format. Providing a specific date format helps performance, because that format will be used as the first option when trying to parse date values. Some example date formats are:</p>
<ul style="list-style-type: disc;">
<li>
<p>"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</p>
</li>
<li>
<p>"MM/dd/yyyy HH:mm:ss"</p>
</li>
<li>
<p>"ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"</p>
</li>
<li>
<p>"dddd, dd MMMM yyyy hh:mm:ss"</p>
</li>
<li>
<p>"yyyy-MM-dd"</p>
</li>
<li>
<p>"MM/dd/yyyy"</p>
</li>
</ul>
</li>
<li>
<p>A flag indicating if the CSV file contains String values with new line characters. If this parameter is set to true, all the Strings in the file that contain new lines or quotation characters as values must be quoted.</p>
<ul style="list-style-type: disc;">
<li>
<p>"The first lines of Don Quixote are:""In a village of La Mancha, the name of which I have no desire to call to mind""."</p>
</li>
</ul>
</li>
</ul>
<p>The following code fragment shows how to use the API to convert a CSV file into an <code class="codeph">.ope</code> file with a null&nbsp;<code class="codeph">ColumnToAttrMapping</code> array.</p>
<pre dir="ltr">
    String inputOPE    = "/path/mygraph-edges.csv";
    String outputOPE   = "/path/mygraph.ope"; 
    String eidColumn   = null;             // null implies that an integer sequence will be used
    String svidColumn  = "START_ID";
    String dvidColumn  = "END_ID";
    boolean hasLabel   = true;
    String labelColumn = "TYPE";

    isOPE = new FileInputStream(inputOPE);
    osOPE = new FileOutputStream(new File(outputOPE));
      
    // Convert Edges
    OraclePropertyGraphUtilsBase.convertCSV2OPE(isOPE, eidColumn, 0, svidColumn, dvidColumn, hasLabel, labelColumn, null, 1, 0, osOPE, null);
</pre>
<p>An input CSV that uses the former example to be converted should include the header specifying the columns name and their type. An example CSV file is as follows.</p>
<pre dir="ltr">
START_ID:long,weight:float,END_ID:long,:TYPE
1,1.0,2,loves
1,1.0,5,admires
2,0.9,1,loves
1,0.5,3,likes
2,0.0,4,likes
4,1.0,5,is the dad of
3,1.0,4,turns to
5,1.0,3,saves from the dark side
</pre>
<p>The resulting .ope file is as follows.</p>
<pre dir="ltr">
1,1,2,loves,weight,3,,1.0,
2,1,5,admires,weight,3,,1.0,
3,2,1,loves,weight,3,,0.9,
4,1,3,likes,weight,3,,0.5,
5,2,4,likes,weight,3,,0.0,
6,4,5,is%20the%20dad%20of,weight,3,,1.0,
7,3,4,turns%20to,weight,3,,1.0,
8,5,3,saves%20from%20the%20dark%20side,weight,3,,1.0,
</pre>
<p><span class="bold">Another way to convert a CSV file containing edges data</span> is to use the <code class="codeph">convertCSV2OPE</code> APIs that take a <code class="codeph">CSV2OPEConfig</code> object as one of the following input arguments:</p>
<ul style="list-style-type: disc;">
<li>
<p>An <code class="codeph">InputStream</code> to read edges from a CSV file</p>
</li>
<li>
<p>A <code class="codeph">CSV2OPVConfig</code> object that specifies the configuration</p>
</li>
<li>
<p>An <code class="codeph">OutputStream</code> to write the edge flat file (.opv) to</p>
</li>
</ul>
<p>The <code class="codeph">CSV2OPEConfig</code> class has different members, which can be set according to the desired tuning; this is equivalent to call the <code class="codeph">convertCSV2OPE</code> API with all the different configuration parameters.</p>
<p>The following code fragment shows how to create a&nbsp;<code class="codeph">CSV2OPEConfig</code> object and use the API to convert a CSV file into an <code class="codeph">.ope</code> file.</p>
<pre dir="ltr">
    String inputOPE    = "/path/mygraph-edges.csv";
    String outputOPE   = "/path/mygraph.ope"; 
    String eidColumn   = null;             // null implies that an integer sequence will be used
    String svidColumn  = "START_ID";
    String dvidColumn  = "END_ID";
    boolean hasLabel   = true;
    String labelColumn = "TYPE";

    InputStream isCSV = new FileInputStream(inputOPE);
    OutputStream osOPE = new FileOutputStream(new File(outputOPE));
     CSV2OPEConfig config = (CSV2OPEConfig) new CSV2OPEConfig()
    .setEidColumnName(eidColumn)
    .setSvidColumnName(svidColumn)
    .setDvidColumnName(dvidColumn)
    .setHasEdgeLabelColumn(hasLabel)
    .setElColumnName(labelColumn)
    .setCtams(null)
    .setDelimiterChar(',')
    .setQuotationChar('"');

    // Convert Edges
    OraclePropertyGraphCSVConverter.convertCSV2OPE(isCSV, config, osOPE);
    isCSV.close();
    osOPE.close();
</pre>
<p>If the <code class="codeph">CSV2OPEConfig</code> does not include a <code class="codeph">ColumnToAttrMapping</code> array or if this array is set to null, then the input CSV must include a header specifying the column names and data type. An example CSV file is:</p>
<pre dir="ltr">
START_ID:long,weight:float,END_ID:long,:TYPE
1,1.0,2,loves
1,1.0,5,admires
2,0.9,1,loves
1,0.5,3,likes
2,0.0,4,likes
4,1.0,5,is the dad of
3,1.0,4,turns to
5,1.0,3,saves from the dark side
</pre>
<p>The resulting <code class="codeph">.ope</code> file is as follows:</p>
<pre dir="ltr">
1,1,2,loves,weight,3,,1.0,
2,1,5,admires,weight,3,,1.0,
3,2,1,loves,weight,3,,0.9,
4,1,3,likes,weight,3,,0.5,
5,2,4,likes,weight,3,,0.0,
6,4,5,is%20the%20dad%20of,weight,3,,1.0,
7,3,4,turns%20to,weight,3,,1.0,
8,5,3,saves%20from%20the%20dark%20side,weight,3,,1.0,
</pre></div>
</div>
<div class="props_rev_3"><a id="GUID-DA6B1A39-DAB7-4BC9-B0C4-4DBBA4E2E395"></a>
<h4 id="BDSPA-GUID-DA6B1A39-DAB7-4BC9-B0C4-4DBBA4E2E395" class="sect4"><span class="enumeration_section">5.12.7.3</span> Vertices and Edges: Converting a Single CSV File Containing Both Vertices and Edges Data into a Pair of Graph Flat Files</h4>
<div>
<p>The property graph support also provides an option to convert a single CSV file containing both vertices and edges data, into a pair of graph flat files. One can use the convertCSV2OPG APIs to make this conversion and the input parameters are as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>An <code class="codeph">InputStream</code> to read vertices and edges from a CSV file</p>
</li>
<li>
<p>A <code class="codeph">CSV2OPGConfig</code> object that specifies the configuration</p>
</li>
<li>
<p>An <code class="codeph">OutputStream</code> to write the vertex flat file (<code class="codeph">.opv</code>) to</p>
</li>
<li>
<p>An <code class="codeph">OutputStream</code> to write the edge flat file (<code class="codeph">.ope</code>) to</p>
</li>
</ul>
<p>The following code fragment shows how to create a&nbsp;<code class="codeph">CSV2OPGConfig</code> object and use the API to convert a single CSV file into <code class="codeph">.opv</code> and <code class="codeph">.ope</code> files.</p>
<pre dir="ltr">
    String inputCSV    = "/path/mygraph.csv";
    String outputOPV   = "/path/mygraph.opv"; 
    String outputOPE   = "/path/mygraph.ope"; 

    String eidColumn   = null;             // null implies that an integer sequence will be used
    String svidColumn  = "START_ID";
    String dvidColumn  = "END_ID";
    boolean hasLabel   = true;
    String labelColumn = "TYPE";

    String[] vertexNames = new String [2];
    vertexNames[0] = svidColumn;
    vertexNames[1] = dvidColumn;

    InputStream isCSV = new FileInputStream(inputOPE);
    OutputStream osOPV = new FileOutputStream(new File(outputOPV));
    OutputStream osOPE = new FileOutputStream(new File(outputOPE));

     CSV2OPGConfig config = (CSV2OPGConfig) new CSV2OPGConfig()
    .setVidColumnNames(vertexNames)
    .setKeepOriginalID(true)
    .setOriginalIDName("myId")
    .setEidColumnName(eidColumn)
    .setSvidColumnName(svidColumn)
    .setDvidColumnName(dvidColumn)
    .setHasEdgeLabelColumn(hasLabel)
    .setElColumnName(labelColumn)
    .setCtams(null)
    .setDelimiterChar(',')
    .setQuotationChar('"');

    // Convert Graph
    OraclePropertyGraphCSVConverter.convertCSV2OPG(isCSV, config, osOPV, osOPE);
    isCSV.close();
    osOPV.close();
    osOPE.close();
</pre>
<p>If the <code class="codeph">CSV2OPEConfig</code> does not include a <code class="codeph">ColumnToAttrMapping</code> array or this array is set to null, then the input CSV must include a header specifying the column names and data type. An example CSV file is:</p>
<pre dir="ltr">
START_ID:long,weight:float,END_ID:long,:TYPE
John,1.0,Mary,loves
John,1.0,"Skywalker, Luke",admires
Mary,0.9,John,loves
John,0.5,"Skywalker, Anakin",likes
Mary,0.0,"Darth Vader",likes
"Darth Vader",1.0,"Skywalker, Luke",is the dad of
"Skywalker, Anakin",1.0,"Darth Vader",turns to
"Skywalker, Luke",1.0,"Skywalker, Anakin",saves from the dark side
</pre>
<p>The resulting .<code class="codeph">opv</code> file is as follows:</p>
<pre dir="ltr">
-4984830045544402721,myId,1,John,,
6010046165116255926,myId,1,Mary,,
-5861570303285508288,myId,1,Skywalker%2C%20Anakin,,
-6450119557041804291,myId,1,Darth%20Vader,,
3941046021651468440,myId,1,Skywalker%2C%20Luke,,
</pre>
<p>The resulting .<code class="codeph">ope</code> file is as follows:</p>
<pre dir="ltr">
1,-4984830045544402721,6010046165116255926,loves,weight,3,,1.0,
2,-4984830045544402721,3941046021651468440,admires,weight,3,,1.0,
3,6010046165116255926,-4984830045544402721,loves,weight,3,,0.9,
4,-4984830045544402721,-5861570303285508288,likes,weight,3,,0.5,
5,6010046165116255926,-6450119557041804291,likes,weight,3,,0.0,
6,-6450119557041804291,3941046021651468440,is%20the%20dad%20of,weight,3,,1.0,
7,-5861570303285508288,-6450119557041804291,turns%20to,weight,3,,1.0,
8, 3941046021651468440,-5861570303285508288,saves%20from%20the%20dark%20side,weight,3,,1.0,
</pre></div>
</div>
</div>
</div>
<a id="BDSPA263"></a>
<div class="props_rev_3"><a id="GUID-F363808E-6416-4B2D-AFE6-49B9C91B9EED"></a>
<h2 id="BDSPA-GUID-F363808E-6416-4B2D-AFE6-49B9C91B9EED" class="sect2"><span class="enumeration_section">5.13</span> Example Python User Interface</h2>
<div>
<p>The Oracle Big Data Spatial and Graph support for property graphs includes an example Python user interface. It can invoke a set of example Python scripts and modules that perform a variety of property graph operations.</p>
<p>Instructions for installing the example Python user interface are in the <code class="codeph">/property_graph/examples/pyopg/README</code> file under the installation home (<code class="codeph">/opt/oracle/oracle-spatial-graph</code> by default).</p>
<p>The example Python scripts in <code class="codeph">/property_graph/examples/pyopg/</code> can used with Oracle Spatial and Graph Property Graph, and you may want to change and enhance them (or copies of them) to suit your needs.</p>
<p>To invoke the user interface to run the examples, use the script <code class="codeph">pyopg.sh</code>.</p>
<p>The examples include the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>Example 1: Connect to an Oracle NoSQL Database and perform a simple check of number of vertices and edges. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectONDB("mygraph", "kvstore", "localhost:5000")
print "vertices", countV()
print "edges", countE()
</pre>
<p>In the preceding example, <code class="codeph">mygraph</code> is the name of the graph stored in the Oracle NoSQL Database, <code class="codeph">kvstore</code> and <code class="codeph">localhost:5000</code> are the connection information to access the Oracle NoSQL Database. They must be customized for your environment.</p>
</li>
<li>
<p>Example 2: Connect to an Apache HBase and perform a simple check of number of vertices and edges. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectHBase("mygraph", "localhost", "2181")
print "vertices", countV()
print "edges", countE()
</pre>
<p>In the preceding example, <code class="codeph">mygraph</code> is the name of the graph stored in the Apache HBase, and <code class="codeph">localhost</code> and <code class="codeph">2181</code> are the connection information to access the Apache HBase. They must be customized for your environment.</p>
</li>
<li>
<p>Example 3: Connect to an Oracle NoSQL Database and run a few analytical functions. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectONDB("mygraph", "kvstore", "localhost:5000")
print "vertices", countV()
print "edges", countE()
 
import pprint
 
analyzer = analyst()
print "# triangles in the graph", analyzer.countTriangles()
 
graph_communities = [{"commid":i.getName(),"size":i.size()} for i in analyzer.communities().iterator()]
 
import pandas as pd
import numpy as np
 
community_frame = pd.DataFrame(graph_communities)
community_frame[:5]
 
import matplotlib as mpl
import matplotlib.pyplot as plt
 
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(16,12));
community_frame["size"].plot(kind="bar", title="Communities and Sizes")
ax.set_xticklabels(community_frame.index);
plt.show()
</pre>
<p>The preceding example connects to an Oracle NoSQL Database, prints basic information about the vertices and edges, get an in memory analyst, computes the number of triangles, performs community detection, and finally plots out in a bar chart communities and their sizes.</p>
</li>
<li>
<p>Example 4: Connect to an Apache HBase and run a few analytical functions. To run it:</p>
<pre dir="ltr">
cd /opt/oracle/oracle-spatial-graph/property_graph/examples/pyopg
./pyopg.sh
 
connectHBase("mygraph", "localhost", "2181")
print "vertices", countV()
print "edges", countE()
 
import pprint
 
analyzer = analyst()
print "# triangles in the graph", analyzer.countTriangles()
 
graph_communities = [{"commid":i.getName(),"size":i.size()} for i in analyzer.communities().iterator()]
import pandas as pd
import numpy as np
community_frame = pd.DataFrame(graph_communities)
community_frame[:5]
 
import matplotlib as mpl
import matplotlib.pyplot as plt
 
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(16,12));
community_frame["size"].plot(kind="bar", title="Communities and Sizes")
ax.set_xticklabels(community_frame.index);
plt.show()
</pre>
<p>The preceding example connects to an Apache HBase, prints basic information about the vertices and edges, gets an in-memory analyst, computes the number of triangles, performs community detection, and finally plots out in a bar chart communities and their sizes.</p>
</li>
</ul>
<p>For detailed information about this example Python interface, see the following directory under the installation home:</p>
<pre dir="ltr">
property_graph/examples/pyopg/doc/
</pre></div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment323">
<tr>
<td class="cellalignment360">
<table class="cellalignment328">
<tr>
<td class="cellalignment327"><a href="configuring-property-graph-support.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment327"><a href="using-in-memory-analyst.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2015, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment362">
<table class="cellalignment326">
<tr>
<td class="cellalignment327"><a href="http://docs.oracle.com/bigdata/bda49/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment327"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment327"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
