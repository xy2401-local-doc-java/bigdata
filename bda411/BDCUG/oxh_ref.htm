<!DOCTYPE html>
<html lang="en-US" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<meta http-equiv="Content-Type" content="UTF-8" />
<title>Oracle XQuery for Hadoop Reference</title>
<meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)" />
<meta name="keywords" content="Avro files, functions for reading, avro((colon))collection-avroxml function, avro((colon))get function, annotations, Avro collection, collection annotations, Avro, %annotations, avro, put annotation, schema annotation, schema-file annotation, schema-kv annotation, compress annotation, deflate compression, snappy compression, compression codec, file annotation, output file name, Avro file adapter, examples, text files, converting to Avro, converting text to, querying records, reading as XML, Avro records, reading as XML, Avro maps, reading as XML, Avro array,, Avro unions, reading as XML, Avro primitives, type mappings, between XQuery and Avro, data type mappings, XML, writing as Avro records, writing as Avro maps, writing as Avro arrays, writing as Avro unions, writing as Avro primitives, JSON module, Oracle XQuery for Hadoop, JSON files, reading, functions, reading JSON files, json, parse-as-xml function, get function, JSON file adapter, configuration properties, parsing options for JSON files, ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER property, oracle.hadoop.xquery.json.parser.*, ALLOW_COMMENTS property, ALLOW_NON_NUMERIC_NUMBERS property, ALLOW_NUMERIC_LEADING_ZEROS property, ALLOW_SINGLE_QUOTES property, ALLOW_UNQUOTED_CONTROL_CHARS property, ALLOW_UNQUOTED_FIELD_NAMES property, JSON data formats, converting to XML, mapping, JSON to XML, Oracle Database adapter, oracle, columns annotation, oracle-property annotation, Oracle Database and XQuery, mappings, Oracle Database and XQuery data types, equal to Oracle Loader for Hadoop configuration properties, for Oracle XQuery for Hadoop, Oracle NoSQL Database adapter, adapters, Oracle NoSQL Database, kv, collection-text function, collection-avroxml function, collection-xml function, collection-binxml function, collection-tika function, put-text function, put-xml function, put-binxml function, get-text function, get-avroxml function, get-xml function, get-binxml function, get-tika function, key-range function, kv-table, collection-jsontext, kv-lob, get-text, get-xml, get-binxml, get-tika, put-text, put-xml, put-binxml, collection annotation, key annotation, output, encoding annotation, character encoding, encoding characters, UTF-8 encoding, get annotation, %output annotation, Oracle NoSQL Database Adapter, oracle.hadoop.xquery.kv.config.durability property, durability property, MasterPolicy durability, ReplicaPolicy durability, ReplicaAck policy, oracle.hadoop.xquery.kv.config.requestLimit property, requestLimit property, oracle.hadoop.xquery.kv.config.requestTimeout property, requestTimeout property, oracle.hadoop.xquery.kv.config.socketOpenTimeout property, socketOpenTimeout property, oracle.hadoop.xquery.kv.config.socketReadTimeout property, socketReadTimeout property, oracle.kv.batchSize property, batchSize property, oracle.kv.consistency property, consistency property, oracle.kv.hosts property, hosts property, oracle.kv.kvstore property, kvstore property, oracle.kv.timeout property, timeout property, oracle.hadoop.xquery.kv property, LOBSuffixproperty, LOBTimeout property, readZones property, security property, seq, collection function, put functions, split-max annotation, split-min annotation, sequence files, writing, writing sequence files, sequence file adapter, annotations for writing, compression, output annotation, reading and writing, reading text files, writing text files, reading and writing text files, text, put function, trace function, text file adapter, collection functions, split annotation, delimiter, for splitting text files, split size, xmlf, compress annotations, parameter annotation, tika file adapter, parsing, parsing tika files, tika, parse function, parse textual data, helper function, tika files, %output media-type annotation, %output encoding annotation, oracle.hadoop.xquery.tika.html.asis property, oracle.hadoop.xquery.tika.locale property, XML files, reading XML files, split-namespace annotation, split-entity annotation, XML file adapter, oxh, find function, file paths, locating in XQuery, increment-counter function, println function, println-xml function, property function" />
<meta name="dcterms.created" content="2017-10-10T14:24:14Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Big Data Connectors User's Guide" />
<meta name="dcterms.identifier" content="E89802-02" />
<meta name="dcterms.isVersionOf" content="BDCUG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2011, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="http://www.docs.oracle.com/bigdata/411/index.html" title="Home" type="text/html" />
<link rel="Copyright" href="../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../nav/js/doccd.js" charset="UTF-8"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oxh.htm" title="Previous" type="text/html" />
<link rel="Next" href="oxh_hive.htm" title="Next" type="text/html" />
<link rel="alternate" href="BDCUG.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../dcommon/css/fonts.css">
<link rel="stylesheet" href="../dcommon/css/foundation.css">
<link rel="stylesheet" href="../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../nav/css/html5.css">
<link rel="stylesheet" href="../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
<script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<a id="GUID-F84626F5-E1F9-4A2C-8369-2B426D7D7904"></a> <span id="PAGE" style="display:none;">12/31</span> <!-- End Header -->
<a id="BDCUG573"></a>
<h1 id="BDCUG-GUID-F84626F5-E1F9-4A2C-8369-2B426D7D7904" class="sect1"><span class="enumeration_chapter">6</span> Oracle XQuery for Hadoop Reference</h1>
<div>
<p>This chapter describes the adapters available in Oracle XQuery for Hadoop:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-2E501DE7-621C-4A69-A8A1-E5C4213A694D">Avro File Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-6F6BE3C3-B944-4B84-895A-00EF0CB7DE89">JSON File Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-45EAD813-5A24-4D95-9B7D-DA343A572EE9">Oracle Database Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-0FECDBE2-DA61-43DB-B2FD-F02C63EE4DF8">Oracle NoSQL Database Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-214695C5-3584-4058-BA2B-CC55401DF845">Sequence File Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-77FBEE8B-F850-4DF2-B618-CBD6B67E73DE">Solr Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-9E0B8917-D101-49A8-9EC9-00786B01C24C">Text File Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-6B8E60B5-5BBA-410E-B97C-2917C2177014">Tika File Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-C8085B84-9570-4F53-BA5E-E7EE13010130">XML File Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5">Serialization Annotations</a></p>
</li>
</ul>
<p>This chapter also describes several other library modules:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-969E3FF3-02E9-410E-80C6-746F5BBA7173">Hadoop Module</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-7B02969A-1525-4B58-8720-E04ACB1F7B07" title="You can manipulate durations, dates, and times in XQuery using Oracle XQuery functions.The $format argument identifies the various fields that compose a date or time value. The $locale represents a specific geographic, political, or cultural region. You can manipulate strings in XQuery using Oracle XQuery functions.Adds padding characters to the left of a string to create a fixed-length string. If the input string exceeds the specified size, then it is truncated to return a substring of the specified length. The default padding character is a space (ASCII 32).Adds padding characters to the right of a string to create a fixed-length string. If the input string exceeds the specified size, then it is truncated to return a substring of the specified length. The default padding character is a space (ASCII 32).Removes any leading or trailing white space from a string.Removes any leading white space.Removes any trailing white space.">Utility Module</a></p>
</li>
</ul>
</div>
<a id="BDCUG574"></a>
<div class="sect2"><a id="GUID-2E501DE7-621C-4A69-A8A1-E5C4213A694D"></a>
<h2 id="BDCUG-GUID-2E501DE7-621C-4A69-A8A1-E5C4213A694D" class="sect2"><span class="enumeration_section">6.1</span> Avro File Adapter</h2>
<div>
<p>The <a id="d37476e99" class="indexterm-anchor"></a><a id="d37476e101" class="indexterm-anchor"></a>Avro file adapter provides functions to read and write Avro container files in HDFS. It is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-A37F4211-16B7-4FF5-B1A6-2BF4AC388609">Built-in Functions for Reading Avro Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-5B154913-5337-41ED-9302-8977F8B8AA57">Custom Functions for Reading Avro Container Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-487A8337-4CF6-4912-87A7-F031A976F84A">Custom Functions for Writing Avro Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-A09EE4E2-A207-41D4-A418-2B9766144935">Examples of Avro File Adapter Functions</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-6D9ECB91-7782-45F2-81E7-7292F4DA42FC">About Converting Values Between Avro and XML</a></p>
</li>
</ul>
<div class="infobox-note" id="GUID-2E501DE7-621C-4A69-A8A1-E5C4213A694D__GUID-2669E9A9-2AAC-4614-81AB-9F9E186175BF">
<p class="notep1">Note:</p>
<p><span class="bold">Additional Configuration Steps for HDP Users</span></p>
Oracle XQuery for Hadoop has been verified to run on both Cloudera&rsquo;s CDH5 and Hortonwork&rsquo;s HDP 2.3.3. &nbsp;However, to run queries that write to Avro container files in HDP 2.3.2, you must change the OXH classpath definition to use&nbsp;avro-mapred-1.7.4-hadoop2.jar.
<ol>
<li>
<p>Download the JAR from the Apache archive <a href="https://archive.apache.org/dist/avro/avro-1.7.4/java/" target="_blank">https://archive.apache.org/dist/avro/avro-1.7.4/java/</a></p>
</li>
<li>
<p>In $OXH_HOME/lib/oxh-lib.xml locate the following path tag:</p>
<pre dir="ltr">
&lt;path id="oracle.hadoop.xquery.avro.lib"&gt;
    &lt;fileset dir="${oracle.hadoop.loader.olh_home}/jlib" erroronmissingdir="false"&gt;
        &lt;include name="avro-mapred*.jar"/&gt;
    &lt;/fileset&gt;
&lt;/path&gt;
</pre>
<p>Replace the path tag above with the following revision.<code class="codeph">[DIRECTORY]</code> in this example is a placeholder. Replace it with the directory path to the JAR.</p>
<pre dir="ltr">
&lt;path id="oracle.hadoop.xquery.avro.lib&rdquo;&gt;
    &lt;fileset dir="[DIRECTORY]"&gt;
        &lt;include name="avro-mapred-1.7.4-hadoop2.jar"/&gt;\
    &lt;/fileset&gt;
&lt;/path&gt;
</pre></li>
</ol>
</div>
</div>
<a id="BDCUG575"></a>
<div class="sect3"><a id="GUID-A37F4211-16B7-4FF5-B1A6-2BF4AC388609"></a>
<h3 id="BDCUG-GUID-A37F4211-16B7-4FF5-B1A6-2BF4AC388609" class="sect3"><span class="enumeration_section">6.1.1</span> Built-in Functions for Reading Avro Files</h3>
<div>
<p>To use the built-in functions in your query, you must import the Avro file module as follows:</p>
<pre dir="ltr">
import module "oxh:avro";
</pre>
<p>The Avro file module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-F0718FC2-7A27-4208-B72C-798581243C99">avro:collection-avroxml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-6BD570A9-C5B3-4395-8D53-A464089F17FF">avro:get</a></code></p>
</li>
</ul>
<p>There are no built-in functions for writing Avro container files. To write Avro files, you must use a custom function that specifies the Avro writer schema.</p>
</div>
<a id="BDCUG778"></a><a id="BDCUG779"></a><a id="BDCUG780"></a><a id="BDCUG576"></a>
<div class="sect4"><a id="GUID-F0718FC2-7A27-4208-B72C-798581243C99"></a>
<h4 id="BDCUG-GUID-F0718FC2-7A27-4208-B72C-798581243C99" class="sect4"><span class="enumeration_section">6.1.1.1</span> avro:collection-avroxml</h4>
<div>
<p>Accesses a collection of Avro files in HDFS. The files might be split up and processed in parallel by multiple tasks. The function returns an XML element for each object. See <span class="q">"<a href="oxh_ref.htm#GUID-6D9ECB91-7782-45F2-81E7-7292F4DA42FC">About Converting Values Between Avro and XML</a>."</span></p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %avro:collection("avroxml") function 
   avro:collection-avroxml($uris as xs:string*) as element()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The Avro file URIs</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One XML element for each Avro object.</p>
</div>
</div>
<a id="BDCUG781"></a><a id="BDCUG782"></a><a id="BDCUG783"></a><a id="BDCUG577"></a>
<div class="sect4"><a id="GUID-6BD570A9-C5B3-4395-8D53-A464089F17FF"></a>
<h4 id="BDCUG-GUID-6BD570A9-C5B3-4395-8D53-A464089F17FF" class="sect4"><span class="enumeration_section">6.1.1.2</span> avro:get</h4>
<div>
<p>Retrieves an entry from an <a id="d37476e269" class="indexterm-anchor"></a>Avro map modeled as XML</p>
<p>If you omit the <code class="codeph">$map</code> parameter, then the behavior is identical to calling the two-argument function and using the context item for <code class="codeph">$map</code>.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
avro:get($key as xs:string?, $map as node()?) as element(oxh:entry)?
 
avro:get($key as xs:string?) as element(oxh:entry)?
</pre>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>The value of this XPath expression:</p>
<pre dir="ltr">
$map/oxh:entry[@key eq $key]
</pre>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>These function calls are equivalent:</p>
<pre dir="ltr">
$var/avro:get("key")

avro:get("key", $var)
 
$var/oxh:entry[@key eq "key"]
</pre>
<p>In this example, <code class="codeph">$var</code> is an Avro map modeled as XML. See <span class="q">"<a href="oxh_ref.htm#GUID-44BC1AEB-AE71-43D4-B1AA-1890E41A7A5C">Reading Maps</a>."</span></p>
</div>
</div>
</div>
<a id="BDCUG578"></a>
<div class="sect3"><a id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57"></a>
<h3 id="BDCUG-GUID-5B154913-5337-41ED-9302-8977F8B8AA57" class="sect3"><span class="enumeration_section">6.1.2</span> Custom Functions for Reading Avro Container Files</h3>
<div>
<p>You can use the following annotations to define functions that read collections of <a id="d37476e342" class="indexterm-anchor"></a><a id="d37476e346" class="indexterm-anchor"></a><a id="d37476e350" class="indexterm-anchor"></a><a id="d37476e354" class="indexterm-anchor"></a><a id="d37476e356" class="indexterm-anchor"></a>Avro container files in HDFS. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading Avro files must have the following signature:</p>
<pre dir="ltr">
declare %avro:collection("avroxml") [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as element()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57__GUID-175478F6-A430-4BB2-8406-A3BA945D116C"><!-- --></a>%avro:collection("avroxml")</dt>
<dd>
<p>Declares the <code class="codeph">avroxml</code> collection function. Required.</p>
<p>A collection function accesses Avro files in HDFS. The files might be split up and processed in parallel by multiple tasks. The function returns an XML element for each object. See <span class="q">"<a href="oxh_ref.htm#GUID-6D9ECB91-7782-45F2-81E7-7292F4DA42FC">About Converting Values Between Avro and XML</a>."</span></p>
</dd>
<dt class="dlterm"><a id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57__GUID-9FA8029A-4393-44EE-9807-680B99B56D99"><!-- --></a>%avro:schema("<span class="italic">avro-schema</span>")</dt>
<dd>
<p>Provides the <a id="d37476e402" class="indexterm-anchor"></a>Avro reader schema as the value of the annotation. Optional.</p>
<p>The objects in the file are mapped to the reader schema when it is specified. For example:</p>
<div class="p">
<pre dir="ltr">
%avro:schema('
   {
      "type": "record",
      "name": "Person",
      "fields" : [
         {"name": "full_name", "type": "string"},
         {"name": "age", "type": ["int", "null"] }
       ]
   }
')
</pre></div>
<p>You cannot combine this annotation with <code class="codeph">%avro:schema-file</code> or <code class="codeph">%avro:schema-kv</code>.</p>
<div class="infoboxnotealso" id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57__GUID-604FBF2D-9948-4D59-B928-DC2EFFA965EC">
<p class="notep1">See Also:</p>
<p>"Schema Resolution" in the Apache Avro Specification at</p>
<p><a href="http://avro.apache.org/docs/current/spec.html#Schema+Resolution" target="_blank"><code class="codeph">http://avro.apache.org/docs/current/spec.html#Schema+Resolution</code></a></p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57__GUID-DA3A23B0-95B9-499E-9F97-A7D021F46B67"><!-- --></a>%avro:schema-file("<span class="italic">avro-schema-uri</span>")</dt>
<dd>
<p>Like <code class="codeph">%avro:schema</code>, but the annotation value is a file URI that contains the <a id="d37476e438" class="indexterm-anchor"></a>Avro reader schema. Relative URIs are resolved against the current working directory of the client's local file system. Optional.</p>
<p>For example, <code class="codeph">%avro:schema-file("schemas/person.avsc")</code>.</p>
<p>You cannot combine this annotation with <code class="codeph">%avro:schema</code> or <code class="codeph">%avro:schema-kv</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57__GUID-94A740CB-BB50-458C-96C5-D9877CB05773"><!-- --></a>%avro:schema-kv("<span class="italic">schema-name</span>")</dt>
<dd>
<p>Like <code class="codeph">%avro:schema</code>, but the annotation value is a fully qualified record name. The record schema is retrieved from the Oracle NoSQL Database catalog. Optional.</p>
<p>For example, <code class="codeph">%avro:schema-kv("org.example.PersonRecord")</code>.</p>
<p>You must specify the connection parameters to Oracle NoSQL Database when you use this annotation. See <span class="q">"<a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148">Oracle NoSQL Database Adapter Configuration Properties</a>."</span></p>
<p>You cannot combine this annotation with <code class="codeph">%avro:schema</code> or <code class="codeph">%avro:schema-file</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57__GUID-5EBA434A-3359-4F97-AE89-73E59DD013F2"><!-- --></a>%avro:split-max("<span class="italic">split-size</span>")</dt>
<dd>
<p><a id="d37476e493" class="indexterm-anchor"></a>Specifies the maximum <a id="d37476e496" class="indexterm-anchor"></a>split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit). These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%avro:split-max(1024)
%avro:split-max("1024")
%avro:split-max("1K")
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-5B154913-5337-41ED-9302-8977F8B8AA57__GUID-696FF45D-4487-4B70-B6DF-CA3BFBC27C91"><!-- --></a>%avro:split-min("<span class="italic">split-size</span>")</dt>
<dd>
<p>Specifies the minimum split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit). These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%avro:split-min(1024)
%avro:split-min("1024")
%avro:split-min("1K")
</pre></div>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG579"></a>
<div class="sect3"><a id="GUID-487A8337-4CF6-4912-87A7-F031A976F84A"></a>
<h3 id="BDCUG-GUID-487A8337-4CF6-4912-87A7-F031A976F84A" class="sect3"><span class="enumeration_section">6.1.3</span> Custom Functions for Writing Avro Files</h3>
<div>
<p>You can use the following annotations to define functions that write <a id="d37476e623" class="indexterm-anchor"></a><a id="d37476e627" class="indexterm-anchor"></a><a id="d37476e631" class="indexterm-anchor"></a><a id="d37476e635" class="indexterm-anchor"></a><a id="d37476e637" class="indexterm-anchor"></a>Avro files.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for writing Avro files must have the following signature:</p>
<pre dir="ltr">
declare %avro:put("avroxml") [<span class="italic">additional annotations</span>]
   local:<span class="italic">myFunctionName</span>($value as item()) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-487A8337-4CF6-4912-87A7-F031A976F84A__GUID-72A33D4D-F26F-41AD-A252-ADEEF4D4112B"><!-- --></a>%avro:put("avroxml")</dt>
<dd>
<p>Declares the <code class="codeph">avroxml</code> put function. Required.</p>
<p>An Avro schema must be specified using one of the following annotations:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">%avro:schema</code></p>
</li>
<li>
<p><code class="codeph">%avro:schema-file</code></p>
</li>
<li>
<p><code class="codeph">%avro:schema-kv</code></p>
</li>
</ul>
<p>The input XML value is converted to an instance of the schema. See <span class="q">"<a href="oxh_ref.htm#GUID-6D5BD0B4-7377-45C3-A258-71DF590A939B">Writing XML as Avro</a>."</span></p>
</dd>
<dt class="dlterm"><a id="GUID-487A8337-4CF6-4912-87A7-F031A976F84A__GUID-9ADE3CBD-3F85-40B9-AE47-D6AE4042C654"><!-- --></a>%avro:schema("<span class="italic">avro-schema</span>")</dt>
<dd>
<p>Specifies the schema of the files. For example:</p>
<div class="p">
<pre dir="ltr">
%avro:schema('
   {
      "type": "record",
      "name": "Person",
      "fields" : [
         {"name": "full_name", "type": "string"},
         {"name": "age", "type": ["int", "null"] }
      ]
   }
')
</pre></div>
<p>You cannot combine this annotation with <code class="codeph">%avro:schema-file</code> or <code class="codeph">%avro:schema-kv</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-487A8337-4CF6-4912-87A7-F031A976F84A__GUID-295BC22E-E142-4F10-9B44-D1970620C08D"><!-- --></a>%avro:schema-file("<span class="italic">avro-schema-uri</span>")</dt>
<dd>
<p>Like <code class="codeph">%avro:schema</code>, but the annotation value is a file URI that contains the <a id="d37476e721" class="indexterm-anchor"></a>Avro reader schema. Relative URIs are resolved against the current working directory of the client's local file system.</p>
<p>For example: <code class="codeph">%avro:schema-file("schemas/person.avsc")</code></p>
<p>You cannot combine this annotation with <code class="codeph">%avro:schema</code> or <code class="codeph">%avro:schema-kv</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-487A8337-4CF6-4912-87A7-F031A976F84A__GUID-D8AB1D28-0F02-4267-AA92-BE3AF84047AD"><!-- --></a>%avro:schema-kv("<span class="italic">schema-name</span>")</dt>
<dd>
<p>Like <code class="codeph">%avro:schema</code>, but the annotation value is a fully qualified record name. The record schema is retrieved from the Oracle NoSQL Database catalog.</p>
<p>For example: <code class="codeph">%avro:schema-kv("org.example.PersonRecord")</code></p>
<p>You must specify the connection parameters to Oracle NoSQL Database when you use this annotation. See <span class="q">"<a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148">Oracle NoSQL Database Adapter Configuration Properties</a>."</span></p>
<p>You cannot combine this annotation with <code class="codeph">%avro:schema</code> or <code class="codeph">%avro:schema-file</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-487A8337-4CF6-4912-87A7-F031A976F84A__GUID-1B9A7595-B17F-40AA-B0FE-FAFEB3693E45"><!-- --></a>%avro:compress("<span class="italic">method</span>", [<span class="italic">level</span>]?)</dt>
<dd>
<p><a id="d37476e777" class="indexterm-anchor"></a>Specifies the compression format used on the output.</p>
<p>The <span class="italic">codec</span> is one of the following string literal values:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="bold">deflate</span>: The <span class="italic">level</span> controls the trade-off between speed and compression. Valid values are 1 to 9, where 1 is the fastest and 9 is the most compressed.</p>
</li>
<li>
<p><span class="bold">snappy</span>: This algorithm is designed for high speed and moderate compression.</p>
</li>
</ul>
<p>The default is no compression.</p>
<p>The <span class="italic">level</span> is an integer value. It is optional and only supported when <span class="italic">codec</span> is <code class="codeph">deflate</code>.</p>
<p>For example:</p>
<div class="p">
<pre dir="ltr">
%avro:compress("snappy")
%avro:compress("deflate")
%avro:compress("deflate", 3)
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-487A8337-4CF6-4912-87A7-F031A976F84A__GUID-AA793EDC-CD44-4DDC-B2E6-818986F3C835"><!-- --></a>%avro:file("<span class="italic">name</span>")</dt>
<dd>
<p>Specifies the output file name prefix. The default prefix is <code class="codeph">part</code>.</p>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1057"></a><a id="BDCUG1058"></a><a id="BDCUG784"></a>
<div class="sect3"><a id="GUID-A09EE4E2-A207-41D4-A418-2B9766144935"></a>
<h3 id="BDCUG-GUID-A09EE4E2-A207-41D4-A418-2B9766144935" class="sect3"><span class="enumeration_section">6.1.4</span> Examples of Avro File Adapter Functions</h3>
<div>
<p>These examples use the following text file in HDFS:</p>
<pre dir="ltr">
mydata/ages.txt

john,45
kelly,36
laura,
mike,27
</pre>
<div class="example" id="GUID-A09EE4E2-A207-41D4-A418-2B9766144935__CHEBBBEI">
<p class="titleinexample">Example 6-1 Converting a Text File to Avro</p>
<p>The following query converts the file into compressed Avro container files:</p>
<pre dir="ltr">
import module "oxh:text";
 
declare 
   %avro:put("avroxml")
   %avro:compress("snappy")
   %avro:schema('
      {
         "type": "record",
         "name": "AgeRec",
         "fields" : [
            {"name": "user", "type": "string"},
            {"name": "age", "type": ["int", "null"] }
         ]
      }
   ')
function local:put($arg as item()) external;

for $line in text:collection("mydata/ages.txt")
let $split := fn:tokenize($line, ",")
return
   local:put(
      &lt;rec&gt;
         &lt;user&gt;{$split[1]}&lt;/user&gt;
         {
            if ($split[2] castable as xs:int) then
               &lt;age&gt;{$split[2]}&lt;/age&gt;
            else 
               ()
         }
      &lt;/rec&gt;
   )
</pre>
<p>The query generates an Avro file with the following records, represented here as JSON:</p>
<pre dir="ltr">
{"user":"john","age":{"int":45}}
{"user":"kelly","age":{"int":36}}
{"user":"laura","age":null}
{"user":"mike","age":{"int":27}}
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-A09EE4E2-A207-41D4-A418-2B9766144935__GUID-86C7BDE4-9BFA-4A94-8864-47774054F897">
<p class="titleinexample">Example 6-2 Querying Records in Avro Container Files</p>
<p>The next query selects records in which the age is either null or greater than 30, from the myoutput directory. The query in <a href="oxh_ref.htm#GUID-A09EE4E2-A207-41D4-A418-2B9766144935__CHEBBBEI">Example 6-1</a>generated the records.</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:avro";

for $rec in avro:collection-avroxml("myoutput/part*.avro")
where $rec/age/nilled() or $rec/age gt 30
return
   text:put($rec/user)
</pre>
<p>This query creates files that contain the following lines:</p>
<pre dir="ltr">
john
kelly
laura
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDCUG582"></a>
<div class="sect3"><a id="GUID-6D9ECB91-7782-45F2-81E7-7292F4DA42FC"></a>
<h3 id="BDCUG-GUID-6D9ECB91-7782-45F2-81E7-7292F4DA42FC" class="sect3"><span class="enumeration_section">6.1.5</span> About Converting Values Between Avro and XML</h3>
<div>
<p>This section describes how Oracle XQuery for Hadoop converts data between Avro and XML:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-AB8EE1B1-A3B6-40F9-8A95-C033526EF906">Reading Avro as XML</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-6D5BD0B4-7377-45C3-A258-71DF590A939B">Writing XML as Avro</a></p>
</li>
</ul>
</div>
<a id="BDCUG583"></a>
<div class="sect4"><a id="GUID-AB8EE1B1-A3B6-40F9-8A95-C033526EF906"></a>
<h4 id="BDCUG-GUID-AB8EE1B1-A3B6-40F9-8A95-C033526EF906" class="sect4"><span class="enumeration_section">6.1.5.1</span> Reading Avro as XML</h4>
<div>
<p>Both the <a id="d37476e952" class="indexterm-anchor"></a>Avro file adapter and the <a id="d37476e957" class="indexterm-anchor"></a>Oracle NoSQL Database adapter have an <a id="d37476e962" class="indexterm-anchor"></a><code class="codeph">avroxml</code> method, which you can use with the collection functions to read Avro records as XML. After the Avro is converted to XML, you can query and transform the data using XQuery.</p>
<p>The following topics describe how Oracle XQuery for Hadoop reads Avro:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-9E0BAF32-B98F-4DBD-8EFD-B3EDD0BCB451">Reading Records</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-44BC1AEB-AE71-43D4-B1AA-1890E41A7A5C">Reading Maps</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-EB0C99F1-E74E-4FC3-9D01-64F47786A0C9">Reading Arrays</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-C672137F-79FF-4B65-9A66-1526FCA5A6CC">Reading Unions</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-A69421F3-2059-44AC-AFFB-883D574CE4DF">Reading Primitives</a></p>
</li>
</ul>
</div>
<a id="BDCUG584"></a>
<div class="sect5"><a id="GUID-9E0BAF32-B98F-4DBD-8EFD-B3EDD0BCB451"></a>
<h5 id="BDCUG-GUID-9E0BAF32-B98F-4DBD-8EFD-B3EDD0BCB451" class="sect5"><span class="enumeration_section">6.1.5.1.1</span> Reading Records</h5>
<div>
<p>An Avro record is converted to an <code class="codeph">&lt;oxh:item&gt;</code> element with one child element for each field in the record.</p>
<p>For example, consider the following Avro schema:</p>
<pre dir="ltr">
{
   "type": "record",
   "name": "Person",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "age", "type": ["int", "null"] }
   ]
}
</pre>
<p>This is an instance of the record modeled as XML:</p>
<pre dir="ltr">
&lt;oxh:item&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;age&gt;46&lt;/age&gt;
&lt;/oxh:item&gt;
</pre>
<p>Converting Avro records to XML enables XQuery to query them. The next example queries an Avro container file named person.avro, which contains Person records. The query converts the records to a CSV text file in which each line contains the <code class="codeph">full_name</code> and <code class="codeph">age</code> values:</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";
 
for $x in avro:collection-avroxml("person.avro")
return
   text:put($x/full_name || "," || $x/age)
 
</pre>
<p>Null values are converted to nilled elements. A <a id="d37476e1037" class="indexterm-anchor"></a><span class="bold">nilled</span> element has an <a id="d37476e1042" class="indexterm-anchor"></a><code class="codeph">xsi:nil</code> attribute set to <code class="codeph">true</code>; it is always empty. You can use the XQuery <a id="d37476e1052" class="indexterm-anchor"></a><code class="codeph">fn:nilled</code> function to test if a record field is null. For example, the following query writes the name of Person records that have a null value for age:</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";
 
for $x in avro:collection-avroxml("person.avro")
where $x/age/nilled()
return
   text:put($x/full_name)
 
</pre>
<p>For nested records, the fields of the inner schema become child elements of the element that corresponds to the field in the outer schema. For example, this schema has a nested record:</p>
<pre dir="ltr">
{
   "type": "record", 
   "name": "PersonAddress",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "address", "type": 
         { "type" : "record",
           "name" : "Address",
           "fields" : [
              { "name" : "street", "type" : "string" },
              { "name" : "city", "type" : "string" }
            ]
         }
      }
   ]
}
</pre>
<p>This is an instance of the record as XML:</p>
<pre dir="ltr">
&lt;oxh:item&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;address&gt;
      &lt;street&gt;123 First St.&lt;/street&gt;
      &lt;city&gt;New York&lt;/city&gt;
   &lt;/address&gt;
&lt;/oxh:item&gt;
</pre>
<p>The following example queries an Avro container file named people-address.avro that contains <code class="codeph">PersonAddress</code> records, and writes the names of the people that live in New York to a text file:</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";

for $person in avro:collection-avroxml("examples/person-address.avro")
where $person/address/city eq "New York"
return
   text:put($person/full_name)
</pre></div>
</div>
<a id="BDCUG585"></a>
<div class="sect5"><a id="GUID-44BC1AEB-AE71-43D4-B1AA-1890E41A7A5C"></a>
<h5 id="BDCUG-GUID-44BC1AEB-AE71-43D4-B1AA-1890E41A7A5C" class="sect5"><span class="enumeration_section">6.1.5.1.2</span> Reading Maps</h5>
<div>
<p>Avro map values are converted to an element that contains one child <code class="codeph">&lt;oxh:entry&gt;</code> element for each entry in the map. For example, consider the following schema:</p>
<pre dir="ltr">
{
   "type": "record", 
   "name": "PersonProperties",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "properties", "type": 
         {"type": "map", "values": "string"}
      }
   ]
}
</pre>
<p>This is an instance of the schema as XML:</p>
<pre dir="ltr">
&lt;oxh:item&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;properties&gt;
      &lt;oxh:entry key="employer"&gt;Example Inc&lt;/oxh:entry&gt;
      &lt;oxh:entry key="hair color"&gt;brown&lt;/oxh:entry&gt;
      &lt;oxh:entry key="favorite author"&gt;George RR Martin&lt;/oxh:entry&gt;
   &lt;/properties&gt;
&lt;/oxh:item&gt;
</pre>
<p>The following example queries a file named <code class="codeph">person-properties.avro</code> that contains <code class="codeph">PersonAddress</code> records, and writes the names of the people that are employed by Example Inc. The query shows how regular XPath expressions can retrieve map entries. Moreover, you can use the <code class="codeph">avro:get</code> function as a shortcut to retrieve map entries.</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";
 
for $person in avro:collection-avroxml("person-properties.avro")
where $person/properties/oxh:entry[@key eq "employer"] eq "Example Inc"
return
   text:put($person/full_name)
 
</pre>
<p>The following query uses the <code class="codeph">avro:get</code> function to retrieve the <code class="codeph">employer</code> entry. It is equivalent to the previous query.</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";
 
for $person in avro:collection-avroxml("person-properties.avro")
where $person/properties/avro:get("employer") eq "Example Inc"
return
   text:put($person/full_name)
</pre>
<p>You can use XQuery<a id="d37476e1135" class="indexterm-anchor"></a> <code class="codeph">fn:nilled</code> function to test for null values. This example returns true if the map entry is null:</p>
<pre dir="ltr">
$var/avro:get("key")/nilled()
</pre></div>
</div>
<a id="BDCUG586"></a>
<div class="sect5"><a id="GUID-EB0C99F1-E74E-4FC3-9D01-64F47786A0C9"></a>
<h5 id="BDCUG-GUID-EB0C99F1-E74E-4FC3-9D01-64F47786A0C9" class="sect5"><span class="enumeration_section">6.1.5.1.3</span> Reading Arrays</h5>
<div>
<p>Oracle XQuery for Hadoop converts Avro array values to an element that contains a child <code class="codeph">&lt;oxh:item&gt;</code> element for each item in the array. For example, consider the following schema:</p>
<pre dir="ltr">
{
   "type": "record", 
   "name": "PersonScores",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "scores", "type": 
         {"type": "array", "items": "int"}
      }
   ]
}
</pre>
<p>This is an instance of the schema as XML:</p>
<pre dir="ltr">
&lt;oxh:item&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;scores&gt;
      &lt;oxh:item&gt;128&lt;/oxh:item&gt;
      &lt;oxh:item&gt;151&lt;/oxh:item&gt;
      &lt;oxh:item&gt;110&lt;/oxh:item&gt;
   &lt;/scores&gt;
&lt;/oxh:item&gt;
</pre>
<p>The following example queries a file named person-scores.avro that contains <code class="codeph">PersonScores</code> records, and writes the sum and count of scores for each person:</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";
 
for $person in avro:collection-avroxml("person-scores.avro")
let $scores := $person/scores/*
return
   text:put($person/full_name || "," || sum($scores) || "," || count($scores))
</pre>
<p>You can access a specific element of an array by using a numeric XPath predicate. For example, this path expression selects the second score. XPath indexing starts at 1 (not 0).</p>
<pre dir="ltr">
$person/scores/oxh:item[2]
</pre></div>
</div>
<a id="BDCUG587"></a>
<div class="sect5"><a id="GUID-C672137F-79FF-4B65-9A66-1526FCA5A6CC"></a>
<h5 id="BDCUG-GUID-C672137F-79FF-4B65-9A66-1526FCA5A6CC" class="sect5"><span class="enumeration_section">6.1.5.1.4</span> Reading Unions</h5>
<div>
<p>Oracle XQuery for Hadoop converts an instance of an Avro union type based on the actual member type of the value. The name of the member type is added as an XML <code class="codeph">avro:type</code> attribute to the enclosing element, which ensures that queries can distinguish between instances of different member types. However, the attribute is not added for trivial unions where there are only two member types and one of them is null.</p>
<p>For example, consider the following union of two records:</p>
<pre dir="ltr">
[
   {
      "type": "record", 
      "name": "Person1",
      "fields" : [
         {"name": "full_name", "type": "string"}
      ]
   }
   ,
   {
      "type": "record", 
      "name": "Person2",
      "fields" : [
         {"name": "fname", "type": "string"}
      ]
   }
]
 
</pre>
<p>This is an instance of the schema as XML:</p>
<pre dir="ltr">
&lt;oxh:item avro:type="Person2"&gt;
   &lt;fname&gt;John Doe&lt;/fname&gt;
&lt;/oxh:item&gt;
</pre>
<p>The following example queries a file named person-union.avro that contains instances of the previous union schema, and writes the names of the people from both record types to a text file:</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";

for $person in avro:collection-avroxml("examples/person-union.avro")
return
   if ($person/@avro:type eq "Person1") then
      text:put($person/full_name)
   else if ($person/@avro:type eq "Person2") then
      text:put($person/fname)
   else
      error(xs:QName("UNEXPECTED"), "Unexpected record type:" || $person/@avro:type)
</pre></div>
</div>
<a id="BDCUG589"></a><a id="BDCUG588"></a>
<div class="sect5"><a id="GUID-A69421F3-2059-44AC-AFFB-883D574CE4DF"></a>
<h5 id="BDCUG-GUID-A69421F3-2059-44AC-AFFB-883D574CE4DF" class="sect5"><span class="enumeration_section">6.1.5.1.5</span> Reading Primitives</h5>
<div>
<p>The following table shows how Oracle XQuery for Hadoop maps Avro primitive types to XQuery atomic types.</p>
<div class="tblformal" id="GUID-A69421F3-2059-44AC-AFFB-883D574CE4DF__BABGBIGJ">
<p class="titleintable">Table 6-1 Mapping Avro Primitive Types to XQuery Atomic Types</p>
<table class="cellalignment8" title="Mapping Avro Primitive Types to XQuery Atomic Types" summary="Avro primitive types mapping">
<thead>
<tr class="cellalignment2">
<th class="cellalignment53" id="d37476e1276">Avro</th>
<th class="cellalignment54" id="d37476e1279">XQuery</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment55" id="d37476e1284" headers="d37476e1276">
<p><code class="codeph">boolean</code></p>
</td>
<td class="cellalignment56" headers="d37476e1284 d37476e1279">
<p><code class="codeph">xs:boolean</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment55" id="d37476e1293" headers="d37476e1276">
<p><code class="codeph">int</code></p>
</td>
<td class="cellalignment56" headers="d37476e1293 d37476e1279">
<p><code class="codeph">xs:int</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment55" id="d37476e1302" headers="d37476e1276">
<p><code class="codeph">long</code></p>
</td>
<td class="cellalignment56" headers="d37476e1302 d37476e1279">
<p><code class="codeph">xs:long</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment55" id="d37476e1311" headers="d37476e1276">
<p><code class="codeph">float</code></p>
</td>
<td class="cellalignment56" headers="d37476e1311 d37476e1279">
<p><code class="codeph">xs:float</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment55" id="d37476e1320" headers="d37476e1276">
<p><code class="codeph">double</code></p>
</td>
<td class="cellalignment56" headers="d37476e1320 d37476e1279">
<p><code class="codeph">xs:double</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment55" id="d37476e1329" headers="d37476e1276">
<p><code class="codeph">bytes</code></p>
</td>
<td class="cellalignment56" headers="d37476e1329 d37476e1279">
<p><code class="codeph">xs:hexBinary</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment55" id="d37476e1338" headers="d37476e1276">
<p><code class="codeph">string</code></p>
</td>
<td class="cellalignment56" headers="d37476e1338 d37476e1279">
<p><code class="codeph">xs:string</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>Avro null values are mapped to empty nilled elements. To distinguish between a null string value and an empty string value, use the XQuery <a id="d37476e1348" class="indexterm-anchor"></a><a id="d37476e1350" class="indexterm-anchor"></a><a id="d37476e1352" class="indexterm-anchor"></a><code class="codeph">nilled</code> function. This path expression only returns true if the field value is null:</p>
<pre dir="ltr">
$record/field/fn:nilled()
</pre>
<p>Avro fixed values are mapped to <code class="codeph">xs:hexBinary</code>, and <code class="codeph">enums</code> are mapped to <code class="codeph">xs:string</code>.</p>
</div>
</div>
</div>
<a id="BDCUG591"></a>
<div class="sect4"><a id="GUID-6D5BD0B4-7377-45C3-A258-71DF590A939B"></a>
<h4 id="BDCUG-GUID-6D5BD0B4-7377-45C3-A258-71DF590A939B" class="sect4"><span class="enumeration_section">6.1.5.2</span> Writing XML as Avro</h4>
<div>
<p>Both the <a id="d37476e1390" class="indexterm-anchor"></a>Avro file adapter and the <a id="d37476e1395" class="indexterm-anchor"></a>Oracle NoSQL Database adapter have an <a id="d37476e1400" class="indexterm-anchor"></a><code class="codeph">avroxml</code> method, which you can use with the put functions to write XML as Avro. The following topics describe how the XML is converted to an Avro instance:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-7083B00F-F917-4CEB-AE77-DB3662338D5D">Writing Records</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-43DAE9E4-E64A-4873-86FD-1E737B0FBA54">Writing Maps</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-FBD65518-457E-4A90-BB3F-32B38D9305ED">Writing Arrays</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-E3C0117A-6C80-4BBA-8936-6C62E3A2EEEA">Writing Unions</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-B3665A72-56E6-467A-A772-03CF08CFCBEB">Writing Primitives</a></p>
</li>
</ul>
</div>
<a id="BDCUG592"></a>
<div class="sect5"><a id="GUID-7083B00F-F917-4CEB-AE77-DB3662338D5D"></a>
<h5 id="BDCUG-GUID-7083B00F-F917-4CEB-AE77-DB3662338D5D" class="sect5"><span class="enumeration_section">6.1.5.2.1</span> Writing Records</h5>
<div>
<p>Oracle XQuery for Hadoop maps the XML to an Avro record schema by matching the child element names to the field names of the record. For example, consider the following Avro schema:</p>
<pre dir="ltr">
{
   "type": "record",
   "name": "Person",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "age", "type": ["int", "null"] }
   ]
}
</pre>
<p>You can use the following XML element to write an instance of this record in which the <code class="codeph">full_name</code> field is John Doe and the <code class="codeph">age</code> field is 46. The name of the root element (<code class="codeph">Person</code>) is inconsequential. Only the names of the child elements are used to map to the Avro record fields (<code class="codeph">full_name</code> and <code class="codeph">age</code>).</p>
<pre dir="ltr">
&lt;person&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;age&gt;46&lt;/age&gt;
&lt;/person&gt;
</pre>
<p>The next example uses the following CSV file named <code class="codeph">people.csv</code>:</p>
<pre dir="ltr">
John Doe,46
Jane Doe,37
     .
     .
     .
 
</pre>
<p>This query converts values from the CSV file to Avro <code class="codeph">Person</code> records:</p>
<pre dir="ltr">
import module "oxh:avro";
import module "oxh:text";
 
declare 
   %avro:put("avroxml")
   %avro:schema('
      {
         "type": "record", 
         "name": "Person",
         "fields" : [
            {"name": "full_name", "type": "string"},
            {"name": "age", "type": ["int", "null"] }
         ]
      }
   ')
function local:put-person($person as element()) external;

for $line in text:collection("people.csv")
let $split := tokenize($line, ",")
return
   local:put-person(
      &lt;person&gt;
         &lt;full_name&gt;{$split[1]}&lt;/full_name&gt;
         &lt;age&gt;{$split[2]}&lt;/age&gt;
      &lt;/person&gt;
   )
 
</pre>
<p>For null values, you can omit the element or set the <code class="codeph">xsi:nil="true"</code> attribute. For example, this modified query sets <code class="codeph">age</code> to null when the value is not numeric:</p>
<pre dir="ltr">
   .
   .
   .
for $line in text:collection("people.csv")
let $split := tokenize($line, ",")
return
   local:put-person(
      &lt;person&gt;
         &lt;full_name&gt;{$split[1]}&lt;/full_name&gt;
         {
         if ($split[2] castable as xs:int) then
            &lt;age&gt;{$split[2]}&lt;/age&gt;
         else 
            ()
         }
      &lt;/person&gt;
   )
</pre>
<p>In the case of nested records, the values are obtained from nested elements. The next example uses the following schema:</p>
<pre dir="ltr">
{
"type": "record", 
"name": "PersonAddress",
"fields" : [
   {"name": "full_name", "type": "string"},
   {"name": "address", "type": 
      { "type" : "record",
        "name" : "Address",
        "fields" : [
           { "name" : "street", "type" : "string" },
           { "name" : "city", "type" : "string" }
        ]
      }
   }
]
}
</pre>
<p>You can use following XML to write an instance of this record:</p>
<pre dir="ltr">
&lt;person&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;address&gt;
      &lt;street&gt;123 First St.&lt;/street&gt;
      &lt;city&gt;New York&lt;/city&gt;
   &lt;/address&gt;
&lt;/person&gt;
</pre></div>
</div>
<a id="BDCUG593"></a>
<div class="sect5"><a id="GUID-43DAE9E4-E64A-4873-86FD-1E737B0FBA54"></a>
<h5 id="BDCUG-GUID-43DAE9E4-E64A-4873-86FD-1E737B0FBA54" class="sect5"><span class="enumeration_section">6.1.5.2.2</span> Writing Maps</h5>
<div>
<p>Oracle XQuery for Hadoop converts XML to an Avro map with one map entry for each <code class="codeph">&lt;oxh:entry&gt;</code> child element. For example, consider the following schema:</p>
<pre dir="ltr">
{
   "type": "record", 
   "name": "PersonProperties",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "properties", "type": 
         {"type": "map", "values": "string"}
      }
   ]
}
</pre>
<p>You can use the following XML element to write an instance of this schema in which the <code class="codeph">full_name</code> field is John Doe, and the properties field is set to a map with three entries:</p>
<pre dir="ltr">
&lt;person&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;properties&gt;
      &lt;oxh:entry key="hair color"&gt;brown&lt;/oxh:entry&gt;
      &lt;oxh:entry key="favorite author"&gt;George RR Martin&lt;/oxh:entry&gt;
      &lt;oxh:entry key="employer"&gt;Example Inc&lt;/oxh:entry&gt;
   &lt;/properties&gt;
&lt;/person&gt;
</pre></div>
</div>
<a id="BDCUG594"></a>
<div class="sect5"><a id="GUID-FBD65518-457E-4A90-BB3F-32B38D9305ED"></a>
<h5 id="BDCUG-GUID-FBD65518-457E-4A90-BB3F-32B38D9305ED" class="sect5"><span class="enumeration_section">6.1.5.2.3</span> Writing Arrays</h5>
<div>
<p>Oracle XQuery for Hadoop converts XML to an Avro array with one item for each <code class="codeph">&lt;oxh:item&gt;</code> child element. For example, consider the following schema:</p>
<pre dir="ltr">
{
   "type": "record", 
   "name": "PersonScores",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "scores", "type": 
         {"type": "array", "items": "int"}
      }
   ]
}
</pre>
<p>You can use the following XML element to write an instance of this schema in which the <code class="codeph">full_name</code> field is John Doe and the scores field is set to [128, 151, 110]:</p>
<pre dir="ltr">
&lt;person&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;scores&gt;
      &lt;oxh:item&gt;128&lt;/oxh:item&gt;
      &lt;oxh:item&gt;151&lt;/oxh:item&gt;
      &lt;oxh:item&gt;110&lt;/oxh:item&gt;
   &lt;/scores&gt;
&lt;/person&gt;
</pre></div>
</div>
<a id="BDCUG595"></a>
<div class="sect5"><a id="GUID-E3C0117A-6C80-4BBA-8936-6C62E3A2EEEA"></a>
<h5 id="BDCUG-GUID-E3C0117A-6C80-4BBA-8936-6C62E3A2EEEA" class="sect5"><span class="enumeration_section">6.1.5.2.4</span> Writing Unions</h5>
<div>
<p>When writing an Avro union type, Oracle XQuery for Hadoop bases the selection of a member type on the value of the <code class="codeph">avro:type</code> attribute.</p>
<p>This example uses the following schema:</p>
<pre dir="ltr">
[
   {
      "type": "record", 
      "name": "Person1",
      "fields" : [
         {"name": "full_name", "type": "string"}
      ]
   }
   ,
   {
      "type": "record", 
      "name": "Person2",
      "fields" : [
         {"name": "fname", "type": "string"}
      ]
   }
]
</pre>
<p>The following XML is mapped to an instance of the <code class="codeph">Person1</code> record:</p>
<pre dir="ltr">
&lt;person avro:type="Person1"&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
&lt;/person&gt;
</pre>
<p>This XML is mapped to an instance of the <code class="codeph">Person2</code> record:</p>
<pre dir="ltr">
&lt;person avro:type="Person2"&gt;
   &lt;fname&gt;John Doe&lt;/fname&gt;
&lt;/person&gt;
</pre>
<p>The <code class="codeph">avro:type</code> attribute selects the member type of the union. For trivial unions that contain a null and one other type, the <code class="codeph">avro:type</code> attribute is unnecessary. If the member type cannot be determined, then an error is raised.</p>
</div>
</div>
<a id="BDCUG596"></a>
<div class="sect5"><a id="GUID-B3665A72-56E6-467A-A772-03CF08CFCBEB"></a>
<h5 id="BDCUG-GUID-B3665A72-56E6-467A-A772-03CF08CFCBEB" class="sect5"><span class="enumeration_section">6.1.5.2.5</span> Writing Primitives</h5>
<div>
<p>To map primitive values, Oracle XQuery for Hadoop uses the equivalent data types shown in <a href="oxh_ref.htm#GUID-A69421F3-2059-44AC-AFFB-883D574CE4DF__BABGBIGJ" title="Avro primitive types mapping">Table 6-1</a> to cast an XML value to the corresponding Avro type. If the value cannot be converted to the Avro type, then an error is raised.</p>
<p>This example uses the following schema:</p>
<pre dir="ltr">
{
   "type": "record",
   "name": "Person",
   "fields" : [
      {"name": "full_name", "type": "string"},
      {"name": "age", "type": ["int", "null"] }
   ]
}
</pre>
<p>Attempting to map the following XML to an instance of this schema raises an error, because the <code class="codeph">string</code> value <code class="codeph">apple</code> cannot be converted to an <code class="codeph">int</code>:</p>
<pre dir="ltr">
&lt;person&gt;
   &lt;full_name&gt;John Doe&lt;/full_name&gt;
   &lt;age&gt;apple&lt;/age&gt;
&lt;/person&gt;
</pre></div>
</div>
</div>
</div>
</div>
<a id="BDCUG672"></a>
<div class="sect2"><a id="GUID-6F6BE3C3-B944-4B84-895A-00EF0CB7DE89"></a>
<h2 id="BDCUG-GUID-6F6BE3C3-B944-4B84-895A-00EF0CB7DE89" class="sect2"><span class="enumeration_section">6.2</span> JSON File Adapter</h2>
<div>
<p>The JSON file adapter provides access to JSON files stored in HDFS. It also contains functions for working with JSON data embedded in other file formats. For example, you can query JSON that is stored as lines in a large text file by using <code class="codeph">json:parse-as-xml</code> with the <code class="codeph">text:collection</code> function.</p>
<p>Processing a single JSON file in parallel is not currently supported. A set of JSON files can be processes in parallel, with sequential processing of each file.</p>
<p>The JSON module is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-BC0663F9-C369-495E-B37D-208D0A4760D8">Built-in Functions for Reading JSON</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-E4FBD869-B696-4473-A827-A66246361828">Custom Functions for Reading JSON Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-01AF8B30-1582-47E4-A830-098A09E60080">Examples of JSON Functions</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-046EB306-3E8D-4551-B0F7-2957E00462FD">JSON File Adapter Configuration Properties</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903">About Converting JSON Data Formats to XML</a></p>
</li>
</ul>
</div>
<a id="BDCUG673"></a>
<div class="sect3"><a id="GUID-BC0663F9-C369-495E-B37D-208D0A4760D8"></a>
<h3 id="BDCUG-GUID-BC0663F9-C369-495E-B37D-208D0A4760D8" class="sect3"><span class="enumeration_section">6.2.1</span> Built-in Functions for Reading JSON</h3>
<div>
<p>To use the built-in functions in your query, you must import the JSON file adapter as follows:</p>
<pre dir="ltr">
import module "oxh:json";
</pre>
<p>The JSON module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-64EE64BF-59B7-4826-9C8D-F67DEB0B2232">json:collection-jsonxml</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-75EDF233-E0C4-456B-81A4-1D178F0B7387">json:parse-as-xml</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-A825CD41-07BD-4A53-8141-688C316DABE0">json:get</a></p>
</li>
</ul>
<p>As of Big Data Connectors Release 4.9, Oracle XQuery for Hadoop also supports XQuery 3.1 including the standard facilities for processing JSON, including: <code class="codeph">fn:parse-json</code>, <code class="codeph">fn:json-to-xml</code>, and <code class="codeph">fn:xml-to-json</code></p>
<div class="infoboxnotealso" id="GUID-BC0663F9-C369-495E-B37D-208D0A4760D8__GUID-090AD78A-A952-419E-B2B6-2826A99F77FA">
<p class="notep1">See Also:</p>
<a href="https://www.w3.org/TR/xpath-functions-31/" target="_blank">XPath and XQuery Functions and Operators 3.1</a></div>
</div>
<a id="BDCUG786"></a><a id="BDCUG787"></a><a id="BDCUG788"></a><a id="BDCUG785"></a>
<div class="sect4"><a id="GUID-64EE64BF-59B7-4826-9C8D-F67DEB0B2232"></a>
<h4 id="BDCUG-GUID-64EE64BF-59B7-4826-9C8D-F67DEB0B2232" class="sect4"><span class="enumeration_section">6.2.1.1</span> json:collection-jsonxml</h4>
<div>
<p>Accesses a collection of JSON files in HDFS. Multiple files can be processed concurrently, but each individual file is parsed by a single task.</p>
<p>The JSON file adapter automatically decompresses files compressed with a Hadoop-supported compression codec.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
json:collection-jsonxml($uris as xs:string*) as element()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The JSON file URIs</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>XML elements that model the JSON values. See <span class="q">"<a href="oxh_ref.htm#GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903">About Converting JSON Data Formats to XML</a>."</span></p>
</div>
</div>
<a id="BDCUG789"></a><a id="BDCUG790"></a><a id="BDCUG791"></a><a id="BDCUG674"></a>
<div class="sect4"><a id="GUID-75EDF233-E0C4-456B-81A4-1D178F0B7387"></a>
<h4 id="BDCUG-GUID-75EDF233-E0C4-456B-81A4-1D178F0B7387" class="sect4"><span class="enumeration_section">6.2.1.2</span> json:parse-as-xml</h4>
<div>
<p>Parses a JSON value as XML.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
json:parse-as-xml($arg as xs:string?) as element(*)?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$arg</code>: Can be the empty sequence.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>An XML element that models the JSON value. An empty sequence if <code class="codeph">$arg</code> is an empty sequence. See <span class="q">"<a href="oxh_ref.htm#GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903">About Converting JSON Data Formats to XML</a>."</span></p>
</div>
</div>
<a id="BDCUG792"></a><a id="BDCUG793"></a><a id="BDCUG794"></a><a id="BDCUG795"></a><a id="BDCUG679"></a>
<div class="sect4"><a id="GUID-A825CD41-07BD-4A53-8141-688C316DABE0"></a>
<h4 id="BDCUG-GUID-A825CD41-07BD-4A53-8141-688C316DABE0" class="sect4"><span class="enumeration_section">6.2.1.3</span> json:get</h4>
<div>
<p>Retrieves an entry from a JSON object modeled as XML. See <span class="q">"<a href="oxh_ref.htm#GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903">About Converting JSON Data Formats to XML</a>."</span></p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
json:get($key as xs:string?, $obj as node()?) as element(oxh:entry)?

json:get($key as xs:string?) as element(oxh:entry)?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$key</code>: The JSON data key</p>
<p><code class="codeph">$obj</code>: The JSON object value</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>The value of the following XPath expression:</p>
<pre dir="ltr">
$obj/oxh:entry[@key eq $key]
</pre>
<p>If <code class="codeph">$input</code> not present, then the behavior is identical to calling the two-argument function using the context item for <code class="codeph">$obj</code>. See the Notes.</p>
<div class="section">
<p class="subhead3">Notes</p>
</div>
<!-- class="section" -->
<p>These function calls are equivalent:</p>
<pre dir="ltr">
$var/json:get("key")

json:get("key", $var)

$var/oxh:entry[@key eq "key"]
 
</pre>
<p><code class="codeph">$var</code> is a JSON object modeled as XML. See <span class="q">"<a href="oxh_ref.htm#GUID-44BC1AEB-AE71-43D4-B1AA-1890E41A7A5C">Reading Maps</a>."</span></p>
</div>
</div>
</div>
<a id="BDCUG796"></a>
<div class="sect3"><a id="GUID-E4FBD869-B696-4473-A827-A66246361828"></a>
<h3 id="BDCUG-GUID-E4FBD869-B696-4473-A827-A66246361828" class="sect3"><span class="enumeration_section">6.2.2</span> Custom Functions for Reading JSON Files</h3>
<div>
<p>You can use the following annotations to define functions that read collections of JSON files in HDFS. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading JSON files must have the following signature:</p>
<pre dir="ltr">
declare %json:collection("jsonxml") [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as element()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-E4FBD869-B696-4473-A827-A66246361828__GUID-7EF0E388-8DB5-4056-A485-BBF91F37AB1C"><!-- --></a>%json:collection("jsonxml")</dt>
<dd>
<p>Declares the collection function. The annotation parameter must be <code class="codeph">jsonxml</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-E4FBD869-B696-4473-A827-A66246361828__GUID-EFFF7772-4D6A-470C-9494-04A2E98EEF72"><!-- --></a>%output:encoding("<span class="italic">charset</span>")</dt>
<dd>
<p>Identifies the text encoding of the input files.</p>
<p>The valid encodings are those supported by the JVM. If this annotation is omitted, then the encoding is automatically detected from the JSON file as UTF-8, UTF-16 big-endian serialization (BE) or little-endian serialization (LE), or UTF-32 (BE or LE).</p>
<p>For better performance, omit the encoding annotation if the actual file encoding is specified by JSON Request for Comment 4627, Section 3 "Encoding," on the Internet Engineering Task Force (IETF) website at</p>
<p><a href="http://www.ietf.org/rfc/rfc4627.txt" target="_blank"><code class="codeph">http://www.ietf.org/rfc/rfc4627.txt</code></a></p>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<dl>
<dt class="dlterm"><a id="GUID-E4FBD869-B696-4473-A827-A66246361828__GUID-767D56B9-62D9-4BE3-B460-CA119B443E2E"><!-- --></a>$uris as xs:string*</dt>
<dd>
<p>Lists the JSON file URIs. Required.</p>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Returns</p>
<p>A collection of XML elements. Each element models the corresponding JSON value. See <span class="q">"<a href="oxh_ref.htm#GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903">About Converting JSON Data Formats to XML</a>."</span></p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1059"></a><a id="BDCUG1060"></a><a id="BDCUG1061"></a><a id="BDCUG680"></a>
<div class="sect3"><a id="GUID-01AF8B30-1582-47E4-A830-098A09E60080"></a>
<h3 id="BDCUG-GUID-01AF8B30-1582-47E4-A830-098A09E60080" class="sect3"><span class="enumeration_section">6.2.3</span> Examples of JSON Functions</h3>
<div>
<div class="example" id="GUID-01AF8B30-1582-47E4-A830-098A09E60080__CHEJCAII">
<p class="titleinexample">Example 6-3</p>
<p>This example uses the following JSON text files stored in HDFS:</p>
<pre dir="ltr">
mydata/users1.json
[
{ "user" : "john", "full name" : "John Doe", "age" : 45 },
{ "user" : "kelly", "full name" : "Kelly Johnson", "age" : 32 }
]
 
mydata/users2.json 
[
{ "user" : "laura", "full name" : "Laura Smith", "age" : null },
{ "user" : "phil", "full name" : "Phil Johnson", "age" : 27 }
]
 
</pre>
<p>The following query selects names of users whose last name is Johnson from <code class="codeph">users1.json</code> and <code class="codeph">users2.json</code></p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:json";
 
for $user in json:collection-jsonxml("mydata/users*.json")/oxh:item
let $fullname := $user/json:get("full name")
where tokenize($fullname, "\s+")[2] eq "Johnson"
return 
   text:put-text($fullname)
</pre>
<p>This query generates text files that contain the following lines:</p>
<pre dir="ltr">
Phil Johnson
Kelly Johnson
</pre></div>
<!-- class="example" -->
<p>The remaining examples query the following text file in HDFS:</p>
<pre dir="ltr">
mydata/users-json.txt
 
{ "user" : "john", "full name" : "John Doe", "age" : 45 }
{ "user" : "kelly", "full name" : "Kelly Johnson", "age" : 32 }
{ "user" : "laura", "full name" : "Laura Smith", "age" : null }
{ "user" : "phil", "full name" : "Phil Johnson", "age" : 27 }
</pre>
<div class="example" id="GUID-01AF8B30-1582-47E4-A830-098A09E60080__GUID-F75ED55D-1BFD-4AFA-A70D-FD321EC4A47D">
<p class="titleinexample">Example 6-4</p>
<p>The following query selects the names of users that are older than 30 from <code class="codeph">users-json.txt</code>:</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:json";

for $line in text:collection("mydata/users-json.txt")
let $user := json:parse-as-xml($line)
where $user/json:get("age") gt 30
return 
   text:put($user/json:get("full name"))
</pre>
<p>This query generates text files that contain the following lines:</p>
<pre dir="ltr">
John Doe
Kelly Johnson
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-01AF8B30-1582-47E4-A830-098A09E60080__GUID-4F44C44D-931E-4F29-A875-0B2D0AB26F14">
<p class="titleinexample">Example 6-5</p>
<p>The next query selects the names of employees that have a null value for age from <code class="codeph">users-json.txt</code>:</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:json";

for $line in text:collection("mydata/users-json.txt")
let $user := json:parse-as-xml($line)
where $user/json:get("age")/nilled()
return 
   text:put($user/json:get("full name"))
 
</pre>
<p>This query generates a text file that contains the following line:</p>
<pre dir="ltr">
Laura Smith
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDCUG798"></a>
<div class="sect3"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD"></a>
<h3 id="BDCUG-GUID-046EB306-3E8D-4551-B0F7-2957E00462FD" class="sect3"><span class="enumeration_section">6.2.4</span> JSON File Adapter Configuration Properties</h3>
<div>
<p>Oracle XQuery for Hadoop uses the generic options for specifying configuration properties in the <code class="codeph">hadoop</code> command. You can use the <code class="codeph">-conf</code> option to identify configuration files, and the <code class="codeph">-D</code> option to specify individual properties.</p>
<p>The following configuration properties are equivalent to the Jackson parser options with the same names. You can enter the option name in either upper or lower case. For example, <code class="codeph">oracle.hadoop.xquery.json.parser.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER</code> and <code class="codeph">oracle.hadoop.xquery.json.parser.allow_backslash_escaping_any_character</code> are equal.</p>
<dl>
<dt class="dlterm"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD__GUID-1D08A811-580B-4B45-BCE9-46A84A781380"><!-- --></a>oracle.hadoop.xquery.json.parser.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER</dt>
<dd>
<p><span class="bold">Type</span>: Boolean</p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Description</span>: Enables any character to be escaped with a backslash (\). Otherwise, only the following characters can be escaped: quotation mark("), slash (/), backslash (\), backspace, form feed (f), new line (n), carriage return (r), horizontal tab (t), and hexadecimal representations (<code class="codeph">u</code><span class="italic"><code class="codeph">nnnn</code></span>)</p>
</dd>
<dt class="dlterm"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD__GUID-0E589121-239E-402A-8F7D-DB384570B59D"><!-- --></a>oracle.hadoop.xquery.json.parser.ALLOW_COMMENTS</dt>
<dd>
<p><span class="bold">Type</span>: Boolean</p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Description</span>: Allows Java and C++ comments (/* and //) within the parsed text.</p>
</dd>
<dt class="dlterm"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD__GUID-E9C56FC0-12BD-44FD-A314-4F76D3D79D59"><!-- --></a>oracle.hadoop.xquery.json.parser.ALLOW_NON_NUMERIC_NUMBERS</dt>
<dd>
<p><span class="bold">Type</span>: Boolean</p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Description</span>: Allows Not a Number (NaN) tokens to be parsed as floating number values.</p>
</dd>
<dt class="dlterm"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD__GUID-AF7CA143-D4BA-4459-A112-EA81B1F00534"><!-- --></a>oracle.hadoop.xquery.json.parser.ALLOW_NUMERIC_LEADING_ZEROS</dt>
<dd>
<p><span class="bold">Type</span>: Boolean</p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Description</span>: Allows integral numbers to start with zeroes, such as 00001. The zeros do not change the value and can be ignored.</p>
</dd>
<dt class="dlterm"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD__GUID-774D7A81-ECED-4CDC-900A-E4EC0DA29421"><!-- --></a>oracle.hadoop.xquery.json.parser.ALLOW_SINGLE_QUOTES</dt>
<dd>
<p><span class="bold">Type</span>: Boolean</p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Description</span>: Allow single quotes (') to delimit string values.</p>
</dd>
<dt class="dlterm"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD__GUID-C17C80B7-E8DA-40F4-935F-C38B0D59E135"><!-- --></a>oracle.hadoop.xquery.json.parser.ALLOW_UNQUOTED_CONTROL_CHARS</dt>
<dd>
<p><span class="bold">Type</span>: Boolean</p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Description</span>: Allows JSON strings to contain unquoted control characters (that is, ASCII characters with a decimal value less than 32, including the tab and line feed).</p>
</dd>
<dt class="dlterm"><a id="GUID-046EB306-3E8D-4551-B0F7-2957E00462FD__GUID-368D58DA-F971-4C08-A909-A2ABAAE855A1"><!-- --></a>oracle.hadoop.xquery.json.parser.ALLOW_UNQUOTED_FIELD_NAMES</dt>
<dd>
<p><span class="bold">Type</span>: Boolean</p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Description</span>: Allows unquoted field names, which are allowed by Javascript but not the JSON specification.</p>
</dd>
</dl>
</div>
<div>
<div class="relinfo">
<p><strong>Related Topics</strong></p>
<ul>
<li><a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a></li>
</ul>
</div>
</div>
</div>
<a id="BDCUG799"></a>
<div class="sect3"><a id="GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903"></a>
<h3 id="BDCUG-GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903" class="sect3"><span class="enumeration_section">6.2.5</span> About Converting JSON Data Formats to XML</h3>
<div>
<p>This section describes how JSON data formats are converted to XML. It contains the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-3C447BC5-6BF3-4F49-82B9-D8B14F496255">About Converting JSON Objects to XML</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-FB2B7F8F-4B15-411C-962D-7FAD6A4641F4">About Converting JSON Arrays to XML</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-5FDC6250-3191-475F-A0E3-D19D1229FCB0">About Converting Other JSON Types</a></p>
</li>
</ul>
<p>As of Big Data Connectors Release 4.9, Oracle XQuery for Hadoop also supports XQuery 3.1 including the standard facilities for processing JSON, including: <code class="codeph">fn:parse-json</code>, <code class="codeph">fn:json-to-xml</code>, and <code class="codeph">fn:xml-to-json</code></p>
<div class="infoboxnotealso" id="GUID-E7DA0DDB-A1B9-4DDD-9BB7-A33320559903__XPATHANDXQUERYFUNCTIONSANDOPERATORS-E54F8393">
<p class="notep1">See Also:</p>
<a href="https://www.w3.org/TR/xpath-functions-31/" target="_blank">XPath and XQuery Functions and Operators 3.1</a></div>
</div>
<a id="BDCUG800"></a>
<div class="sect4"><a id="GUID-3C447BC5-6BF3-4F49-82B9-D8B14F496255"></a>
<h4 id="BDCUG-GUID-3C447BC5-6BF3-4F49-82B9-D8B14F496255" class="sect4"><span class="enumeration_section">6.2.5.1</span> About Converting JSON Objects to XML</h4>
<div>
<p>JSON objects are similar to Avro maps and are converted to the same XML structure. See <span class="q">"<a href="oxh_ref.htm#GUID-44BC1AEB-AE71-43D4-B1AA-1890E41A7A5C">Reading Maps</a>."</span></p>
<p>For example, the following JSON object is converted to an XML element:</p>
<pre dir="ltr">
{ 
   "user" : "john", 
   "full_name" : "John Doe", 
   "age" : 45 
}
</pre>
<p>The object is modeled as the following element:</p>
<pre dir="ltr">
&lt;oxh:item&gt;
    &lt;oxh:entry key="user"&gt;john&lt;/oxh:entry&gt;
    &lt;oxh:entry key="full_name"&gt;John Doe&lt;/oxh:entry&gt;
    &lt;oxh:entry key="age"&gt;45&lt;/oxh:entry&gt;
&lt;/oxh:item&gt;
</pre></div>
</div>
<a id="BDCUG801"></a>
<div class="sect4"><a id="GUID-FB2B7F8F-4B15-411C-962D-7FAD6A4641F4"></a>
<h4 id="BDCUG-GUID-FB2B7F8F-4B15-411C-962D-7FAD6A4641F4" class="sect4"><span class="enumeration_section">6.2.5.2</span> About Converting JSON Arrays to XML</h4>
<div>
<p>JSON arrays are similar to Avro arrays and are converted to the same XML structure. See <span class="q">"<a href="oxh_ref.htm#GUID-EB0C99F1-E74E-4FC3-9D01-64F47786A0C9">Reading Arrays</a>."</span></p>
<p>For example, the following JSON array is converted to an XML element:</p>
<pre dir="ltr">
[ "red", "blue", "green" ]
</pre>
<p>The array is modeled as the following element:</p>
<pre dir="ltr">
&lt;oxh:item&gt;
   &lt;oxh:item&gt;red&lt;/oxh:item&gt;
   &lt;oxh:item&gt;blue&lt;/oxh:item&gt;
   &lt;oxh:item&gt;green&lt;/oxh:item&gt;
&lt;/oxh:item&gt;
</pre></div>
</div>
<a id="BDCUG678"></a><a id="BDCUG802"></a>
<div class="sect4"><a id="GUID-5FDC6250-3191-475F-A0E3-D19D1229FCB0"></a>
<h4 id="BDCUG-GUID-5FDC6250-3191-475F-A0E3-D19D1229FCB0" class="sect4"><span class="enumeration_section">6.2.5.3</span> About Converting Other JSON Types</h4>
<div>
<p>The other JSON values are mapped as shown in the following table.</p>
<div class="tblformal" id="GUID-5FDC6250-3191-475F-A0E3-D19D1229FCB0__BABHFAGA">
<p class="titleintable">Table 6-2 JSON Type Conversions</p>
<table class="cellalignment8" title="JSON Type Conversions" summary="JSON to XML type conversions">
<thead>
<tr class="cellalignment2">
<th class="cellalignment69" id="d37476e2511">JSON</th>
<th class="cellalignment70" id="d37476e2514">XML</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment71" id="d37476e2519" headers="d37476e2511">
<p>null</p>
</td>
<td class="cellalignment72" headers="d37476e2519 d37476e2514">
<p>An empty (nilled) element</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment71" id="d37476e2526" headers="d37476e2511">
<p>true/false</p>
</td>
<td class="cellalignment72" headers="d37476e2526 d37476e2514">
<p><code class="codeph">xs:boolean</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment71" id="d37476e2534" headers="d37476e2511">
<p>number</p>
</td>
<td class="cellalignment72" headers="d37476e2534 d37476e2514">
<p><code class="codeph">xs:decimal</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment71" id="d37476e2542" headers="d37476e2511">
<p>string</p>
</td>
<td class="cellalignment72" headers="d37476e2542 d37476e2514">
<p><code class="codeph">xs:string</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
</div>
<a id="BDCUG597"></a>
<div class="sect2"><a id="GUID-45EAD813-5A24-4D95-9B7D-DA343A572EE9"></a>
<h2 id="BDCUG-GUID-45EAD813-5A24-4D95-9B7D-DA343A572EE9" class="sect2"><span class="enumeration_section">6.3</span> Oracle Database Adapter</h2>
<div>
<p>The<a id="d37476e2570" class="indexterm-anchor"></a><a id="d37476e2572" class="indexterm-anchor"></a><a id="d37476e2576" class="indexterm-anchor"></a> Oracle Database adapter provides custom functions for loading data into tables in Oracle Database.</p>
<p>A custom put function supported by this adapter automatically calls Oracle Loader for Hadoop at run time, either to load the data immediately or to output it to HDFS. You can declare and use multiple custom Oracle Database adapter put functions within a single query. For example, you might load data into different tables or into different Oracle databases with a single query.</p>
<p>Ensure that <a id="d37476e2583" class="indexterm-anchor"></a>Oracle Loader for Hadoop is installed on your system, and that the <code class="codeph">OLH_HOME</code> environment variable is set to the installation directory. See Step 3 of <span class="q">"<a href="start.htm#GUID-E5EB1E76-518C-4FF6-9369-AF4C81F7B12D">Installing Oracle XQuery for Hadoop</a>."</span> Although not required, you might find it helpful to familiarize yourself with Oracle Loader for Hadoop before using this adapter.</p>
<p>The Oracle Database adapter is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-805992BB-7206-41F8-9082-E487650C5066">Custom Functions for Writing to Oracle Database</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-EE71E7C2-BBC7-448D-B72F-58C456051277">Examples of Oracle Database Adapter Functions</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-FFF7CD75-28B6-4AEE-BEDC-293026CE7626">Oracle Loader for Hadoop Configuration Properties and Corresponding %oracle-property Annotations</a></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-45EAD813-5A24-4D95-9B7D-DA343A572EE9__GUID-7978E486-DE6B-44AB-8AB8-5334853CC0AF">
<p class="notep1">See Also:</p>
<p><span class="q">"<a href="start.htm#GUID-7C8CCFD8-E8A9-42EF-8659-B550012B25EE">Software Requirements</a>"</span> for the versions of Oracle Database that Oracle Loader for Hadoop supports</p>
</div>
</div>
<a id="BDCUG599"></a><a id="BDCUG600"></a><a id="BDCUG598"></a>
<div class="sect3"><a id="GUID-805992BB-7206-41F8-9082-E487650C5066"></a>
<h3 id="BDCUG-GUID-805992BB-7206-41F8-9082-E487650C5066" class="sect3"><span class="enumeration_section">6.3.1</span> Custom Functions for Writing to Oracle Database</h3>
<div>
<p><a id="d37476e2662" class="indexterm-anchor"></a><a id="d37476e2666" class="indexterm-anchor"></a><a id="d37476e2670" class="indexterm-anchor"></a>You can use the following annotations to define functions that write to tables in an Oracle database either directly or by generating binary or text files for subsequent loading with another utility, such as SQL*Loader.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for writing to Oracle database tables must have the following signature:</p>
<pre dir="ltr">
declare %oracle:put(["jdbc" | "oci" | "text" | "datapump"])
   [%oracle:columns(col1 [, col2...])] [<span class="italic">%oracle-property annotations</span>]
   function local:<span class="italic">myPut</span>($column1 [as xs:allowed_type_name[?]], [$column2 [as xs:allowed_type_name[?]], ...]) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-805992BB-7206-41F8-9082-E487650C5066__GUID-F12F03E7-06AB-468D-8B29-41869E9F87A9"><!-- --></a>%oracle:put("<span class="italic">output_mode</span>"?)</dt>
<dd>
<p>Declares the put function and the output mode. Required.</p>
<p>The optional <span class="italic">output_mode</span> parameter can be one of the following string literal values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">jdbc</code>: Writes to an Oracle database table using a JDBC connection. Default.</p>
<p>See <span class="q">"<a href="olh.htm#GUID-0B2E5A4B-A6D1-47E4-97C1-37D27A156C05">JDBC Output Format</a>."</span></p>
</li>
<li>
<p><code class="codeph">oci</code>: Writes to an Oracle database table using an Oracle Call Interface (OCI) connection.</p>
<p>See <span class="q">"<a href="olh.htm#GUID-15DE7B55-E308-4965-8B9E-8F37FB6B4A3B">Oracle OCI Direct Path Output Format</a>."</span></p>
</li>
<li>
<p><code class="codeph">datapump</code>: Creates Data Pump files and associated scripts in HDFS for subsequent loading by another utility.</p>
<p>See <span class="q">"<a href="olh.htm#GUID-02512C0C-1B34-4CD0-AC0A-01BC053B28FE">Oracle Data Pump Output Format</a>."</span></p>
</li>
<li>
<p><code class="codeph">text</code>: Creates delimited text files and associated scripts in HDFS.</p>
<p>See <span class="q">"<a href="olh.htm#GUID-052CF2D1-3F5C-4652-A894-6CFBE40402D5">Delimited Text Output Format</a>."</span></p>
</li>
</ul>
<p>For Oracle XQuery for Hadoop to write directly to an Oracle database table using either JDBC or OCI, all systems involved in processing the query must be able to connect to the Oracle Database system. See <span class="q">"<a href="olh.htm#GUID-3D76103E-6620-42F9-924B-36DEAA1BF483">About the Modes of Operation</a>."</span></p>
</dd>
<dt class="dlterm"><a id="GUID-805992BB-7206-41F8-9082-E487650C5066__GUID-9F40AA0F-D899-4626-AD58-CC537B47600D"><!-- --></a>%oracle:columns(<span class="italic">col1</span> [, <span class="italic">col2</span>...])</dt>
<dd>
<p>Identifies a selection of one or more column names in the target table. The order of column names corresponds to the order of the function parameters. See <span class="q">"<a href="oxh_ref.htm#GUID-805992BB-7206-41F8-9082-E487650C5066__BABCBBFD">Parameters</a>."</span> Optional.</p>
<p>This annotation enables loading a subset of the table columns. If omitted, the put function attempts to load all columns of the target table.</p>
</dd>
<dt class="dlterm"><a id="GUID-805992BB-7206-41F8-9082-E487650C5066__GUID-8FA60EFD-0A31-4F94-AD2B-8AD37246BE0F"><!-- --></a>%oracle-property:<span class="italic">property_name</span> (<span class="italic">value</span>)</dt>
<dd>
<p>Controls various aspects of connecting to the database and writing data. You can specify multiple <code class="codeph">%oracle-property</code> annotations. These annotations correspond to the Oracle Loader for Hadoop configuration properties. Every <code class="codeph">%oracle-property</code> annotation has an equivalent Oracle Loader for Hadoop configuration property. <span class="q">"<a href="oxh_ref.htm#GUID-FFF7CD75-28B6-4AEE-BEDC-293026CE7626">Oracle Loader for Hadoop Configuration Properties and Corresponding %oracle-property Annotations</a>"</span> explains this relationship in detail.</p>
<p>The <code class="codeph">%oracle-property</code> annotations are optional. However, the various loading scenarios require you to specify some of them or their equivalent configuration properties. For example, to load data into an Oracle database using JDBC or OCI, you must specify the target table and the connection information.</p>
<p>The following example specifies a target table named <code class="codeph">VISITS</code>, a user name of <code class="codeph">db</code>, a password of <code class="codeph">password</code>, and the URL connection string:</p>
<div class="p">
<pre dir="ltr">
%oracle-property:targetTable('visits')
%oracle-property:connection.user('db')
%oracle-property:connection.password('password')
%oracle-property:connection.url('jdbc:oracle:thin:@//localhost:1521/orcl.example.com')
</pre></div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section" id="GUID-805992BB-7206-41F8-9082-E487650C5066__BABCBBFD">
<p class="subhead3">Parameters</p>
<dl>
<dt class="dlterm"><a id="GUID-805992BB-7206-41F8-9082-E487650C5066__GUID-9451EF25-058B-4720-AB36-FDF16A7AA87B"><!-- --></a>$column1 [as xs:allowed_type_name[?]], [$column2 [as xs:allowed_type_name[?]],...]</dt>
<dd>
<p>Enter a parameter for each column in the same order as the Oracle table columns to load all columns, or use the <code class="codeph">%oracle:columns</code> annotation to load selected columns.</p>
<p>Because the correlation between parameters and database columns is positional, the name of the parameter (<span class="italic">column1</span> in the parameter syntax) is not required to match the name of the database column.</p>
<p>You can omit the explicit <code class="codeph">as xs:allowed_type_name</code> type declaration for any parameter. For example, you can declare the parameter corresponding to a <code class="codeph">NUMBER</code> column simply as <code class="codeph">$column1</code>. In this case, the parameter is automatically assigned an XQuery type of <code class="codeph">item()*</code>. At run time, the input value is cast to the allowed XQuery type for the corresponding table column type, as described in the following table. For example, data values that are mapped to a column with a <code class="codeph">NUMBER</code> data type are automatically cast as <code class="codeph">xs:decimal</code>. An error is raised if the cast fails.</p>
<p>Alternatively, you can specify the type or its subtype for any parameter. In this case, compile-time type checking is performed. For example, you can declare a parameter corresponding to a <code class="codeph">NUMBER</code> column as <code class="codeph">$column as xs:decimal</code>. You can also declare it as any subtype of <code class="codeph">xs:decimal</code>, such as <code class="codeph">xs:integer</code>.</p>
<p>You can include the <code class="codeph">?</code> optional occurrence indicator for each specified parameter type. This indicator allows the empty sequence to be passed as a parameter value at run time, so that a null is inserted into the database table. Any occurrence indicator other than <code class="codeph">?</code> raises a compile-time error.</p>
<p>The following table describes the appropriate mappings of XQuery data types with the supported Oracle Database data types. In addition to the listed XQuery data types, you can also use the subtypes, such as <code class="codeph">xs:integer</code> instead of <code class="codeph">xs:decimal</code>. Oracle data types are more restrictive than XQuery data types, and these restrictions are identified in the table.<a id="d37476e2887" class="indexterm-anchor"></a><a id="d37476e2891" class="indexterm-anchor"></a></p>
</dd>
</dl>
<div class="tblformal" id="GUID-805992BB-7206-41F8-9082-E487650C5066__CHEJDDHI">
<p class="titleintable">Table 6-3 Data Type Mappings Between Oracle Database and XQuery</p>
<table class="cellalignment8" title="Data Type Mappings Between Oracle Database and XQuery" summary="Database data type to XQuery data type conversions">
<thead>
<tr class="cellalignment2">
<th class="cellalignment61" id="d37476e2905">Database Type</th>
<th class="cellalignment62" id="d37476e2908">XQuery Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e2913" headers="d37476e2905">
<p><code class="codeph">VARCHAR2</code></p>
</td>
<td class="cellalignment64" headers="d37476e2913 d37476e2908">
<p><code class="codeph">xs:string</code></p>
<p>Limited by the <code class="codeph">VARCHAR2</code> maximum size of 4000 bytes.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e2927" headers="d37476e2905">
<p><code class="codeph">CHAR</code></p>
</td>
<td class="cellalignment64" headers="d37476e2927 d37476e2908">
<p><code class="codeph">xs:string</code></p>
<p>Limited by the <code class="codeph">CHAR</code> maximum size of 2000 bytes.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e2941" headers="d37476e2905">
<p><code class="codeph">NVARCHAR2</code></p>
</td>
<td class="cellalignment64" headers="d37476e2941 d37476e2908">
<p><code class="codeph">xs:string</code></p>
<p>Limited by the <code class="codeph">NVARCHAR2</code> maximum size of 4000 bytes.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e2955" headers="d37476e2905">
<p><code class="codeph">NCHAR</code></p>
</td>
<td class="cellalignment64" headers="d37476e2955 d37476e2908">
<p><code class="codeph">xs:string</code></p>
<p>Limited by the <code class="codeph">NCHAR</code> maximum size of 2000 bytes.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e2969" headers="d37476e2905">
<p><code class="codeph">DATE</code></p>
</td>
<td class="cellalignment64" headers="d37476e2969 d37476e2908">
<p><code class="codeph">xs:dateTime</code></p>
<p>Limited to the range of January 1, 4712 BC, to December 31, 9999 CE. If a time zone is specified in the <code class="codeph">xs:dateTime</code> value, then the time zone information is dropped. Fractional seconds are also dropped. A time value of 24:00:00 is not valid.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e2983" headers="d37476e2905">
<p><code class="codeph">TIMESTAMP</code></p>
</td>
<td class="cellalignment64" headers="d37476e2983 d37476e2908">
<p><code class="codeph">xs:dateTime</code></p>
<p>Limited to the range of January 1, 4712 BC, to December 31, 9999 CE. If a time zone is specified in the <code class="codeph">xs:dateTime</code> value, then the time zone information is dropped. Fractional seconds are limited to a precision of 0 to 9 digits. A time value of 24:00:00 is not valid.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e2997" headers="d37476e2905">
<p><code class="codeph">TIMESTAMP W LOCAL TIME ZONE</code></p>
</td>
<td class="cellalignment64" headers="d37476e2997 d37476e2908">
<p><code class="codeph">xs:dateTime</code></p>
<p>Limited to the range of January 1, 4712 BC, to December 31, 9999 CE. In the offset from UTC, the time-zone hour field is limited to -12:00 to 14:00. Fractional seconds are limited to a precision of 0 to 9 digits.</p>
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-805992BB-7206-41F8-9082-E487650C5066__BABFICHI">About Session Time Zones</a>."</span></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3014" headers="d37476e2905">
<p><code class="codeph">TIMESTAMP W TIME ZONE</code></p>
</td>
<td class="cellalignment64" headers="d37476e3014 d37476e2908">
<p><code class="codeph">xs:dateTime</code></p>
<p>Limited to the range of January 1, 4712 BC, to December 31, 9999 CE. In the offset from UTC, the time-zone hour field is limited to -12:00 to 14:00. Fractional seconds are limited to a precision of 0 to 9 digits.</p>
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-805992BB-7206-41F8-9082-E487650C5066__BABFICHI">About Session Time Zones</a>."</span></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3031" headers="d37476e2905">
<p><code class="codeph">INTERVAL DAY TO SECOND</code></p>
</td>
<td class="cellalignment64" headers="d37476e3031 d37476e2908">
<p><code class="codeph">xs:dateTimeDuration</code></p>
<p>The day and fractional seconds are limited by a precision of 0 to 9 digits each. The hour is limited to a range of 0 to 23, and minutes and seconds are limited to a range of 0 to 59.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3042" headers="d37476e2905">
<p><code class="codeph">INTERVAL YEAR TO MONTH</code></p>
</td>
<td class="cellalignment64" headers="d37476e3042 d37476e2908">
<p><code class="codeph">xs:yearMonthDuration</code></p>
<p>The year is limited by a precision of 0 to 9 digits, and the month is limited to a range of 0 to 11.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3053" headers="d37476e2905">
<p><code class="codeph">BINARY_FLOAT</code></p>
</td>
<td class="cellalignment64" headers="d37476e3053 d37476e2908">
<p><code class="codeph">xs:float</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3063" headers="d37476e2905">
<p><code class="codeph">BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment64" headers="d37476e3063 d37476e2908">
<p><code class="codeph">xs:double</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3072" headers="d37476e2905">
<p><code class="codeph">NUMBER</code></p>
</td>
<td class="cellalignment64" headers="d37476e3072 d37476e2908">
<p><code class="codeph">xs:decimal</code></p>
<p>Limited by the <code class="codeph">NUMBER</code> precision of 1 to 38 decimal digits and scale of -84 to 127 decimal digits.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3086" headers="d37476e2905">
<p><code class="codeph">FLOAT</code></p>
</td>
<td class="cellalignment64" headers="d37476e3086 d37476e2908">
<p><code class="codeph">xs:decimal</code></p>
<p>Limited by the <code class="codeph">FLOAT</code> precision of 1 to 126 binary digits.</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment63" id="d37476e3100" headers="d37476e2905">
<p><code class="codeph">RAW</code></p>
</td>
<td class="cellalignment64" headers="d37476e3100 d37476e2908">
<p><code class="codeph">xs:hexBinary</code></p>
<p>Limit by the <code class="codeph">RAW</code> maximum size of 2000 bytes.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p id="GUID-805992BB-7206-41F8-9082-E487650C5066__BABFICHI">About Session Time Zones</p>
<p>If an <code class="codeph">xs:dateTime</code> value with no<a id="d37476e3120" class="indexterm-anchor"></a> time zone is loaded into <code class="codeph">TIMESTAMP W TIME ZONE</code> or <code class="codeph">TIMESTAMP W LOCAL TIME ZONE</code>, then the time zone is set to the value of the <code class="codeph">sessionTimeZone</code> parameter, which defaults to the JVM time zone. Using Oracle XQuery for Hadoop, you can set the <code class="codeph">sessionTimeZone</code> property, as described in <span class="q">"<a href="oxh_ref.htm#GUID-FFF7CD75-28B6-4AEE-BEDC-293026CE7626">Oracle Loader for Hadoop Configuration Properties and Corresponding %oracle-property Annotations</a>."</span></p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Notes</p>
<p>With JDBC or OCI output modes, the Oracle Database Adapter loads data directly into the database table. It also creates a directory with the same name as the custom <code class="codeph">put</code> function name, under the query output directory. For example, if your query output directory is myoutput, and your custom function is <code class="codeph">myPut</code>, then the <code class="codeph">myoutput/myPut</code> directory is created.</p>
<p>For every custom Oracle Database Adapter put function, a separate directory is created. This directory contains output produced by the Oracle Loader for Hadoop job. When you use <code class="codeph">datapump</code> or <code class="codeph">text</code> output modes, the data files are written to this directory. The control and SQL scripts for loading the files are written to the <code class="codeph">_olh</code> subdirectory, such as <code class="codeph">myoutput/myPut/_olh</code>.</p>
<p>For descriptions of the generated files, see <span class="q">"<a href="olh.htm#GUID-052CF2D1-3F5C-4652-A894-6CFBE40402D5">Delimited Text Output Format</a>"</span> and <span class="q">"<a href="olh.htm#GUID-02512C0C-1B34-4CD0-AC0A-01BC053B28FE">Oracle Data Pump Output Format</a>."</span></p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1062"></a><a id="BDCUG1063"></a><a id="BDCUG803"></a>
<div class="sect3"><a id="GUID-EE71E7C2-BBC7-448D-B72F-58C456051277"></a>
<h3 id="BDCUG-GUID-EE71E7C2-BBC7-448D-B72F-58C456051277" class="sect3"><span class="enumeration_section">6.3.2</span> Examples of Oracle Database Adapter Functions</h3>
<div>
<p>These examples use the following text files in HDFS. The files contain a log of visits to different web pages. Each line represents a visit to a web page and contains the time, user name, and page visited:</p>
<pre dir="ltr">
mydata/visits1.log  
 
2013-10-28T06:00:00, john, index.html, 200
2013-10-28T08:30:02, kelly, index.html, 200
2013-10-28T08:32:50, kelly, about.html, 200
2013-10-30T10:00:10, mike, index.html, 401

mydata/visits2.log  

2013-10-30T10:00:01, john, index.html, 200
2013-10-30T10:05:20, john, about.html, 200
2013-11-01T08:00:08, laura, index.html, 200
2013-11-04T06:12:51, kelly, index.html, 200
2013-11-04T06:12:40, kelly, contact.html, 200
</pre>
<p>The examples also use the following file in HDFS, which contains anonymous page visits:</p>
<pre dir="ltr">
mydata/anonvisits.log
 
2011-10-30T10:01:01, index.html, 401
2011-11-04T06:15:40, contact.html, 401
</pre>
<p>This SQL command creates the <code class="codeph">VISITS</code> table in the Oracle database:</p>
<pre dir="ltr">
CREATE TABLE visits (time TIMESTAMP, name VARCHAR2(15), page VARCHAR2(15), code NUMBER)
</pre>
<div class="example" id="GUID-EE71E7C2-BBC7-448D-B72F-58C456051277__GUID-78A1E440-9F49-4EA1-A7E4-BF03CD157BA2">
<p class="titleinexample">Example 6-6 Loading All Columns</p>
<p>The first query loads all information related to the page visit (time of visit, user name, page visited, and status code) to the <code class="codeph">VISITS</code> table. For anonymous access, the user name is missing, therefore the query specifies <code class="codeph">()</code> to insert a null into the table. The target table name, user name, password, and connection URL are specified with <code class="codeph">%oracle-property</code> annotations.</p>
<p>The example uses a clear-text user name and password, which is insecure but acceptable in a development environment. Oracle recommends that you use a wallet instead for security, especially in a production application. You can configure an Oracle wallet using either Oracle Loader for Hadoop properties or their equivalent <code class="codeph">%oracle-property</code> annotations. The specific properties that you must set are described in <span class="q">"<a href="olh.htm#GUID-03BFB4D6-1CD2-4EC6-84B0-5970E74A8740">Providing the Connection Details for Online Database Mode</a>."</span></p>
<pre dir="ltr">
import module "oxh:text";
 
declare
   %oracle:put
   %oracle-property:targetTable('visits')
   %oracle-property:connection.user('db')
   %oracle-property:connection.password('password')
   %oracle-property:connection.url('jdbc:oracle:thin:@//localhost:1521/orcl.example.com')
function local:myPut($c1, $c2, $c3, $c4) external;
 
for $line in text:collection("mydata/*visits*.log")
let $split := fn:tokenize($line, "\s*,\s*")
return
   if (count($split) &gt; 3) then
      local:myPut($split[1], $split[2], $split[3], $split[4])
   else
      local:myPut($split[1], (), $split[2], $split[3])
 
</pre>
<p>The <code class="codeph">VISITS</code> table contains the following data after the query runs:</p>
<pre dir="ltr">
TIME                           NAME            PAGE                  CODE
------------------------------ --------------- --------------- ----------
30-OCT-13 10.00.01.000000 AM   john            index.html             200
30-OCT-13 10.05.20.000000 AM   john            about.html             200
01-NOV-13 08.00.08.000000 AM   laura           index.html             200
04-NOV-13 06.12.51.000000 AM   kelly           index.html             200
04-NOV-13 06.12.40.000000 AM   kelly           contact.html           200
28-OCT-13 06.00.00.000000 AM   john            index.html             200
28-OCT-13 08.30.02.000000 AM   kelly           index.html             200
28-OCT-13 08.32.50.000000 AM   kelly           about.html             200
30-OCT-13 10.00.10.000000 AM   mike            index.html             401
30-OCT-11 10.01.01.000000 AM                   index.html             401
04-NOV-11 06.15.40.000000 AM                   contact.html           401
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-EE71E7C2-BBC7-448D-B72F-58C456051277__GUID-5A6AA4C1-3A0B-4869-B3FB-22B7F83F7800">
<p class="titleinexample">Example 6-7 Loading Selected Columns</p>
<p>This example uses the <code class="codeph">%oracle:columns</code> annotation to load only the <code class="codeph">time</code> and <code class="codeph">name</code> columns of the table. It also loads only visits by <code class="codeph">john</code>.</p>
<p>The column names specified in <code class="codeph">%oracle:columns</code> are positionally correlated to the put function parameters. Data values provided for the <code class="codeph">$c1</code> parameter are loaded into the <code class="codeph">TIME</code> column, and data values provided for the <code class="codeph">$c2</code> parameter are loaded into the <code class="codeph">NAME</code> column.</p>
<pre dir="ltr">
import module "oxh:text";

declare
   %oracle:put
   %oracle:columns('time', 'name')
   %oracle-property:targetTable('visits')
   %oracle-property:connection.user('db')
   %oracle-property:connection.password('password')
   %oracle-property:connection.url('jdbc:oracle:thin:@//localhost:1521/orcl.example.com')
function local:myPut($c1, $c2) external;
 
for $line in text:collection("mydata/*visits*.log")
let $split := fn:tokenize($line, "\s*,\s*")
where $split[2] eq 'john'
return
   local:myPut($split[1], $split[2])
 
</pre>
<p>If the <code class="codeph">VISITS</code> table is empty before the query runs, then it contains the following data afterward:</p>
<pre dir="ltr">
TIME                           NAME            PAGE                 CODE
------------------------------ --------------- --------------- ----------
30-OCT-13 10.00.01.000000 AM   john
30-OCT-13 10.05.20.000000 AM   john
28-OCT-13 06.00.00.000000 AM   john
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDCUG604"></a><a id="BDCUG603"></a>
<div class="sect3"><a id="GUID-FFF7CD75-28B6-4AEE-BEDC-293026CE7626"></a>
<h3 id="BDCUG-GUID-FFF7CD75-28B6-4AEE-BEDC-293026CE7626" class="sect3"><span class="enumeration_section">6.3.3</span> Oracle Loader for Hadoop Configuration Properties and Corresponding %oracle-property Annotations</h3>
<div>
<p>When you use the Oracle Database adapter of Oracle XQuery for Hadoop, you indirectly use Oracle Loader for Hadoop. Oracle Loader for Hadoop defines configuration properties that control various aspects of connecting to Oracle Database and writing data. Oracle XQuery for Hadoop supports many of these properties, which are listed in the last column of the table below.</p>
<p>You can specify these properties with the generic <code class="codeph">-conf</code> and <code class="codeph">-D</code> <code class="codeph">hadoop</code> command-line options in Oracle XQuery for Hadoop. Properties specified using this method apply to all Oracle Database adapter put functions in your query. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>"</span> and especially <span class="q">"<a href="oxh.htm#GUID-6F7FDEB0-B55F-468A-B103-08C39BB3998C">Generic Options</a>"</span> for more information about the <code class="codeph">hadoop</code> command-line options.</p>
<p>Alternatively, you can specify these properties as Oracle Database adapter put function annotations with the <code class="codeph">%oracle-property</code> prefix. These annotations are listed in the second column of the table below. Annotations apply only to the particular Oracle Database adapter put function that contains them in its declaration.</p>
<p>For example, you can set the target table to <code class="codeph">VISITS</code> by adding the following lines to the configuration file, and identifying the configuration file with the <code class="codeph">-conf</code> option:</p>
<pre dir="ltr">
&lt;property&gt;
   &lt;name&gt;oracle.hadoop.loader.targetTable&lt;/name&gt;
   &lt;value&gt;visits&lt;/value&gt;
&lt;/property&gt;
 
</pre>
<p>You can also set the target table to <code class="codeph">VISITS</code> with the <code class="codeph">-D</code> option, using the same Oracle Loader for Hadoop property:</p>
<pre dir="ltr">
-D oracle.hadoop.loader.targetTable=visits
 
</pre>
<p>Both methods set the target table to <code class="codeph">VISITS</code> for all Oracle Database adapter put functions in your query.</p>
<p>Alternatively, this annotation sets the target table to <code class="codeph">VISITS</code> only for the particular put function that has the annotation in the declaration:</p>
<pre dir="ltr">
%oracle-property:connection.url('visits')
 
</pre>
<p>This flexibility is provided for convenience. For example, if a query has multiple Oracle Database adapter put functions, each writing to a different table in the same database, then the most convenient way to specify the necessary information is like this:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use the <code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJCAAI">oracle.hadoop.loader.connection.url</a></code> property in the configuration file to specify the database connection URL. Then identify the configuration file using the <code class="codeph">-conf</code> option. This option sets the same database connection URL for all Oracle Database adapter put functions in your query.</p>
</li>
<li>
<p>Set a different table name using the <code class="codeph">%oracle-property:targetTable</code> annotation in each Oracle Database adapter put function declaration.</p>
</li>
</ul>
<p>The following table identifies the Oracle Loader for Hadoop properties and their equivalent Oracle XQuery for Hadoop annotations by functional category. Oracle XQuery for Hadoop supports only the Oracle Loader for Hadoop properties listed in this table.</p>
<div class="tblformalwide" id="GUID-FFF7CD75-28B6-4AEE-BEDC-293026CE7626__BABGGEJH">
<p class="titleintable">Table 6-4 Configuration Properties and Corresponding %oracle-property Annotations</p>
<table class="cellalignment23" title="Configuration Properties and Corresponding %oracle-property Annotations " summary="%oracle-property annotations by category">
<thead>
<tr class="cellalignment2">
<th class="cellalignment73" id="d37476e3424">Category</th>
<th class="cellalignment74" id="d37476e3427">Property</th>
<th class="cellalignment9" id="d37476e3430">Annotation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3435" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3435 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJGADB">oracle.hadoop.loader.connection.defaultExecuteBatch</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3435 d37476e3430">
<p><code class="codeph">%oracle-property:connection.defaultExecuteBatch</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3449" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3449 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABGFFBE">oracle.hadoop.loader.connection.oci_url</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3449 d37476e3430">
<p><code class="codeph">%oracle-property:connection.oci_url</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3463" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3463 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABHFCAG">oracle.hadoop.loader.connection.password</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3463 d37476e3430">
<p><code class="codeph">%oracle-property:connection.password</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3477" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3477 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABCDDBD">oracle.hadoop.loader.connection.sessionTimeZone</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3477 d37476e3430">
<p><code class="codeph">%oracle-property:connection.sessionTimeZone</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3491" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3491 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJIJJE">oracle.hadoop.loader.connection.tns_admin</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3491 d37476e3430">
<p><code class="codeph">%oracle-property:connection.tns_admin</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3505" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3505 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABBFJCB">oracle.hadoop.loader.connection.tnsEntryName</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3505 d37476e3430">
<p><code class="codeph">%oracle-property:connection.tnsEntryName</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3519" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3519 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJCAAI">oracle.hadoop.loader.connection.url</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3519 d37476e3430">
<p><code class="codeph">%oracle-property:connection.url</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3533" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3533 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABFIIAA">oracle.hadoop.loader.connection.user</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3533 d37476e3430">
<p><code class="codeph">%oracle-property:connection.user</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3547" headers="d37476e3424">
<p>Connection</p>
</td>
<td class="cellalignment76" headers="d37476e3547 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABFAFGG">oracle.hadoop.loader.connection.wallet_location</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3547 d37476e3430">
<p><code class="codeph">%oracle-property:connection.wallet_location</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3561" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3561 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABIFHHD">oracle.hadoop.loader.badRecordFlushInterval</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3561 d37476e3430">
<p><code class="codeph">%oracle-property:badRecordFlushInterva</code>l</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3576" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3576 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABEFHAH">oracle.hadoop.loader.compressionFactors</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3576 d37476e3430">
<p><code class="codeph">%oracle-property:compressionFactors</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3591" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3591 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABEJCDG">oracle.hadoop.loader.enableSorting</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3591 d37476e3430">
<p><code class="codeph">%oracle-property:enableSorting</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3605" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3605 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABHAEGH">oracle.hadoop.loader.extTabDirectoryName</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3605 d37476e3430">
<p><code class="codeph">%oracle-property:extTabDirectoryName</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3619" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3619 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABCCBIC">oracle.hadoop.loader.loadByPartition</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3619 d37476e3430">
<p><code class="codeph">%oracle-property:loadByPartition</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3633" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3633 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABEIJEB">oracle.hadoop.loader.logBadRecords</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3633 d37476e3430">
<p><code class="codeph">%oracle-property:logBadRecords</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3647" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3647 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABIGABJ">oracle.hadoop.loader.rejectLimit</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3647 d37476e3430">
<p><code class="codeph">%oracle-property:rejectLimit</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3661" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3661 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABHFHFD">oracle.hadoop.loader.sortKey</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3661 d37476e3430">
<p><code class="codeph">%oracle-property:sortKey</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3675" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3675 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABFGBIF">oracle.hadoop.loader.tableMetadataFile</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3675 d37476e3430">
<p><code class="codeph">%oracle-property:tableMetadataFile</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3689" headers="d37476e3424">
<p>General</p>
</td>
<td class="cellalignment76" headers="d37476e3689 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJIBCB">oracle.hadoop.loader.targetTable</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3689 d37476e3430">
<p><code class="codeph">%oracle-property:targetTable</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3703" headers="d37476e3424">
<p>Output</p>
</td>
<td class="cellalignment76" headers="d37476e3703 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABDFIID">oracle.hadoop.loader.output.dirpathBufsize</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3703 d37476e3430">
<p><code class="codeph">%oracle-property:dirpathBufsize</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3717" headers="d37476e3424">
<p>Output</p>
</td>
<td class="cellalignment76" headers="d37476e3717 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABFHGDC">oracle.hadoop.loader.output.escapeEnclosers</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3717 d37476e3430">
<p><code class="codeph">%oracle-property:output.escapeEnclosers</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3731" headers="d37476e3424">
<p>Output</p>
</td>
<td class="cellalignment76" headers="d37476e3731 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABIHCHD">oracle.hadoop.loader.output.fieldTerminator</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3731 d37476e3430">
<p><code class="codeph">%oracle-property:output.fieldTerminator</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3746" headers="d37476e3424">
<p>Output</p>
</td>
<td class="cellalignment76" headers="d37476e3746 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABFGGAC">oracle.hadoop.loader.output.granuleSize</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3746 d37476e3430">
<p><code class="codeph">%oracle-property:output.granuleSize</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3760" headers="d37476e3424">
<p>Output</p>
</td>
<td class="cellalignment76" headers="d37476e3760 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABBFBGJ">oracle.hadoop.loader.output.initialFieldEncloser</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3760 d37476e3430">
<p><code class="codeph">%oracle-property:output.initialFieldEncloser</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3774" headers="d37476e3424">
<p>Output</p>
</td>
<td class="cellalignment76" headers="d37476e3774 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJAIBI">oracle.hadoop.loader.output.trailingFieldEncloser</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3774 d37476e3430">
<p><code class="codeph">%oracle-property:output.trailingFieldEncloser</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3788" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3788 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJDJIG">oracle.hadoop.loader.sampler.enableSampling</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3788 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.enableSampling</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3802" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3802 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABJFBIJ">oracle.hadoop.loader.sampler.hintMaxSplitSize</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3802 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.hintMaxSplitSize</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3816" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3816 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABDHECB">oracle.hadoop.loader.sampler.hintNumMapTasks</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3816 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.hintNumMapTask</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3830" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3830 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABCDJDF">oracle.hadoop.loader.sampler.loadCI</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3830 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.loadCI</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3844" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3844 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABIEJEG">oracle.hadoop.loader.sampler.maxHeapBytes</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3844 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.maxHeapBytes</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3858" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3858 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABHIGDE">oracle.hadoop.loader.sampler.maxLoadFactor</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3858 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.maxLoadFactor</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3872" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3872 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABIFIFB">oracle.hadoop.loader.sampler.maxSamplesPct</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3872 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.maxSamplesPct</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3886" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3886 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABCJBAB">oracle.hadoop.loader.sampler.minSplits</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3886 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.minSplits</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment75" id="d37476e3901" headers="d37476e3424">
<p>Sampler</p>
</td>
<td class="cellalignment76" headers="d37476e3901 d37476e3427">
<p><code class="codeph"><a href="olh.htm#GUID-8D428E86-5EA8-4919-A0DE-1FE163436B52__BABEDJDC">oracle.hadoop.loader.sampler.numThreads</a></code></p>
</td>
<td class="cellalignment11" headers="d37476e3901 d37476e3430">
<p><code class="codeph">%oracle-property:sampler.numThreads</code></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<a id="BDCUG605"></a>
<div class="sect2"><a id="GUID-0FECDBE2-DA61-43DB-B2FD-F02C63EE4DF8"></a>
<h2 id="BDCUG-GUID-0FECDBE2-DA61-43DB-B2FD-F02C63EE4DF8" class="sect2"><span class="enumeration_section">6.4</span> Oracle NoSQL Database Adapter</h2>
<div>
<p>This adapter provides functions to read and write values stored in Oracle NoSQL Database.</p>
<p>This adapter is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-9D16D634-DCF7-44DE-81B5-F6318A76B313">Prerequisites for Using the Oracle NoSQL Database Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-786053EC-686A-4C88-957A-7E2B6CFF41F5">Built-in Functions for Reading from and Writing to Oracle NoSQL Database</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-BDBB6D96-5A5F-42FE-B8B1-87535A876232">Built-in Functions for Reading from and Writing to Oracle NoSQL Database using Table API</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF">Custom Functions for Reading Values from Oracle NoSQL Database</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7">Custom Functions for Retrieving Single Values from Oracle NoSQL Database</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-6E516C92-9B78-41E0-86B9-0B89FCAB5894">Custom Functions for Reading Values from Oracle NoSQL Database using Table API</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-06F109D4-F8A9-4E7B-A6A5-14EB381D2C83">Custom Functions for Reading Single Row from Oracle NoSQL Database using Table API</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-6927A933-73C2-4F93-BB55-CBCF0711AA39">Custom Functions for Retrieving Single Values from Oracle NoSQL Database using Large Object API</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50">Custom Functions for Writing to Oracle NoSQL Database</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-866099C5-6A31-41C3-959B-B7B803BFB9B1">Custom Functions for Writing Values to Oracle NoSQL Database using Table API</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-41F62F39-8E6C-4139-B89A-F67DCA9194B5">Custom Functions for Writing Values to Oracle NoSQL Database using Large Object API</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15">Examples of Oracle NoSQL Database Adapter Functions</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148">Oracle NoSQL Database Adapter Configuration Properties</a></p>
</li>
</ul>
</div>
<a id="BDCUG606"></a>
<div class="sect3"><a id="GUID-9D16D634-DCF7-44DE-81B5-F6318A76B313"></a>
<h3 id="BDCUG-GUID-9D16D634-DCF7-44DE-81B5-F6318A76B313" class="sect3"><span class="enumeration_section">6.4.1</span> Prerequisites for Using the Oracle NoSQL Database Adapter</h3>
<div>
<p>Before you write queries that use the Oracle NoSQL Database adapter, you must configure <a id="d37476e4022" class="indexterm-anchor"></a>Oracle XQuery for Hadoop to use your Oracle NoSQL Database server.</p>
<p>You must set the following:</p>
<ul style="list-style-type: disc;">
<li>
<p>The <code class="codeph">KVHOME</code> environment variable to the local directory containing the Oracle NoSQL database lib directory.</p>
</li>
<li>
<p>The <code class="codeph"><a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__BABDDBFB">oracle.kv.hosts</a></code> and <code class="codeph"><a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__BABHAEIF">oracle.kv.kvstore</a></code> configuration properties.</p>
</li>
<li>
<p>The <code class="codeph">OXH_SOLR_MR_HOME</code> environment variable to the local directory containing <code class="codeph">search-mr-&lt;version&gt;.jar</code> and <code class="codeph">search-mr-&lt;version&gt;-job.jar</code>, only when Tika parser is invoked. That is, only when <code class="codeph">kv:collection-tika()</code> or <code class="codeph">kv:get-tika()</code> functions are invoked or, <code class="codeph">%kv:collection('tika')</code> or <code class="codeph">%kv:get('tika')</code> annotations are used with external functions.</p>
</li>
</ul>
<p>You can set the configuration properties using either the <code class="codeph">-D</code> or <code class="codeph">-conf</code> options in the <code class="codeph">hadoop</code> command when you run the query. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>."</span></p>
<p>This example sets <code class="codeph">KVHOME</code> and uses the <code class="codeph">hadoop</code> <code class="codeph">-D</code> option in a query to set <code class="codeph">oracle.kv.kvstore</code>:</p>
<pre dir="ltr">
$ export KVHOME=/local/path/to/kvstore/
$ hadoop jar $OXH_HOME/lib/oxh.jar -D oracle.kv.hosts=example.com:5000 -D oracle.kv.kvstore=kvstore ./myquery.xq -output ./myoutput
</pre>
<p>This example sets <code class="codeph">OXH_SOLR_MR_HOME</code> environment variable when the Tika parser is invoked:</p>
<pre dir="ltr">
$ export OXH_SOLR_MR_HOME=/usr/lib/solr/contrib/mr
</pre>
<div class="infobox-note" id="GUID-9D16D634-DCF7-44DE-81B5-F6318A76B313__GUID-DA507C5E-7776-40FC-8C8D-3325EC285090">
<p class="notep1">Note:</p>
<p>The <code class="codeph">HADOOP_CLASSPATH</code> environment variable or <code class="codeph">-libjars</code> command line option must not contain NoSQL DB jars.</p>
</div>
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148">Oracle NoSQL Database Adapter Configuration Properties</a>."</span></p>
</div>
</div>
<a id="BDCUG607"></a>
<div class="sect3"><a id="GUID-786053EC-686A-4C88-957A-7E2B6CFF41F5"></a>
<h3 id="BDCUG-GUID-786053EC-686A-4C88-957A-7E2B6CFF41F5" class="sect3"><span class="enumeration_section">6.4.2</span> Built-in Functions for Reading from and Writing to Oracle NoSQL Database</h3>
<div>
<p>To use the built-in functions in your query, you must import the Oracle NoSQL Database module as follows</p>
<pre dir="ltr">
import module "oxh:kv";
</pre>
<p>The <a id="d37476e4151" class="indexterm-anchor"></a><a id="d37476e4153" class="indexterm-anchor"></a>Oracle NoSQL Database module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-DCDF2F8A-7551-4E8E-A7E8-5125A2952ACE">kv:collection-text</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-DB2BA52B-8FC1-4E77-A7AD-8CE0909AF0FF">kv:collection-avroxml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-BFB75004-5D56-4144-AE67-C18F42941A53">kv:collection-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-67ABD514-B25E-458B-BDE2-05D121AB396D">kv:collection-binxml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-3E7ADE20-6E8B-4EAF-BE18-F9433BC8BE96">kv:collection-tika</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-6EF96B83-AC42-4DF5-9A72-1BA1D2E336FB">kv:put-text</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-0E6E0DA0-C27D-4376-AF34-1A085B69FE70">kv:put-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-300720DF-9BA2-4E7A-B2AD-43995C729ADB">kv:put-binxml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-C7EB123D-99B6-42C3-8CB5-C0807F3DA572">kv:get-text</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-9671608A-3A7B-49C5-8584-666572981C11">kv:get-avroxml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-A482DB1B-7E06-4D0D-A6DE-F1623A4F7779">kv:get-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-7B2E8D77-0C47-4184-80AC-5859BF1A5ED3">kv:get-binxml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-4CF25244-D3D1-4DA7-B812-2BF786736CDC">kv:get-tika</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-FA0A721B-07E4-42AF-8AFD-0DB1F7A9E9F0">kv:key-range</a></code></p>
</li>
</ul>
</div>
<a id="BDCUG804"></a><a id="BDCUG805"></a><a id="BDCUG806"></a><a id="BDCUG608"></a>
<div class="sect4"><a id="GUID-DCDF2F8A-7551-4E8E-A7E8-5125A2952ACE"></a>
<h4 id="BDCUG-GUID-DCDF2F8A-7551-4E8E-A7E8-5125A2952ACE" class="sect4"><span class="enumeration_section">6.4.2.1</span> kv:collection-text</h4>
<div>
<p>Accesses a collection of values in the database. Each value is decoded as UTF-8 and returned as a string.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:collection("text") function 
   kv:collection-text($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?) as xs:string* external;

declare %kv:collection("text") function 
   kv:collection-text($parent-key as xs:string?, $depth as xs:int?) as xs:string* external;

declare %kv:collection("text") function 
   kv:collection-text($parent-key as xs:string?) as xs:string* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__BABHJFGB">Parameters</a>."</span> Omitting <code class="codeph">$subrange</code> is the same as specifying <code class="codeph">$subrange()</code>. Likewise, omitting <code class="codeph">$depth</code> is the same as specifying <code class="codeph">$depth()</code>.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One string for each value</p>
</div>
</div>
<a id="BDCUG807"></a><a id="BDCUG808"></a><a id="BDCUG809"></a><a id="BDCUG611"></a>
<div class="sect4"><a id="GUID-DB2BA52B-8FC1-4E77-A7AD-8CE0909AF0FF"></a>
<h4 id="BDCUG-GUID-DB2BA52B-8FC1-4E77-A7AD-8CE0909AF0FF" class="sect4"><span class="enumeration_section">6.4.2.2</span> kv:collection-avroxml</h4>
<div>
<p>Accesses a collection of values in the database. Each value is read as an Avro record and returned as an XML element. The records are converted to XML as described in <span class="q">"<a href="oxh_ref.htm#GUID-9E0BAF32-B98F-4DBD-8EFD-B3EDD0BCB451">Reading Records</a>."</span></p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:collection("avroxml") function 
   kv:collection-avroxml($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?) as element()* external;

declare %kv:collection("avroxml") function 
   kv:collection-avroxml($parent-key as xs:string?, $depth as xs:int?) as element()* external;

declare %kv:collection("avroxml") function 
   kv:collection-avroxml($parent-key as xs:string?) as element()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__BABHJFGB">Parameters</a>."</span> Omitting <code class="codeph">$subrange</code> is the same as specifying <code class="codeph">$subrange()</code>. Likewise, omitting <code class="codeph">$depth</code> is the same as specifying <code class="codeph">$depth()</code>.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One XML element for each Avro record</p>
</div>
</div>
<a id="BDCUG810"></a><a id="BDCUG811"></a><a id="BDCUG812"></a><a id="BDCUG614"></a>
<div class="sect4"><a id="GUID-BFB75004-5D56-4144-AE67-C18F42941A53"></a>
<h4 id="BDCUG-GUID-BFB75004-5D56-4144-AE67-C18F42941A53" class="sect4"><span class="enumeration_section">6.4.2.3</span> kv:collection-xml</h4>
<div>
<p>Accesses a collection of values in the database. Each value is read as a sequence of bytes and parsed as XML.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:collection("xml") function 
   kv:collection-xml($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?) as document-node()* external;

declare %kv:collection("xml") function 
   kv:collection-xml($parent-key as xs:string?, $depth as xs:int?) as document-node()* external;

declare %kv:collection("xml") function 
   kv:collection-xml($parent-key as xs:string?) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__BABHJFGB">Parameters</a>."</span> Omitting <code class="codeph">$subrange</code> is the same as specifying <code class="codeph">$subrange()</code>. Likewise, omitting <code class="codeph">$depth</code> is the same as specifying <code class="codeph">$depth()</code>.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One XML document for each value.</p>
</div>
</div>
<a id="BDCUG813"></a><a id="BDCUG814"></a><a id="BDCUG815"></a><a id="BDCUG816"></a><a id="BDCUG617"></a>
<div class="sect4"><a id="GUID-67ABD514-B25E-458B-BDE2-05D121AB396D"></a>
<h4 id="BDCUG-GUID-67ABD514-B25E-458B-BDE2-05D121AB396D" class="sect4"><span class="enumeration_section">6.4.2.4</span> kv:collection-binxml</h4>
<div>
<p>Accesses a collection of values in the database. Each value is read as XDK binary XML and returned as an XML document.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:collection("binxml") function 
   kv:collection-binxml($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?) as document-node()* external;
</pre>
<pre dir="ltr">
declare %kv:collection("binxml") function 
   kv:collection-binxml($parent-key as xs:string?, $depth as xs:int?) as document-node()* external;
</pre>
<pre dir="ltr">
declare %kv:collection("binxml") function
   kv:collection-binxml($parent-key as xs:string?) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__BABHJFGB">Parameters</a>."</span> Omitting <code class="codeph">$subrange</code> is the same as specifying <code class="codeph">$subrange()</code>. Likewise, omitting <code class="codeph">$depth</code> is the same as specifying <code class="codeph">$depth()</code>.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One XML document for each value.</p>
</div>
</div>
<a id="BDCUG1005"></a><a id="BDCUG1006"></a><a id="BDCUG1007"></a><a id="BDCUG1004"></a>
<div class="sect4"><a id="GUID-3E7ADE20-6E8B-4EAF-BE18-F9433BC8BE96"></a>
<h4 id="BDCUG-GUID-3E7ADE20-6E8B-4EAF-BE18-F9433BC8BE96" class="sect4"><span class="enumeration_section">6.4.2.5</span> kv:collection-tika</h4>
<div>
<p>Uses Tika to parse the specified value when invoked and returns as a document node.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:collection("tika") function
kv:collection-tika($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?) $contentType as xs:string?) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__BABHJFGB">Parameters</a>."</span> Omitting <code class="codeph">$subrange</code> is the same as specifying <code class="codeph">$subrange()</code>. Likewise, omitting <code class="codeph">$depth</code> is the same as specifying <code class="codeph">$depth()</code>.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One document node for each value.</p>
</div>
</div>
<a id="BDCUG817"></a><a id="BDCUG621"></a>
<div class="sect4"><a id="GUID-6EF96B83-AC42-4DF5-9A72-1BA1D2E336FB"></a>
<h4 id="BDCUG-GUID-6EF96B83-AC42-4DF5-9A72-1BA1D2E336FB" class="sect4"><span class="enumeration_section">6.4.2.6</span> kv:put-text</h4>
<div>
<p>Writes a key-value pair. The <code class="codeph">$value</code> is encoded as UTF-8.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:put("text") function
   kv:put-text($key as xs:string, $value as xs:string) external;
</pre></div>
</div>
<a id="BDCUG818"></a><a id="BDCUG622"></a>
<div class="sect4"><a id="GUID-0E6E0DA0-C27D-4376-AF34-1A085B69FE70"></a>
<h4 id="BDCUG-GUID-0E6E0DA0-C27D-4376-AF34-1A085B69FE70" class="sect4"><span class="enumeration_section">6.4.2.7</span> kv:put-xml</h4>
<div>
<p>Writes a key/value pair. The <code class="codeph">$xml</code> is serialized and encoded as UTF-8.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:put("xml") function 
   kv:put-xml($key as xs:string, $xml as node()) external;
</pre></div>
</div>
<a id="BDCUG820"></a><a id="BDCUG819"></a>
<div class="sect4"><a id="GUID-300720DF-9BA2-4E7A-B2AD-43995C729ADB"></a>
<h4 id="BDCUG-GUID-300720DF-9BA2-4E7A-B2AD-43995C729ADB" class="sect4"><span class="enumeration_section">6.4.2.8</span> kv:put-binxml</h4>
<div>
<p>Puts a key/value pair. The <code class="codeph">$xml</code> is encoded as XDK binary XML. See <a class="olink ADXDK4440" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E92664-01&amp;id=ADXDK4440"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a>.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:putkv:put-binxml("binxml") function
   ($key as xs:string, $xml as node()) external;
</pre></div>
</div>
<a id="BDCUG821"></a><a id="BDCUG623"></a>
<div class="sect4"><a id="GUID-C7EB123D-99B6-42C3-8CB5-C0807F3DA572"></a>
<h4 id="BDCUG-GUID-C7EB123D-99B6-42C3-8CB5-C0807F3DA572" class="sect4"><span class="enumeration_section">6.4.2.9</span> kv:get-text</h4>
<div>
<p>Obtains the value associated with the key. The value is decoded as UTF-8 and returned as a string.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:get("text") function 
   kv:get-text($key as xs:string) as xs:string? external;
</pre></div>
</div>
<a id="BDCUG822"></a><a id="BDCUG624"></a>
<div class="sect4"><a id="GUID-9671608A-3A7B-49C5-8584-666572981C11"></a>
<h4 id="BDCUG-GUID-9671608A-3A7B-49C5-8584-666572981C11" class="sect4"><span class="enumeration_section">6.4.2.10</span> kv:get-avroxml</h4>
<div>
<p>Obtains the value associated with the key. The value is read as an Avro record and returned as an XML element. The records are converted to XML as described in <span class="q">"<a href="oxh_ref.htm#GUID-9E0BAF32-B98F-4DBD-8EFD-B3EDD0BCB451">Reading Records</a>."</span>.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:get("avroxml") function 
   kv:get-avroxml($key as xs:string) as element()? external;
</pre></div>
</div>
<a id="BDCUG823"></a><a id="BDCUG625"></a>
<div class="sect4"><a id="GUID-A482DB1B-7E06-4D0D-A6DE-F1623A4F7779"></a>
<h4 id="BDCUG-GUID-A482DB1B-7E06-4D0D-A6DE-F1623A4F7779" class="sect4"><span class="enumeration_section">6.4.2.11</span> kv:get-xml</h4>
<div>
<p>Obtains the value associated with the key. The value is read as a sequence of bytes and parsed as XML.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:get("xml")  function 
   kv:get-xml($key as xs:string) as document-node()? external;
</pre></div>
</div>
<a id="BDCUG824"></a><a id="BDCUG825"></a><a id="BDCUG626"></a>
<div class="sect4"><a id="GUID-7B2E8D77-0C47-4184-80AC-5859BF1A5ED3"></a>
<h4 id="BDCUG-GUID-7B2E8D77-0C47-4184-80AC-5859BF1A5ED3" class="sect4"><span class="enumeration_section">6.4.2.12</span> kv:get-binxml</h4>
<div>
<p>Obtains the value associated with the key. The value is read as XDK binary XML and returned as an XML document.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:get("binxml") function
   kv:get-binxml($key as xs:string) as document-node()? external;
</pre></div>
</div>
<a id="BDCUG1009"></a><a id="BDCUG1010"></a><a id="BDCUG1008"></a>
<div class="sect4"><a id="GUID-4CF25244-D3D1-4DA7-B812-2BF786736CDC"></a>
<h4 id="BDCUG-GUID-4CF25244-D3D1-4DA7-B812-2BF786736CDC" class="sect4"><span class="enumeration_section">6.4.2.13</span> kv:get-tika</h4>
<div>
<p>Obtains the value associated with the key. The value is parsed as byte array and returned as a document node.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv:get("tika") function
   kv:get-tika($key as xs:string, $contentType as xs:string?) as document-node()? external;
</pre></div>
</div>
<a id="BDCUG826"></a><a id="BDCUG627"></a>
<div class="sect4"><a id="GUID-FA0A721B-07E4-42AF-8AFD-0DB1F7A9E9F0"></a>
<h4 id="BDCUG-GUID-FA0A721B-07E4-42AF-8AFD-0DB1F7A9E9F0" class="sect4"><span class="enumeration_section">6.4.2.14</span> kv:key-range</h4>
<div>
<p>Defines a prefix range. The prefix defines both the lower and upper inclusive boundaries.</p>
<p>Use this function as the <span class="italic">subrange</span> argument of a <code class="codeph">kv:collection</code> function.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
kv:key-range($prefix as xs:string) as xs:string;
</pre></div>
</div>
<a id="BDCUG827"></a><a id="BDCUG828"></a><a id="BDCUG628"></a>
<div class="sect4"><a id="GUID-3E59ECB2-0B66-4B9E-82F1-F4947A3A13B9"></a>
<h4 id="BDCUG-GUID-3E59ECB2-0B66-4B9E-82F1-F4947A3A13B9" class="sect4"><span class="enumeration_section">6.4.2.15</span> kv:key-range</h4>
<div>
<p>Specifies a key range.</p>
<p>Use this function as the <span class="italic">subrange</span> argument of a <code class="codeph">kv:collection</code> function.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
kv:key-range($start as xs:string, $start-inclusive as xs:boolean, $end as xs:string, $end-inclusive as xs:boolean) as xs:string;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$start</code>: Defines the lower boundary of the key range.</p>
<p><code class="codeph">$start-inclusive</code>: A value of <code class="codeph">true</code> includes <code class="codeph">$start</code> in the range, or <code class="codeph">false</code> omits it.</p>
<p><code class="codeph">$end</code>: Defines the upper boundary of the key range. It must be greater than <code class="codeph">$start</code>.</p>
<p><code class="codeph">$end-inclusive</code>: A value of <code class="codeph">true</code> includes <code class="codeph">$end</code> in the range, or false omits it.</p>
</div>
</div>
</div>
<a id="BDCUG1115"></a>
<div class="sect3"><a id="GUID-BDBB6D96-5A5F-42FE-B8B1-87535A876232"></a>
<h3 id="BDCUG-GUID-BDBB6D96-5A5F-42FE-B8B1-87535A876232" class="sect3"><span class="enumeration_section">6.4.3</span> Built-in Functions for Reading from and Writing to Oracle NoSQL Database using Table API</h3>
<div>
<p>To use the built-in functions in your query, you must have declared the name space and imported the module as follows:</p>
<pre dir="ltr">
declare namespace kv-table = "oxh:kv-table";
import module "oxh:kv-table";
</pre>
<p>The <a id="d37476e4965" class="indexterm-anchor"></a><a id="d37476e4967" class="indexterm-anchor"></a>Oracle NoSQL Database through Table API module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318">kv-table:collection-jsontext</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-C82C17C7-96AC-46C9-920E-F48E111482BD">kv-table:get-jsontext</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-342D7390-D59D-4130-A443-9114293E0BCE">kv-table:put-jsontext</a></p>
</li>
</ul>
</div>
<a id="BDCUG1117"></a><a id="BDCUG1118"></a><a id="BDCUG1119"></a><a id="BDCUG1116"></a>
<div class="sect4"><a id="GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318"></a>
<h4 id="BDCUG-GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318" class="sect4"><span class="enumeration_section">6.4.3.1</span> kv-table:collection-jsontext</h4>
<div>
<p>These functions iterate over all or a subset of rows stored in a single table in the NoSQL Database. Each row is returned in a form of a JSON string.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-table:collection-jsontext("jsontext") function 
  kv-table:collection-jsontext($tableName as xs:string) as xs:string*
</pre>
<pre dir="ltr">
declare %kv-table:collection(&ldquo;jsontext") function 
  kv-table:collection-jsontext($tableName as xs:string, $primaryKeyJsonValue as xs:string?) as xs:string*
</pre>
<pre dir="ltr">
declare %kv-table:collection(&ldquo;jsontext") function
  kv-table:collection-jsontext($tableName as xs:string, $primaryKeyJsonValue as xs:string?, $fieldRangeJsonValue as xs:string?) as xs:string*
</pre>
<div class="section" id="GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318__CHEHCJFI">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$tableName</code> as <code class="codeph">xs:string</code> &ndash; name of the table in NoSQL Database</p>
<p><code class="codeph">$primaryKeyJsonValue</code> as <code class="codeph">xs:string?</code> &ndash; a partial primary key specified as JSON text</p>
<div class="infoboxnotealso" id="GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318__GUID-A1BF5507-F013-438D-9433-26FB6D8636EE">
<p class="notep1">See Also:</p>
<p><a href="http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuideTables/primaryshardkeys.html#partialprimarykeys" target="_blank"><code class="codeph">http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuideTables/primaryshardkeys.html#partialprimarykeys</code></a></p>
</div>
<p><code class="codeph">$fieldRangeJsonValue</code> as <code class="codeph">xs:string?</code> &ndash; field range for a remaining field of the given primary key specified as JSON text</p>
<pre dir="ltr">
{ 
   "name": &ldquo;fieldname", 
   "start": &ldquo;startVal", 
   "startInclusive": true|false,  
   "end" : "endVal",
   "endInclusive": true|false   
}
</pre>
<div class="section" id="GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318__CHEHCFDA">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>JSON value of each row</p>
<p>Use <span class="q">"<a href="oxh_ref.htm#GUID-75EDF233-E0C4-456B-81A4-1D178F0B7387">json:parse-as-xml</a>"</span> function to parse JSON string into an XML document</p>
</div>
</div>
<a id="BDCUG1121"></a><a id="BDCUG1122"></a><a id="BDCUG1123"></a><a id="BDCUG1120"></a>
<div class="sect4"><a id="GUID-C82C17C7-96AC-46C9-920E-F48E111482BD"></a>
<h4 id="BDCUG-GUID-C82C17C7-96AC-46C9-920E-F48E111482BD" class="sect4"><span class="enumeration_section">6.4.3.2</span> kv-table:get-jsontext</h4>
<div>
<p>This function reads a single row stored in a table in NoSQL Database. The row is returned in a form of a JSON string. If the row is not found, then an empty sequence is returned.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-table:get(&ldquo;jsontext") function
  kv-table:get-jsontext($tableName as xs:string, $primaryKeyJsonValue as xs:string) as xs:string?
</pre>
<div class="section" id="GUID-C82C17C7-96AC-46C9-920E-F48E111482BD__CHEICIHC">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$tableName</code> as <code class="codeph">xs:string</code> &ndash; name of the table in NoSQL Database</p>
<p><code class="codeph">$primaryKeyJsonValu</code>e as <code class="codeph">xs:string?</code> &ndash; a full primary key specified as JSON text</p>
<div class="infoboxnotealso" id="GUID-C82C17C7-96AC-46C9-920E-F48E111482BD__GUID-096BC698-16CD-40C6-9900-BAB4693F034B">
<p class="notep1">See Also:</p>
<p><a href="http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuideTables/primaryshardkeys.html#primarykeys" target="_blank"><code class="codeph">http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuideTables/primaryshardkeys.html#primarykeys</code></a></p>
</div>
<div class="section" id="GUID-C82C17C7-96AC-46C9-920E-F48E111482BD__CHEDIJDG">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>JSON value of the row or an empty sequence, if the row is not found.</p>
<p>Use <span class="q">"<a href="oxh_ref.htm#GUID-75EDF233-E0C4-456B-81A4-1D178F0B7387">json:parse-as-xml</a>"</span> function to parse JSON string into an XML document</p>
</div>
</div>
<a id="BDCUG1125"></a><a id="BDCUG1126"></a><a id="BDCUG1124"></a>
<div class="sect4"><a id="GUID-342D7390-D59D-4130-A443-9114293E0BCE"></a>
<h4 id="BDCUG-GUID-342D7390-D59D-4130-A443-9114293E0BCE" class="sect4"><span class="enumeration_section">6.4.3.3</span> kv-table:put-jsontext</h4>
<div>
<p>This function writes a row into NoSQL Database using its Table API</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-table:put(&ldquo;jsontext") function
  kv-table:put-jsontext($tableName as xs:string, $jsonValue as xs:string);
</pre>
<div class="section" id="GUID-342D7390-D59D-4130-A443-9114293E0BCE__CHEEJAED">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$tableName</code> as <code class="codeph">xs:string</code> &ndash; name of the table in NoSQL Database</p>
<p><code class="codeph">$jsonValue</code> as <code class="codeph">xs:string</code> &ndash; row specified as JSON text</p>
</div>
</div>
</div>
<a id="BDCUG1127"></a>
<div class="sect3"><a id="GUID-7312E8F7-5C72-4384-B2DC-E36754191691"></a>
<h3 id="BDCUG-GUID-7312E8F7-5C72-4384-B2DC-E36754191691" class="sect3"><span class="enumeration_section">6.4.4</span> Built-in Functions for Reading from and Writing to Oracle NoSQL Database using Large Object API</h3>
<div>
<p>To use the built-in functions in your query you must have declared the name space and imported the module as follows:</p>
<pre dir="ltr">
declare namespace kv-lob = "oxh:kv-lob";
import module "oxh:kv-lob";
</pre>
<p>The <a id="d37476e5198" class="indexterm-anchor"></a><a id="d37476e5200" class="indexterm-anchor"></a>Oracle NoSQL Database through Large Object API module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-D3315806-A7D0-4B84-BD00-E495EFFC2A0A">kv-lob:get-text</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-CAAB1108-19C2-4213-824F-F4203E943D78">kv-lob:get-xml</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-2F6B8877-1681-4F3E-ABC4-4D5FD1A563A8">kv-lob:get-binxml</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-D4C15216-6CCB-4119-ACD7-3BABCA89C6B8">kv-lob:get-tika</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-1FA4B8A9-9935-4309-BF14-2E5A508A9922">kv-lob:put-text</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-9ED5B6E0-AA6F-477C-9AD7-8BC9EB3E9877">kv-lob:put-xml</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-B8CC301C-A2AF-42E6-93B6-20BD75074B66">kv-lob:put-binxml</a></p>
</li>
</ul>
</div>
<a id="BDCUG1129"></a><a id="BDCUG1128"></a>
<div class="sect4"><a id="GUID-D3315806-A7D0-4B84-BD00-E495EFFC2A0A"></a>
<h4 id="BDCUG-GUID-D3315806-A7D0-4B84-BD00-E495EFFC2A0A" class="sect4"><span class="enumeration_section">6.4.4.1</span> kv-lob:get-text</h4>
<div>
<p>Obtains the value associated with the key. The value is decoded as UTF-8 and returned as a string.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-lob:get("text") 
function kv-lob:get-text($key as xs:string) as xs:string?
</pre></div>
</div>
<a id="BDCUG1142"></a><a id="BDCUG1141"></a>
<div class="sect4"><a id="GUID-CAAB1108-19C2-4213-824F-F4203E943D78"></a>
<h4 id="BDCUG-GUID-CAAB1108-19C2-4213-824F-F4203E943D78" class="sect4"><span class="enumeration_section">6.4.4.2</span> kv-lob:get-xml</h4>
<div>
<p>Obtains the value associated with the key. The value is read as a sequence of bytes and parsed as XML.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-lob:get("xml") 
function kv-lob:get-xml($key as xs:string) as document-node()?
</pre></div>
</div>
<a id="BDCUG1144"></a><a id="BDCUG1143"></a>
<div class="sect4"><a id="GUID-2F6B8877-1681-4F3E-ABC4-4D5FD1A563A8"></a>
<h4 id="BDCUG-GUID-2F6B8877-1681-4F3E-ABC4-4D5FD1A563A8" class="sect4"><span class="enumeration_section">6.4.4.3</span> kv-lob:get-binxml</h4>
<div>
<p>Obtains the value associated with the key. The value is read as XDK binary XML and returned as an XML document. See <a class="olink ADXDK4440" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E92664-01&amp;id=ADXDK4440"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a>.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-lob:get("binxml")
function kv-lob:get-binxml($key as xs:string) as document-node()?
</pre></div>
</div>
<a id="BDCUG1146"></a><a id="BDCUG1145"></a>
<div class="sect4"><a id="GUID-D4C15216-6CCB-4119-ACD7-3BABCA89C6B8"></a>
<h4 id="BDCUG-GUID-D4C15216-6CCB-4119-ACD7-3BABCA89C6B8" class="sect4"><span class="enumeration_section">6.4.4.4</span> kv-lob:get-tika</h4>
<div>
<p>Obtains the value associated with the key. The value is parsed as byte array and returned as a document node.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-lob:get("tika")
function kv-lob:get-tika($key as xs:string) as document-node()?
</pre>
<pre dir="ltr">
declare %kv-lob:get("tika")
function kv-lob:get-tika($key as xs:string, $contentType as xs:string?) as document-node()?
</pre></div>
</div>
<a id="BDCUG1131"></a><a id="BDCUG1130"></a>
<div class="sect4"><a id="GUID-1FA4B8A9-9935-4309-BF14-2E5A508A9922"></a>
<h4 id="BDCUG-GUID-1FA4B8A9-9935-4309-BF14-2E5A508A9922" class="sect4"><span class="enumeration_section">6.4.4.5</span> kv-lob:put-text</h4>
<div>
<p>Writes a key-value pair. The <code class="codeph">$value</code> is encoded as UTF-8.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-lob:put("text")
function kv-lob:put-text($key as xs:string, $value as xs:string)
</pre></div>
</div>
<a id="BDCUG1148"></a><a id="BDCUG1147"></a>
<div class="sect4"><a id="GUID-9ED5B6E0-AA6F-477C-9AD7-8BC9EB3E9877"></a>
<h4 id="BDCUG-GUID-9ED5B6E0-AA6F-477C-9AD7-8BC9EB3E9877" class="sect4"><span class="enumeration_section">6.4.4.6</span> kv-lob:put-xml</h4>
<div>
<p>Writes a key/value pair. The <code class="codeph">$xml</code> is serialized and encoded as UTF-8.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-lob:put("xml")
function kv-lob:put-xml($key as xs:string, $document as node())
</pre></div>
</div>
<a id="BDCUG1150"></a><a id="BDCUG1149"></a>
<div class="sect4"><a id="GUID-B8CC301C-A2AF-42E6-93B6-20BD75074B66"></a>
<h4 id="BDCUG-GUID-B8CC301C-A2AF-42E6-93B6-20BD75074B66" class="sect4"><span class="enumeration_section">6.4.4.7</span> kv-lob:put-binxml</h4>
<div>
<p>Puts a key/value pair. The <code class="codeph">$xml</code> is encoded as XDK binary XML.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %kv-lob:put("binxml")
function kv-lob:put-binxml($key as xs:string, $document as node()
</pre></div>
</div>
</div>
<a id="BDCUG629"></a>
<div class="sect3"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF"></a>
<h3 id="BDCUG-GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF" class="sect3"><span class="enumeration_section">6.4.5</span> Custom Functions for Reading Values from Oracle NoSQL Database</h3>
<div>
<p>You can use the following functions to read values from Oracle NoSQL Database. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p><a id="d37476e5528" class="indexterm-anchor"></a><a id="d37476e5532" class="indexterm-anchor"></a><a id="d37476e5536" class="indexterm-anchor"></a><a id="d37476e5540" class="indexterm-anchor"></a>Custom functions for reading collections of NoSQL values must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv:collection("text") [<span class="italic">additional annotations</span>] 
   function local:<span class="italic">myFunctionName</span>($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?) as xs:string* external;

declare %kv:collection(["xml"|"binxml"|"tika"]) [<span class="italic">additional annotations</span>] 
   function local:<span class="italic">myFunctionName</span>($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?) as document-node()* external;

declare %kv:collection("tika") [<span class="italic">additional annotations</span>]
   function local:myFunctionName($parent-key as xs:string?, $depth as xs:int?, $subrange as xs:string?, $contentType as xs:string?) as document-node()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations&shy;</p>
<dl>
<dt class="dlterm"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-25C7CF81-E445-4A3E-A8E6-CA1BD5EA4F85"><!-- --></a>%kv:collection("<span class="italic">method</span>")</dt>
<dd>
<p>Declares the NoSQL Database collection function. Required.</p>
<p>The <span class="italic">method</span> parameter is one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">avroxml</code>: Each value is read as an Avro record and returned as an XML element. The records are converted to XML as described in <span class="q">"<a href="oxh_ref.htm#GUID-9E0BAF32-B98F-4DBD-8EFD-B3EDD0BCB451">Reading Records</a>."</span></p>
</li>
<li>
<p><code class="codeph">binxml</code>: Each value is read as XDK binary XML and returned as an XML document.</p>
</li>
<li>
<p><code class="codeph">text</code>: Each value is decoded using the character set specified by the <code class="codeph">%output:encoding</code> annotation.</p>
</li>
<li>
<p><code class="codeph">tika</code>: Each value is parsed by Tika, and returned as a document node.</p>
</li>
<li>
<p><code class="codeph">xml</code>: Each value is parsed as XML, and returned as an XML document.</p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-5A8C0644-7419-4665-AF5D-1ABEEC2E44DD"><!-- --></a>%kv:key("true" | "false")</dt>
<dd>
<p>Controls whether the key of a key-value pair is set as the <code class="codeph">document-uri</code> of the returned value. Specify <code class="codeph">true</code> to return the key.</p>
<p>The default setting is true when <span class="italic">method</span> is <code class="codeph">xml</code>, <code class="codeph">avroxml</code>, or <code class="codeph">binxml</code>, and <code class="codeph">false</code> when it is text. Text functions with this annotation set to <code class="codeph">true</code> must be declared to return <code class="codeph">text()?</code> instead of <code class="codeph">xs:string?</code>. Atomic <code class="codeph">xs:string</code> values are not associated with a document node, but text nodes are. For example:</p>
<div class="p">
<pre dir="ltr">
declare %kv:collection("text") %kv:key("true")
   function local:col($parent-key as xs:string?) as text()* external;
</pre></div>
<p>When the key is returned, you can obtain its string representation by using the <code class="codeph">kv:key()</code> function. For example:</p>
<div class="p">
<pre dir="ltr">
for $value in local:col(...)
let $key := $value/kv:key()
return ...
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-598410FF-B635-4CDF-A5C4-A4369EB4C3E1"><!-- --></a>%avro:schema-kv("<span class="italic">schema-name</span>")</dt>
<dd>
<p>Specifies the Avro reader schema. This annotation is valid only when <span class="italic">method</span> is <code class="codeph">avroxml</code>. Optional.</p>
<p>The <span class="italic">schema-name</span> is a fully qualified record name. The record schema is retrieved from the Oracle NoSQL Database catalog. The record value is mapped to the reader schema. For example, <code class="codeph">%avro:schema-kv("org.example.PersonRecord")</code>.</p>
<div class="infoboxnotealso" id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-89163333-1688-4274-8F6E-941CFDBE728D">
<p class="notep1">See Also:</p>
<p>For information about Avro schemas, the <span class="italic">Oracle NoSQL Database Getting Started Guide</span> at</p>
<p><a href="http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuide/schemaevolution.html" target="_blank"><code class="codeph">http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuide/schemaevolution.html</code></a></p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-C79ED05D-4EFB-4483-9723-85E61BA294E2"><!-- --></a>%output:encoding</dt>
<dd>
<p>Specifies the character encoding of text values. UTF-8 is assumed when this annotation is not used. The valid encodings are those supported by the JVM.</p>
<p>This annotation currently only applies to the text method. For XML files, the document's encoding declaration is used if it is available.</p>
<div class="infoboxnotealso" id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-7B171855-4B20-4E8C-AEA9-6B2CC402CB84">
<p class="notep1">See Also:</p>
<p>"Supported Encodings" in the Oracle Java SE documentation at</p>
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html" target="_blank"><code class="codeph">http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html</code></a></p>
</div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section" id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__BABHJFGB">
<p class="subhead3">Parameters</p>
<dl>
<dt class="dlterm"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-228F39EB-5DC2-4D18-AE65-F1199AB30DB2"><!-- --></a>Parameter 1: $parent-key as xs:string?</dt>
<dd>
<p>Specifies the parent key whose child KV pairs are returned by the function. The major key path must be a partial path and the minor key path must be empty. An empty sequence results in fetching all keys in the store.</p>
<div class="infoboxnotealso" id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-6A0AA658-124B-4EF8-B7A7-A8E5DE3BFDF4">
<p class="notep1">See Also:</p>
<p>For the format of the key, <span class="italic">Oracle NoSQL Database Java Reference</span> at</p>
<p><a href="http://docs.oracle.com/cd/NOSQL/html/javadoc/oracle/kv/Key.html#toString" target="_blank"><code class="codeph">http://docs.oracle.com/cd/NOSQL/html/javadoc/oracle/kv/Key.html#toString</code></a></p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-F772EA0E-F12A-469A-B673-298CF824ED4F"><!-- --></a>Parameter 2: $depth as xs:int?</dt>
<dd>
<p>Specifies whether parents, children, descendants, or a combination are returned. The following values are valid:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">kv:depth-parent-and-descendants()</code>: Selects the parents and all descendants.</p>
</li>
<li>
<p><code class="codeph">kv:depth-children-only()</code>: Selects only the immediately children, but not the parent.</p>
</li>
<li>
<p><code class="codeph">kv:depth-descendants-only()</code>: Selects all descendants, but not the parent.</p>
</li>
<li>
<p><code class="codeph">kv:depth-parent-and-children()</code>: Selects the parent and the immediate children.</p>
</li>
</ul>
<p>An empty sequence implies <code class="codeph">kv:depth-parent-and-descendants()</code>.</p>
<p>This example selects all the descendants, but not the parent:</p>
<pre dir="ltr">
kv:collection-text("/parent/key", kv:depth-descendants-only(), ...
</pre></dd>
<dt class="dlterm"><a id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-B70B284C-15FA-454D-8DC5-428660B50EE0"><!-- --></a>Parameter 3: $subRange as xs:string?</dt>
<dd>
<p><a id="d37476e5778" class="indexterm-anchor"></a>Specifies a subrange to further restrict the range under <code class="codeph">parentKey</code> to the major path components. The format of the string is:</p>
<pre dir="ltr">
&lt;startType&gt;/&lt;start&gt;/&lt;end&gt;/&lt;endType&gt;
</pre>
<p>The <code class="codeph">startType</code> and <code class="codeph">endType</code> are either <code class="codeph">I</code> for inclusive or <code class="codeph">E</code> for exclusive.</p>
<p>The <code class="codeph">start</code> and <code class="codeph">end</code> are the starting and ending key strings.</p>
<p>If the range does not have a lower boundary, then omit the leading <code class="codeph">startType/start</code> specification from the string representation. Similarly, if the range does not have an upper boundary, then omit the trailing <code class="codeph">end/endType</code> specification. A <code class="codeph">KeyRange</code> requires at least one boundary, thus at least one specification must appear in the string representation.</p>
<p>The <code class="codeph"><a href="oxh_ref.htm#GUID-FA0A721B-07E4-42AF-8AFD-0DB1F7A9E9F0">kv:key-range</a></code> function provides a convenient way to create a range string.</p>
<p>The value can also be the empty sequence.</p>
<p>The following examples are valid subrange specifications:</p>
<div class="tblformal" id="GUID-AA0BBE96-B555-4660-8C3C-3970848CBDBF__GUID-0B2B88BB-2D79-40C0-AB74-1F45A04B49EC">
<table class="cellalignment77" summary="$subrange examples and descriptions">
<thead>
<tr class="cellalignment2">
<th class="cellalignment46" id="d37476e5837">Example</th>
<th class="cellalignment45" id="d37476e5840">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment48" id="d37476e5845" headers="d37476e5837">
<p><code class="codeph">I/alpha/beta/E</code></p>
</td>
<td class="cellalignment47" headers="d37476e5845 d37476e5840">
<p>From alpha inclusive to beta exclusive</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment48" id="d37476e5853" headers="d37476e5837">
<p><code class="codeph">E//0123/I</code></p>
</td>
<td class="cellalignment47" headers="d37476e5853 d37476e5840">
<p>From "" exclusive to 0123 inclusive</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment48" id="d37476e5861" headers="d37476e5837">
<p><code class="codeph">I/chi/</code></p>
</td>
<td class="cellalignment47" headers="d37476e5861 d37476e5840">
<p>From chi inclusive to infinity</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment48" id="d37476e5869" headers="d37476e5837">
<p><code class="codeph">E//</code></p>
</td>
<td class="cellalignment47" headers="d37476e5869 d37476e5840">
<p>From "" exclusive to infinity</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment48" id="d37476e5877" headers="d37476e5837">
<p><code class="codeph">/chi/E</code></p>
</td>
<td class="cellalignment47" headers="d37476e5877 d37476e5840">
<p>From negative infinity to chi exclusive</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment48" id="d37476e5885" headers="d37476e5837">
<p><code class="codeph">//I</code></p>
</td>
<td class="cellalignment47" headers="d37476e5885 d37476e5840">
<p>From negative infinity to "" inclusive</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG630"></a>
<div class="sect3"><a id="GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7"></a>
<h3 id="BDCUG-GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7" class="sect3"><span class="enumeration_section">6.4.6</span> Custom Functions for Retrieving Single Values from Oracle NoSQL Database</h3>
<div>
<p><a id="d37476e5936" class="indexterm-anchor"></a><a id="d37476e5940" class="indexterm-anchor"></a><a id="d37476e5944" class="indexterm-anchor"></a><a id="d37476e5948" class="indexterm-anchor"></a>The Oracle NoSQL Database adapter has get functions, which enable you to retrieve a single value from the database. Unlike collection functions, calls to get functions are not distributed across the cluster. When a get function is called, the value is retrieved by a single task.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom <code class="codeph">get</code> functions must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv:get("text") [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($key as xs:string) as xs:string? external;

declare %kv:get("avroxml") [<span class="italic">additional annotations</span>] 
   function local:<span class="italic">myFunctionName</span>($key as xs:string) as element()? external;

declare %kv:get(["xml"|"binxml"|"tika"]) [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($key as xs:string) as document-node()?

declare %kv:get(["tika"]) [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($key as xs:string $contentType as xs:string?) as document-node()?
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7__GUID-5749BDD9-10CD-4932-9E08-3D89C6E9686D"><!-- --></a>%kv:get("<span class="italic">method</span>")</dt>
<dd>
<p>Declares the NoSQL Database get function. Required.</p>
<p>The <span class="italic">method</span> parameter is one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">avroxml</code>: The value is read as an Avro record and returned as an XML element. The records are converted to XML as described in <span class="q">"<a href="oxh_ref.htm#GUID-9E0BAF32-B98F-4DBD-8EFD-B3EDD0BCB451">Reading Records</a>."</span></p>
</li>
<li>
<p><code class="codeph">binxml</code>: The value is read as XDK binary XML and returned as an XML document.</p>
</li>
<li>
<p><code class="codeph">text</code>: The value is decoded using the character set specified by the <code class="codeph">%output:encoding</code> annotation.</p>
</li>
<li>
<p><code class="codeph">tika</code>: Each value is parsed by Tika, and returned as a document node.</p>
</li>
<li>
<p><code class="codeph">xml</code>: The value is parsed as XML and returned as an XML document.</p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7__GUID-933D87B6-3212-4942-9C83-BDDF046F1B6F"><!-- --></a>%kv:key("true" | "false")</dt>
<dd>
<p>Controls whether the key of a key-value pair is set as the <code class="codeph">document-uri</code> of the returned value. Specify <code class="codeph">true</code> to return the key.</p>
<p>The default setting is <code class="codeph">true</code> when <span class="italic">method</span> is <code class="codeph">xml</code>, <code class="codeph">avroxml</code>, or <code class="codeph">binxml</code>, and <code class="codeph">false</code> when it is text. Text functions with this annotation set to <code class="codeph">true</code> must be declared to return <code class="codeph">text()?</code> instead of <code class="codeph">xs:string?</code>. Atomic <code class="codeph">xs:string</code> values are not associated with a document node, but text nodes are.</p>
<p>When the key is returned, you can obtain its string representation by using the <code class="codeph">kv:key()</code> function.</p>
</dd>
<dt class="dlterm"><a id="GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7__GUID-3C7D81B5-9DDD-40FC-9EEF-45DDE8482BF4"><!-- --></a>%avro:schema-kv("<span class="italic">schema-name</span>")</dt>
<dd>
<p>Specifies the <a id="d37476e6098" class="indexterm-anchor"></a>Avro reader schema. This annotation is valid only when <span class="italic">method</span> is <code class="codeph">avroxml</code>. Optional.</p>
<p>The <span class="italic">schema-name</span> is a fully qualified record name. The record schema is retrieved from the Oracle NoSQL Database catalog. The record value is mapped to the reader schema. For example, <code class="codeph">%avro:schema-kv("org.example.PersonRecord")</code>.</p>
<div class="infoboxnotealso" id="GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7__GUID-295AA272-AA45-43DF-966C-7ACC4971E162">
<p class="notep1">See Also:</p>
<p>For information about Avro schemas, the <span class="italic">Oracle NoSQL Database Getting Started Guide</span> at</p>
<p><a href="http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuide/schemaevolution.html" target="_blank"><code class="codeph">http://docs.oracle.com/cd/NOSQL/html/GettingStartedGuide/schemaevolution.html</code></a></p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7__GUID-95A51977-3B90-48D6-A15A-1B85696B916D"><!-- --></a>%output:encoding</dt>
<dd>
<p>Specifies the character encoding of text values. UTF-8 is assumed when this annotation is not used. The valid encodings are those supported by the JVM.</p>
<p>This annotation currently only applies to the text method. For XML files, the document encoding declaration is used, if it is available.</p>
<div class="infoboxnotealso" id="GUID-80593657-7EDA-4BD1-B9C7-34360DB033C7__GUID-B63A490F-5099-4438-AACC-1BEEA32A9DEE">
<p class="notep1">See Also:</p>
<p>"Supported Encodings" in the Oracle Java SE documentation at</p>
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html" target="_blank"><code class="codeph">http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html</code></a></p>
</div>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1132"></a>
<div class="sect3"><a id="GUID-6E516C92-9B78-41E0-86B9-0B89FCAB5894"></a>
<h3 id="BDCUG-GUID-6E516C92-9B78-41E0-86B9-0B89FCAB5894" class="sect3"><span class="enumeration_section">6.4.7</span> Custom Functions for Reading Values from Oracle NoSQL Database using Table API</h3>
<div>
<p>You can use the following functions to read values from Oracle NoSQL Database using Table API. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading collections of NoSQL values using Table API must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv-table:collection(&ldquo;jsontext")
function local:myFunctionName($tableName as xs:string) as xs:string* external;
</pre>
<pre dir="ltr">
declare %kv-table:collection(&ldquo;jsontext")
function local:myFunctionName($tableName as xs:string, $primaryKeyJsonValue as xs:string?) as xs:string* external;
</pre>
<pre dir="ltr">
declare %kv-table:collection(&ldquo;jsontext")
function local:myFunctionName($tableName as xs:string, $primaryKeyJsonValue as xs:string?, $fieldRangeJsonValue as xs:string?) as xs:string* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations&shy;</p>
<dl>
<dt class="dlterm"><a id="GUID-6E516C92-9B78-41E0-86B9-0B89FCAB5894__GUID-75A10E5E-71FF-416A-8C05-C51DD5734D87"><!-- --></a>%kv-table:collection(&ldquo;jsontext")</dt>
<dd>
<p>Declares the collection function that uses Table API.</p>
<div class="infobox-note" id="GUID-6E516C92-9B78-41E0-86B9-0B89FCAB5894__GUID-9E1211B3-31F3-4C8C-991B-F1A156776620">
<p class="notep1">Note:</p>
<p><code class="codeph">jsontext</code> is the only supported and required annotation value.</p>
</div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<p>Same as <span class="q">"<a href="oxh_ref.htm#GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318__CHEHCJFI">Parameters</a>."</span></p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Returns</p>
<p>Same as <span class="q">"<a href="oxh_ref.htm#GUID-1F9BB5F5-A1DD-4AD4-B022-CD8B0E5E1318__CHEHCFDA">Returns</a>."</span></p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1133"></a>
<div class="sect3"><a id="GUID-06F109D4-F8A9-4E7B-A6A5-14EB381D2C83"></a>
<h3 id="BDCUG-GUID-06F109D4-F8A9-4E7B-A6A5-14EB381D2C83" class="sect3"><span class="enumeration_section">6.4.8</span> Custom Functions for Reading Single Row from Oracle NoSQL Database using Table API</h3>
<div>
<p>You can use the following functions to read single row from Oracle NoSQL Database using Table API. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions to read single row from Oracle NoSQL Database using Table API must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv-table:get(&ldquo;jsontext")
function local:myFunctionName($tableName as xs:string, $primaryKeyJsonValue as xs:string?) as xs:string? external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations&shy;</p>
<dl>
<dt class="dlterm"><a id="GUID-06F109D4-F8A9-4E7B-A6A5-14EB381D2C83__GUID-04F62731-2904-46AB-B034-4DA940CFBFAC"><!-- --></a>%kv-table:get(&ldquo;jsontext")</dt>
<dd>
<p>Declares the get function that uses Table API.</p>
<div class="infobox-note" id="GUID-06F109D4-F8A9-4E7B-A6A5-14EB381D2C83__GUID-531ACCFA-3599-4F09-ACE8-6B07BDB5633E">
<p class="notep1">Note:</p>
<p><code class="codeph">jsontext</code> is the only supported and required annotation value.</p>
</div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<p>Same as <span class="q">"<a href="oxh_ref.htm#GUID-C82C17C7-96AC-46C9-920E-F48E111482BD__CHEICIHC">Parameters</a>."</span></p>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Returns</p>
<p>Same as <span class="q">"<a href="oxh_ref.htm#GUID-C82C17C7-96AC-46C9-920E-F48E111482BD__CHEDIJDG">Returns</a>."</span></p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1134"></a>
<div class="sect3"><a id="GUID-6927A933-73C2-4F93-BB55-CBCF0711AA39"></a>
<h3 id="BDCUG-GUID-6927A933-73C2-4F93-BB55-CBCF0711AA39" class="sect3"><span class="enumeration_section">6.4.9</span> Custom Functions for Retrieving Single Values from Oracle NoSQL Database using Large Object API</h3>
<div>
<p>You can use the following functions to read values from Oracle NoSQL Database using Large Object API. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading single values using Large Object API must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv-lob:get("text") [additional annotations]
function local:myFunctionName($key as xs:string) as xs:string? external;
</pre>
<pre dir="ltr">
declare %kv-lob:get(["xml"|"binxml"|"tika"]) [additional annotations]
function local:myFunctionName($key as xs:string) as document-node()?
</pre>
<pre dir="ltr">
declare %kv-lob:get(["tika"]) [additional annotations]
function local:myFunctionName($key as xs:string $contentType as xs:string?) as document-node()?
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations&shy;</p>
<dl>
<dt class="dlterm"><a id="GUID-6927A933-73C2-4F93-BB55-CBCF0711AA39__GUID-69F6618C-D544-4EF3-981D-73582E485840"><!-- --></a>%kv-lob:get(&ldquo;method")</dt>
<dd>
<p>Declares the NoSQL Database get function that uses Large Object API. Required. Supported method parameters are <code class="codeph">binxml</code>, <code class="codeph">text</code>, <code class="codeph">tika</code>, and <code class="codeph">xml</code> &ndash; same as in %kv:get(&ldquo;method").</p>
<div class="infobox-note" id="GUID-6927A933-73C2-4F93-BB55-CBCF0711AA39__GUID-1EB97111-17BF-4281-A584-D69E440A79AC">
<p class="notep1">Note:</p>
<p><code class="codeph">avroxml</code> method is not supported with Large Object API.</p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-6927A933-73C2-4F93-BB55-CBCF0711AA39__GUID-9595E606-1EDE-4E97-99F7-BCF7287F89CA"><!-- --></a>%kv-lob:key("true" | "false")</dt>
<dd>
<p>Controls whether the key of a key-value pair is set as the document-uri of the returned value. Specify true to return the key. Same as %kv:key().</p>
</dd>
<dt class="dlterm"><a id="GUID-6927A933-73C2-4F93-BB55-CBCF0711AA39__GUID-0D9598E1-0C76-475A-9CF6-CCB868379B02"><!-- --></a>%output:encoding</dt>
<dd>
<p>Specifies the character encoding of text values. UTF-8 is assumed when this annotation is not used. The valid encodings are those supported by the JVM. This annotation currently only applies to the text method. For XML files, the document encoding declaration is used, if it is available.</p>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG631"></a>
<div class="sect3"><a id="GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50"></a>
<h3 id="BDCUG-GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50" class="sect3"><span class="enumeration_section">6.4.10</span> Custom Functions for Writing to Oracle NoSQL Database</h3>
<div>
<p><a id="d37476e6368" class="indexterm-anchor"></a><a id="d37476e6372" class="indexterm-anchor"></a><a id="d37476e6376" class="indexterm-anchor"></a><a id="d37476e6380" class="indexterm-anchor"></a>You can use the following annotations to define functions that write to Oracle NoSQL Database.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for writing to Oracle NoSQL Database must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv:put("text") function
   local:<span class="italic">myFunctionName</span>($key as xs:string, $value as xs:string) external;

declare %kv:put(["xml"|"binxml"|"avroxml"]) function 
   local:<span class="italic">myFunctionName</span>($key as xs:string, $xml as node()) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<div class="tblformal" id="GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50__GUID-2F9E05C8-6D4C-4D2D-AB6E-EF55B6AE3029">
<table class="cellalignment41" summary="Describes the annotations used in functions for writing to Oracle NoSQL Database.">
<thead>
<tr class="cellalignment2">
<th class="cellalignment40" id="d37476e6409">Annotation</th>
<th class="cellalignment40" id="d37476e6411">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2" id="GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50__GUID-612DDA30-2240-4E21-A234-DCDCFD329D43">
<td class="cellalignment2" id="d37476e6415" headers="d37476e6409">
<p><span class="bold">%kv:put("<span class="italic">method</span>")</span></p>
</td>
<td class="cellalignment2" headers="d37476e6415 d37476e6411">
<p>Declares the NoSQL Database module put function. Required.</p>
<p>The <span class="italic">method</span> determines how the value is stored. It must be one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">text</code>: <code class="codeph">$value</code> is serialized and encoded using the character set specified by the <code class="codeph">%output:encoding</code> annotation.</p>
</li>
<li>
<p><code class="codeph">avroxml</code>: <code class="codeph">$xml</code> is mapped to an instance of the Avro record specified by the <code class="codeph">%avro:schema-kv</code> annotation. See <span class="q">"<a href="oxh_ref.htm#GUID-6D5BD0B4-7377-45C3-A258-71DF590A939B">Writing XML as Avro</a>."</span></p>
</li>
<li>
<p><code class="codeph">binxml</code>: $xml is encoded as XDK binary XML.</p>
</li>
<li>
<p><code class="codeph">xml</code>: <code class="codeph">$xml</code> is serialized and encoded using the character set specified by the <code class="codeph">%output:encoding</code> annotation. You can specify other XML serialization parameters using <code class="codeph"><a href="oxh_ref.htm#GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50__BABHDBHH">%output:*</a></code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment2" id="GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50__GUID-8FB494BB-ADC3-408D-8DBC-47642CB7597D">
<td class="cellalignment2" id="d37476e6479" headers="d37476e6409">
<p><span class="bold">%avro:schema-kv("<span class="italic">schema-name</span>")</span></p>
</td>
<td class="cellalignment2" headers="d37476e6479 d37476e6411">
<p>Specifies the record schema of the values to be written. The annotation value is a fully qualified record name. The record schema is retrieved from the Oracle NoSQL Database catalog.</p>
<p>For example: <code class="codeph">%avro:schema-kv("org.example.PersonRecord")</code></p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-9544CFCE-ADE3-4CA6-964D-A8381F330D50__BABHDBHH">
<td class="cellalignment2" id="d37476e6494" headers="d37476e6409">
<p><span class="bold">%output:*</span></p>
</td>
<td class="cellalignment2" headers="d37476e6494 d37476e6411">
<p>A standard XQuery <a id="d37476e6501" class="indexterm-anchor"></a>serialization parameter for the output method (text or XML) specified in <code class="codeph">%kv:put</code>. See <span class="q">"<a href="oxh_ref.htm#GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5">Serialization Annotations</a>."</span></p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1135"></a>
<div class="sect3"><a id="GUID-866099C5-6A31-41C3-959B-B7B803BFB9B1"></a>
<h3 id="BDCUG-GUID-866099C5-6A31-41C3-959B-B7B803BFB9B1" class="sect3"><span class="enumeration_section">6.4.11</span> Custom Functions for Writing Values to Oracle NoSQL Database using Table API</h3>
<div>
<p>You can use the following annotations to define functions that write to Oracle NoSQL Database using Table API.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for writing rows using Table API must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv-table:put(&ldquo;jsontext")
function local:myFunctionName($tableName as xs:string, $jsonValue as xs:string?) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations&shy;</p>
<dl>
<dt class="dlterm"><a id="GUID-866099C5-6A31-41C3-959B-B7B803BFB9B1__GUID-37398D04-9386-4F5F-BA1B-D0728911C922"><!-- --></a>%kv-table:put(&ldquo;<span class="italic">jsontext</span>")</dt>
<dd>
<p>Declares the put function that uses Table API.</p>
<div class="infobox-note" id="GUID-866099C5-6A31-41C3-959B-B7B803BFB9B1__GUID-CB9BFD9B-674D-4857-A3C7-06A8719BB52E">
<p class="notep1">Note:</p>
<p><code class="codeph">jsontext</code> is the only supported and required annotation value.</p>
</div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<p>Same as <span class="q">"<a href="oxh_ref.htm#GUID-342D7390-D59D-4130-A443-9114293E0BCE__CHEEJAED">Parameters</a>."</span></p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1136"></a>
<div class="sect3"><a id="GUID-41F62F39-8E6C-4139-B89A-F67DCA9194B5"></a>
<h3 id="BDCUG-GUID-41F62F39-8E6C-4139-B89A-F67DCA9194B5" class="sect3"><span class="enumeration_section">6.4.12</span> Custom Functions for Writing Values to Oracle NoSQL Database using Large Object API</h3>
<div>
<p>You can use the following annotations to define functions that write to Oracle NoSQL Database using Large Object API.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for writing values using Large Object API must have one of the following signatures:</p>
<pre dir="ltr">
declare %kv-lob:put("text")
function  local:myFunctionName($key as xs:string, $value as xs:string) external;
</pre>
<pre dir="ltr">
declare %kv-lob:put(["xml"|"binxml"]) 
function local:myFunctionName($key as xs:string, $xml as node()) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations&shy;</p>
<dl>
<dt class="dlterm"><a id="GUID-41F62F39-8E6C-4139-B89A-F67DCA9194B5__GUID-AA97C049-D3D6-467E-992E-DBD2D9D48790"><!-- --></a>%kv-lob:put("<span class="italic">method</span>")</dt>
<dd>
<p>Declares the NoSQL Database put function. Required. Supported method parameters are <code class="codeph">binxml</code>, <code class="codeph">text</code>, and <code class="codeph">xml</code> &ndash; same as in <code class="codeph"><span class="q">"%kv:put("method")"</span></code></p>
<div class="infobox-note" id="GUID-41F62F39-8E6C-4139-B89A-F67DCA9194B5__GUID-EB3D0778-9A2A-4207-81F7-E9E376D06B0D">
<p class="notep1">Note:</p>
<p><code class="codeph">avroxml</code> method is not supported with Large Object API.</p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-41F62F39-8E6C-4139-B89A-F67DCA9194B5__GUID-F1BDF2FC-4F2A-49A0-8224-740EF020D356"><!-- --></a>%output:*</dt>
<dd>
<p>A standard XQuery serialization parameter for the output method (text or XML) specified in <code class="codeph">%kv-lob:put</code>. See <span class="q">"<a href="oxh_ref.htm#GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5">Serialization Annotations</a>."</span></p>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1064"></a><a id="BDCUG1065"></a><a id="BDCUG1066"></a><a id="BDCUG1067"></a><a id="BDCUG1137"></a><a id="BDCUG1139"></a><a id="BDCUG829"></a>
<div class="sect3"><a id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15"></a>
<h3 id="BDCUG-GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15" class="sect3"><span class="enumeration_section">6.4.13</span> Examples of Oracle NoSQL Database Adapter Functions</h3>
<div>
<div class="example" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-41AFFDCE-6B06-4706-8747-E3F0F7881183">
<p class="titleinexample">Example 6-8 Writing and Reading Text in Oracle NoSQL Database</p>
<p>This example uses the following text file is in HDFS. The file contains user profile information such as user ID, full name, and age, separated by colons (:).</p>
<pre dir="ltr">
mydata/users.txt  
 
john:John Doe:45
kelly:Kelly Johnson:32
laura:Laura Smith:
phil:Phil Johnson:27
</pre>
<p>The first query stores the lines of this text file in Oracle NoSQL Database as text values.</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:kv";
 
for $line in text:collection("mydata/users.txt")
let $split := fn:tokenize($line, ":")
let $key := "/users/text/" || $split[1]
return
   kv:put-text($key, $line)
</pre>
<p>The next query reads the values from the database:</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:kv";

for $value in kv:collection-text("/users/text")
let $split := fn:tokenize($value, ":")
where $split[2] eq "Phil Johnson"
return
   text:put($value)
</pre>
<p>The query creates a text file that contains the following line:</p>
<pre dir="ltr">
phil:Phil Johnson:27
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-53056662-B527-4DFF-AD8D-FA3EB4C13452">
<p class="titleinexample">Example 6-9 Writing and Reading Avro in Oracle NoSQL Database</p>
<p>In this example, the following Avro schema is registered with Oracle NoSQL Database:</p>
<pre dir="ltr">
{
   "type": "record",
   "name": "User",
   "namespace": "com.example",
   "fields" : [
      {"name": "id", "type": "string"},
      {"name": "full_name", "type": "string"},
      {"name": "age", "type": ["int", "null"] }
   ]
 }
</pre>
<p>The next query writes the user names to the database as Avro records.</p>
<pre dir="ltr">
import module "oxh:text";

declare %kv:put("avroxml") %avro:schema-kv("com.example.User")
   function local:put-user($key as xs:string, $value as node()) external;

for $line in text:collection("mydata/users.txt")
let $split := fn:tokenize($line, ":")
let $id := $split[1]
let $key := "/users/avro/" || $id
return
   local:put-user(
      $key,
      &lt;user&gt;
         &lt;id&gt;{$id}&lt;/id&gt;
         &lt;full_name&gt;{$split[2]}&lt;/full_name&gt;
         {
            if ($split[3] castable as xs:int) then
               &lt;age&gt;{$split[3]}&lt;/age&gt;
            else
               ()
         }
      &lt;/user&gt;
   )
</pre>
<p>This query reads the values from the database:</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:kv";

for $user in kv:collection-avroxml("/users/avro")
where $user/age gt 30
return
   text:put($user/full_name)
</pre>
<p>The query creates a text files with the following lines:</p>
<pre dir="ltr">
John Doe
Kelly Johnson
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-D9C01786-8327-4092-B6C3-02C3AD7631EC">
<p class="titleinexample">Example 6-10 Storing XML in NoSQL Database</p>
<p>The following query uses the XML files shown in <a href="oxh_ref.htm#GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7__CHEHFIBB">Example 6-24</a> of <span class="q">"<a href="oxh_ref.htm#GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7">Examples of XML File Adapter Functions</a>"</span> as input. It writes each comment element as an Oracle NoSQL Database value:</p>
<pre dir="ltr">
import module "oxh:xmlf";
import module "oxh:kv";
 
for $comment in xmlf:collection("mydata/comments*.xml")/comments/comment
let $key := "/comments/" || $comment/@id
return 
   kv:put-xml($key, $comment)
 
</pre>
<p>The query writes the five <code class="codeph">comment</code> elements as XML values in Oracle NoSQL Database.</p>
<p>For very large XML files, modify the query as follows to improve performance and disk space consumption:</p>
<ul style="list-style-type: disc;">
<li>
<p>Use the following <code class="codeph">for</code> clause, which causes each XML file to be split and processed in parallel by multiple tasks:</p>
<pre dir="ltr">
for $comment in xmlf:collection("mydata/comments*.xml", "comment")
</pre></li>
<li>
<p>In the return clause, use <code class="codeph">kv:put-binxml</code> instead of <code class="codeph">kv:put-xml</code> to store the values as binary XML instead of plain text.</p>
</li>
</ul>
<p>Use the <code class="codeph">kv:collection-xml</code> function to read the values in the database. For example:</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:kv";

for $comment in kv:collection-xml("/comments")/comment
return 
   text:put($comment/@id || " " || $comment/@user)
 
</pre>
<p>The query creates text files that contain the following lines:</p>
<pre dir="ltr">
12345 john
23456 john
54321 mike
56789 kelly
87654 mike
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-F607B373-6DD1-4AA4-A162-4138A0C560BF">
<p class="titleinexample">Example 6-11 Storing XML as Avro in Oracle NoSQL Database</p>
<p>This example converts the XML values to Avro before they are stored.</p>
<p>Add the following Avro schema to Oracle NoSQL Database:</p>
<pre dir="ltr">
{
   "type": "record",
   "name": "Comment",
   "namespace": "com.example",
   "fields" : [
      {"name": "cid", "type": "string"},
      {"name": "user", "type": "string"},
      {"name": "content", "type": "string"},
      {"name": "likes", "type" : { "type" : "array", "items" : "string" } }
   ]
}
</pre>
<p>The following query writes five <code class="codeph">comment</code> elements as Avro values in Oracle NoSQL Database:</p>
<pre dir="ltr">
import module "oxh:xmlf";
import module "oxh:kv";

declare %kv:put("avroxml") %avro:schema-kv("com.example.Comment")
  function local:put-comment($key as xs:string, $value as node()) external;

for $comment in xmlf:collection("mydata/comments*.xml", "comment")
let $key := "/comments/" || $comment/@id
let $value :=
  &lt;comment&gt;
    &lt;cid&gt;{$comment/@id/data()}&lt;/cid&gt;
    &lt;user&gt;{$comment/@user/data()}&lt;/user&gt;
    &lt;content&gt;{$comment/@text/data()}&lt;/content&gt;
    &lt;likes&gt;{
      for $like in $comment/like
      return &lt;oxh:item&gt;{$like/@user/data()}&lt;/oxh:item&gt;
    }&lt;/likes&gt;
  &lt;/comment&gt;
return 
  local:put-comment($key, $value)
</pre>
<p>Use the <code class="codeph">kv:collection-avroxml</code> function to read the values in the database. For example:</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:kv";

for $comment in kv:collection-avroxml("/comments")
return 
   text:put($comment/cid || " " || $comment/user || " " || count($comment/likes/*))
</pre>
<p>The query creates text files that contain the following lines:</p>
<pre dir="ltr">
12345 john 0
23456 john 2
54321 mike 1
56789 kelly 2
87654 mike 0
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-EBADAADD-72AF-4773-83F3-89CBB3D4ECE7">
<p class="titleinexample">Example 6-12 Reading and writing data using Oracle NoSQL Database Table API</p>
<p>This example uses the following text file is in HDFS. The file contains user profile information such as user ID, full name, and age, separated by colons (:).</p>
<pre dir="ltr">
mydata/users.txt  
john:John Doe:45
kelly:Kelly Johnson:32
laura:Laura Smith:
phil:Phil Johnson:27
</pre>
<p>Let us create a table called users in NoSQL DB as follows:</p>
<pre dir="ltr">
CREATE TABLE users (id STRING, name STRING, age INTEGER, PRIMARY KEY (id));
</pre>
<p>The first query stores users age into this table.</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:kv-table";

for $line in text:collection("mydata/users.txt")
let $split := tokenize($line, ":")
let $id := $split[1]
let $name := $split[2]
let $age := $split[3]
where string-length($age) gt 0
let $row := 
'{' ||
  '"id":"' || $id || '",' ||
  '"name":"' || $name || '",' ||
  '"age":' || $age ||
'}'

return
   kv-table:put-jsontext(&ldquo;users", $row)
</pre>
<p>After running this query the table contains the following records:</p>
<div class="tblformal" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-99AD8F12-79CD-4FD5-B626-1D547542B42A">
<table class="cellalignment8" summary="The table lists the query results">
<thead>
<tr class="cellalignment2">
<th class="cellalignment19" id="d37476e6808">Id</th>
<th class="cellalignment19" id="d37476e6811">name</th>
<th class="cellalignment19" id="d37476e6814">age</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment21" id="d37476e6819" headers="d37476e6808">
<p>john</p>
</td>
<td class="cellalignment21" headers="d37476e6819 d37476e6811">
<p>John Doe</p>
</td>
<td class="cellalignment21" headers="d37476e6819 d37476e6814">
<p>45</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment21" id="d37476e6829" headers="d37476e6808">
<p>kelly</p>
</td>
<td class="cellalignment21" headers="d37476e6829 d37476e6811">
<p>Kelly Johnson</p>
</td>
<td class="cellalignment21" headers="d37476e6829 d37476e6814">
<p>32</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment21" id="d37476e6839" headers="d37476e6808">
<p>phil</p>
</td>
<td class="cellalignment21" headers="d37476e6839 d37476e6811">
<p>Phil Johnson</p>
</td>
<td class="cellalignment21" headers="d37476e6839 d37476e6814">
<p>27</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" -->
<p>The second query reads row from the table and returns ids of users whose name ends with <span class="italic">Johnson</span>.</p>
<pre dir="ltr">
import module "oxh:text ";
import module "oxh:json";
import module "oxh:kv-table";
 
for $row in kv-table:collection("users")
let $user := json:parse-as-xml($row)
let $id := $user/json:get(&ldquo;id")
let $name := $user/json:get(&ldquo;name")
where ends-with($name, &ldquo;Johnson")
 
return text:put($id)
</pre>
<p>The query creates a text file that contains the following lines:</p>
<pre dir="ltr">
kelly
phil
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-662AC146-EF84-4EF2-BBD6-37DBEA9F2E0B">
<p class="titleinexample">Example 6-13 Reading data using Oracle NoSQL Database Large Object API</p>
<p>Assuming Oracle NoSQL Database contains the following information:</p>
<ol>
<li>
<p>Table userImages</p>
<p>CREATE TABLE userImages (imageFileName STRING, imageVersion STRING, imageDescription INTEGER, PRIMARY KEY (imageFileName))</p>
<div class="tblformal" id="GUID-7582DCAB-68D0-4B3D-8CBD-42179F013F15__GUID-5A9875F9-0C49-42F8-8FAA-0D1038D87F04">
<table class="cellalignment77" summary="Example Oracle NoSQL using Large Object API - Table userImages">
<thead>
<tr class="cellalignment2">
<th class="cellalignment19" id="d37476e6880">imageFileName</th>
<th class="cellalignment19" id="d37476e6883">imageVersion</th>
<th class="cellalignment19" id="d37476e6886">imageDescription</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment21" id="d37476e6891" headers="d37476e6880">
<p>IMG_001.JPG</p>
</td>
<td class="cellalignment21" headers="d37476e6891 d37476e6883">
<p>1</p>
</td>
<td class="cellalignment21" headers="d37476e6891 d37476e6886">
<p>Sunrise</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment21" id="d37476e6901" headers="d37476e6880">
<p>IMG_002.JPG</p>
</td>
<td class="cellalignment21" headers="d37476e6901 d37476e6883">
<p>1</p>
</td>
<td class="cellalignment21" headers="d37476e6901 d37476e6886">
<p>Sunrise</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></li>
<li>
<p>Key/Value data loaded with Large Object API where:</p>
<ul style="list-style-type: disc;">
<li>
<p>Key is the l<code class="codeph">ob/imageFileName/image.lob</code></p>
</li>
<li>
<p>Value is a JPEG image data that contains geolocation metadata in <code class="codeph">EXIF</code> format</p>
</li>
</ul>
<p>The following query extracts that metadata and converts it to CSV format as imageFileName, latitude, and longitude.</p>
<pre dir="ltr">
import module &ldquo;oxh:kv-table";
import module &ldquo;oxh:kv-lob";
import module "oxh:tika";
import module "oxh:json";
import module "oxh:text ";
 
for $row in kv-table:collection("userImages")
 
let $imageFileName := json:parse-as-xml($row)/json:get(&ldquo;imageFileName")
let $imageKey := &ldquo;lob/" || $imageFileName || &ldquo;/image.lob"
let $doc := kv-lob:get-tika($imageKey, &ldquo;image/jpeg")
let $lat := $doc/tika:metadata/tika:property[@name eq "GPS Latitude"]
let $lon := $doc/tika:metadata/tika:property[@name eq "GPS Longitude"]
where exists($lat) and exists($lon)
 
return text:put($imageFileName || "," || $lat || "," || $lon)
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
</div>
<a id="BDCUG632"></a>
<div class="sect3"><a id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148"></a>
<h3 id="BDCUG-GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148" class="sect3"><span class="enumeration_section">6.4.14</span> Oracle NoSQL Database Adapter Configuration Properties</h3>
<div>
<p>Oracle XQuery for Hadoop uses the generic options for specifying configuration properties in the Hadoop command. You can use the <code class="codeph">-conf</code> option to identify configuration files, and the <code class="codeph">-D</code> option to specify individual properties. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>."</span></p>
<p>You can set various configuration properties for the Oracle NoSQL Database adapter that control the durability characteristics and timeout periods. You must set <a id="d37476e7043" class="indexterm-anchor"></a><code class="codeph"><a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__BABDDBFB">oracle.kv.hosts</a></code> and <a id="d37476e7050" class="indexterm-anchor"></a><a id="d37476e7052" class="indexterm-anchor"></a><code class="codeph"><a href="oxh_ref.htm#GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__BABHAEIF">oracle.kv.kvstore</a></code>.The following properties configure the Oracle NoSQL Database adapter.</p>
<div class="tblformalwide" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-DCD094EE-9030-4823-B06E-FAC1A92B13A1">
<table class="cellalignment23" summary="Describes Oracle NoSQL Adapter configuration properties.">
<thead>
<tr class="cellalignment2">
<th class="cellalignment40" id="d37476e7069">Property</th>
<th class="cellalignment40" id="d37476e7071">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-955D9B48-7583-4E31-B7EB-302619A45533">
<td class="cellalignment2" id="d37476e7075" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.durability</span></p>
</td>
<td class="cellalignment2" headers="d37476e7075 d37476e7071">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: <code class="codeph">NO_SYNC, NO_SYNC, SIMPLE_MAJORITY</code></p>
<p><span class="bold">Description</span>: Defines the durability characteristics associated with <code class="codeph">%kv:put</code> operations. The value consists of three parts, which you specify in order and separate with commas (,):</p>
<p><span class="italic">MasterPolicy</span>, <span class="italic">ReplicaPolicy</span>, <span class="italic">ReplicaAck</span></p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">MasterPolicy</span>: The synchronization policy used when committing a transaction to the master database. Set this part to one of the following constants:</p>
<p><code class="codeph">NO_SYNC</code>: Do not write or synchronously flush the log on a transaction commit.</p>
<p><code class="codeph">SYNC</code>: Write and synchronously flush the log on a transaction commit.</p>
<p><code class="codeph">WRITE_NO_SYNC</code>: Write but do not synchronously flush the log on a transaction commit.</p>
</li>
<li>
<p><span class="italic">ReplicaPolicy</span>: The synchronization policy used when committing a transaction to the replica databases. Set this part to <code class="codeph">NO_SYNC</code>, <code class="codeph">SYNC</code>, or <code class="codeph">WRITE_NO_SYNC</code>, as described under <span class="italic">MasterPolicy</span>.</p>
</li>
<li>
<p><span class="italic">ReplicaAck</span>: The acknowledgment policy used to obtain transaction acknowledgments from the replica databases. Set this part to one of the following constants:</p>
<p><code class="codeph">ALL</code>: All replicas must acknowledge that they have committed the transaction.</p>
<p><code class="codeph">NONE</code>: No transaction commit acknowledgments are required, and the master does not wait for them.</p>
<p><code class="codeph">SIMPLE_MAJORITY</code>: A simple majority of replicas (such as 3 of 5) must acknowledge that they have committed the transaction.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-6309BF56-B93C-4F6A-9AAE-2CC0ACE4BDB3">
<td class="cellalignment2" id="d37476e7159" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.requestLimit</span></p>
</td>
<td class="cellalignment2" headers="d37476e7159 d37476e7071">
<p><span class="bold">Type</span>: Comma-separated list of integers</p>
<p><span class="bold">Default Value</span>: 100, 90, 80</p>
<p><span class="bold">Description</span>: Limits the number of simultaneous requests to prevent nodes with long service times from consuming all threads in the KV store client. The value consists of three integers, which you specify in order and separate with commas:</p>
<p><span class="italic">maxActiveRequests</span>, <span class="italic">requestThresholdPercent</span>, <span class="italic">nodeLimitPercent</span></p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">maxActiveRequests</span>: The maximum number of active requests permitted by the KV client. This number is typically derived from the maximum number of threads that the client has set aside for processing requests.</p>
</li>
<li>
<p><span class="italic">requestThresholdPercent</span>: The percentage of <span class="italic">maxActiveRequests</span> at which requests are limited.</p>
</li>
<li>
<p><span class="italic">nodeLimitPercent</span>: The maximum number of active requests that can be associated with a node when the number of active requests exceeds the threshold specified by <span class="italic">requestThresholdPercent</span>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-B3FD8C11-AFCA-446D-AEDC-CB277B5AE1FB">
<td class="cellalignment2" id="d37476e7208" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.requestTimeout</span></p>
</td>
<td class="cellalignment2" headers="d37476e7208 d37476e7071">
<p><span class="bold">Type</span>: Long</p>
<p><span class="bold">Default Value</span>: 5000 ms</p>
<p><span class="bold">Description</span>: Configures the request timeout period in milliseconds. The value must be greater than zero (0).</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-9969A842-DC48-4567-8798-BD876E8BBD5F">
<td class="cellalignment2" id="d37476e7226" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.socketOpenTimeout</span></p>
</td>
<td class="cellalignment2" headers="d37476e7226 d37476e7071">
<p><span class="bold">Type</span>: Long</p>
<p><span class="bold">Default Value</span>: 5000 ms</p>
<p><span class="bold">Description</span>: Configures the open timeout used when establishing sockets for client requests, in milliseconds. Shorter timeouts result in more rapid failure detection and recovery. The default open timeout is adequate for most applications. The value must be greater than zero (0).</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-3EAB1CE1-7B90-48A1-AD9A-7F6390E1CF0D">
<td class="cellalignment2" id="d37476e7244" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.socketReadTimeout</span></p>
</td>
<td class="cellalignment2" headers="d37476e7244 d37476e7071">
<p><span class="bold">Type</span>: Long</p>
<p><span class="bold">Default Value</span>: 30000 ms</p>
<p><span class="bold">Description</span>: Configures the read timeout period associated with the sockets that make client requests, in milliseconds. Shorter timeouts result in more rapid failure detection and recovery. Nonetheless, the timeout period should be sufficient to allow the longest timeout associated with a request.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-7FA7207A-22B5-4B36-9BC6-189086772CC5">
<td class="cellalignment2" id="d37476e7262" headers="d37476e7069">
<p><span class="bold">oracle.kv.batchSize</span></p>
</td>
<td class="cellalignment2" headers="d37476e7262 d37476e7071">
<p><span class="bold">Type</span>: Key</p>
<p><span class="bold">Default Value</span>: Not defined</p>
<p><span class="bold">Description</span>: The desired number of keys for the InputFormat to fetch during each network round trip. A value of zero (0) sets the property to a default value.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-464F6753-CC15-4713-99DB-42DD15586128">
<td class="cellalignment2" id="d37476e7280" headers="d37476e7069">
<p><span class="bold">oracle.kv.consistency</span></p>
</td>
<td class="cellalignment2" headers="d37476e7280 d37476e7071">
<p><span class="bold">Type</span>: Consistency</p>
<p><span class="bold">Default Value</span>: <code class="codeph">NONE_REQUIRED</code></p>
<p><span class="bold">Description</span>: The consistency guarantee for reading child key-value pairs. The following keywords are valid values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">ABSOLUTE</code>: Requires the master to service the transaction so that consistency is absolute.</p>
</li>
<li>
<p><code class="codeph">NONE_REQUIRED</code>: Allows replicas to service the transaction, regardless of the state of the replicas relative to the master.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__BABDDBFB">
<td class="cellalignment2" id="d37476e7311" headers="d37476e7069">
<p><span class="bold">oracle.kv.hosts</span></p>
</td>
<td class="cellalignment2" headers="d37476e7311 d37476e7071">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: Not defined</p>
<p><span class="bold">Description</span>: An array of one or more <span class="italic">hostname</span>:<span class="italic">port</span> pairs that identify the hosts in the KV store with the source data. Separate multiple pairs with commas.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__BABHAEIF">
<td class="cellalignment2" id="d37476e7335" headers="d37476e7069">
<p><span class="bold">oracle.kv.kvstore</span></p>
</td>
<td class="cellalignment2" headers="d37476e7335 d37476e7071">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: Not defined</p>
<p><span class="bold">Description</span>: The name of the KV store with the source data.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-0D5F3FE0-E57A-47DF-BD7E-A1BF79FA0BAF">
<td class="cellalignment2" id="d37476e7353" headers="d37476e7069">
<p><span class="bold">oracle.kv.timeout</span></p>
</td>
<td class="cellalignment2" headers="d37476e7353 d37476e7071">
<p><span class="bold">Type</span>: Long</p>
<p><span class="bold">Default Value</span>: Not defined</p>
<p><span class="bold">Description</span>: Sets a maximum time interval in milliseconds for retrieving a selection of key-value pairs. A value of zero (0) sets the property to its default value.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-9981301C-9976-4D4E-B862-31CFBCB9ECE1">
<td class="cellalignment2" id="d37476e7371" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.LOBSuffix</span></p>
</td>
<td class="cellalignment2" headers="d37476e7371 d37476e7071">
<p><span class="bold">Type:</span> String</p>
<p><span class="bold">Default Value:</span> .lob</p>
<p><span class="bold">Description:</span> Configures the default suffix associated with LOB keys.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-DCFAC923-1F06-4CE3-A214-67F2959BC196">
<td class="cellalignment2" id="d37476e7390" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.LOBTimeout</span></p>
</td>
<td class="cellalignment2" headers="d37476e7390 d37476e7071">Necessary or FYI? Also, hard-coded link.</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-D26E49A8-C594-41E9-866D-858EF98D7E1F">
<td class="cellalignment2" id="d37476e7397" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.readZones</span></p>
</td>
<td class="cellalignment2" headers="d37476e7397 d37476e7071">
<p><span class="bold">Type:</span> Comma separated list of strings</p>
<p><span class="bold">Default Value:</span> Not defined</p>
<p><span class="bold">Description:</span> Sets the zones in which nodes must be located to be used for read operations.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-E5F0D118-6BC8-4F16-A15A-0EC93D29A148__GUID-3B39CE95-02A3-4D27-98B8-EB59178BBD47">
<td class="cellalignment2" id="d37476e7415" headers="d37476e7069">
<p><span class="bold">oracle.hadoop.xquery.kv.config.security</span></p>
</td>
<td class="cellalignment2" headers="d37476e7415 d37476e7071">
<p><span class="bold">Type:</span> String</p>
<p><span class="bold">Default Value:</span> Not defined</p>
<p><span class="bold">Description:</span> Configures security properties for the client.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<a id="BDCUG633"></a>
<div class="sect2"><a id="GUID-214695C5-3584-4058-BA2B-CC55401DF845"></a>
<h2 id="BDCUG-GUID-214695C5-3584-4058-BA2B-CC55401DF845" class="sect2"><span class="enumeration_section">6.5</span> Sequence File Adapter</h2>
<div>
<p>The <a id="d37476e7452" class="indexterm-anchor"></a><a id="d37476e7454" class="indexterm-anchor"></a><a id="d37476e7458" class="indexterm-anchor"></a>sequence file adapter provides functions to read and write Hadoop sequence files. A sequence file is a Hadoop-specific file format composed of key-value pairs.</p>
<p>The functions are described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-C52F5DF2-0BDF-40A9-AC3D-7A02A9F76859">Built-in Functions for Reading and Writing Sequence Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416">Custom Functions for Reading Sequence Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262">Custom Functions for Writing Sequence Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972">Examples of Sequence File Adapter Functions</a></p>
</li>
</ul>
</div>
<a id="BDCUG634"></a>
<div class="sect3"><a id="GUID-C52F5DF2-0BDF-40A9-AC3D-7A02A9F76859"></a>
<h3 id="BDCUG-GUID-C52F5DF2-0BDF-40A9-AC3D-7A02A9F76859" class="sect3"><span class="enumeration_section">6.5.1</span> Built-in Functions for Reading and Writing Sequence Files</h3>
<div>
<p>To use the built-in <a id="d37476e7502" class="indexterm-anchor"></a><a id="d37476e7504" class="indexterm-anchor"></a><a id="d37476e7508" class="indexterm-anchor"></a><a id="d37476e7510" class="indexterm-anchor"></a>functions in your query, you must import the sequence file module as follows:</p>
<pre dir="ltr">
import module "oxh:seq";
</pre>
<p>The sequence file module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-1EF13DE6-2A28-4469-85D2-5D82B36876AF">seq:collection</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-9BA458C1-3773-4411-AC94-EE76C8AA21CE">seq:collection-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-6A317849-56F8-4109-95BB-C0AA465813ED">seq:collection-binxml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-CEFA0D28-055F-4B8F-9251-10492A223810">seq:collection-tika</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-A5D1D66A-70E8-4DFE-8796-2F421124285F">seq:put</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-4D003FFD-5977-4911-B6DF-2162D5C65A45">seq:put-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-61AF5E5C-9F0C-4972-B2D6-1C677E0A3E7D">seq:put-binxml</a></code></p>
</li>
</ul>
<p>For examples, see <span class="q">"<a href="oxh_ref.htm#GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972">Examples of Sequence File Adapter Functions</a>."</span></p>
</div>
<a id="BDCUG834"></a><a id="BDCUG835"></a><a id="BDCUG836"></a><a id="BDCUG635"></a>
<div class="sect4"><a id="GUID-1EF13DE6-2A28-4469-85D2-5D82B36876AF"></a>
<h4 id="BDCUG-GUID-1EF13DE6-2A28-4469-85D2-5D82B36876AF" class="sect4"><span class="enumeration_section">6.5.1.1</span> seq:collection</h4>
<div>
<p>Accesses a collection of sequence files in HDFS and returns the values as strings. The files may be split up and processed in parallel by multiple tasks.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %seq:collection("text") function 
   seq:collection($uris as xs:string*) as xs:string* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The sequence file URIs. The values in the sequence files must be either <code class="codeph">org.apache.hadoop.io.Text</code> or <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. For BytesWritable values, the bytes are converted to a string using a UTF-8 decoder.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One string for each value in each file.</p>
</div>
</div>
<a id="BDCUG837"></a><a id="BDCUG838"></a><a id="BDCUG839"></a><a id="BDCUG636"></a>
<div class="sect4"><a id="GUID-9BA458C1-3773-4411-AC94-EE76C8AA21CE"></a>
<h4 id="BDCUG-GUID-9BA458C1-3773-4411-AC94-EE76C8AA21CE" class="sect4"><span class="enumeration_section">6.5.1.2</span> seq:collection-xml</h4>
<div>
<p>Accesses a collection of sequence files in HDFS, parses each value as XML, and returns it. Each file may be split up and processed in parallel by multiple tasks.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %seq:collection("xml") function 
   seq:collection-xml($uris as xs:string*) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The sequence file URIs. The values in the sequence files must be either <code class="codeph">org.apache.hadoop.io.Text</code> or <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. For <code class="codeph">BytesWritable</code> values, the XML document encoding declaration is used, if it is available.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One XML document for each value in each file. See <span class="q">"<a href="oxh_ref.htm#GUID-4B931558-D4A5-47BE-85CF-B739F0D4BFF1">Tika Parser Output Format</a>."</span></p>
</div>
</div>
<a id="BDCUG840"></a><a id="BDCUG841"></a><a id="BDCUG842"></a><a id="BDCUG843"></a><a id="BDCUG844"></a><a id="BDCUG637"></a>
<div class="sect4"><a id="GUID-6A317849-56F8-4109-95BB-C0AA465813ED"></a>
<h4 id="BDCUG-GUID-6A317849-56F8-4109-95BB-C0AA465813ED" class="sect4"><span class="enumeration_section">6.5.1.3</span> seq:collection-binxml</h4>
<div>
<p>Accesses a collection of sequence files in the HDFS, reads each value as binary XML, and returns it. Each file may be split up and processed in parallel by multiple tasks.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %seq:collection("binxml") function 
   seq:collection-binxml($uris as xs:string*) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The sequence file URIs. The values in the sequence files must be <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. The bytes are decoded as binary XML.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One XML document for each value in each file.</p>
<div class="section">
<p class="subhead3">Notes</p>
</div>
<!-- class="section" -->
<p>You can use this function to read files that were created by <code class="codeph">seq:put-binxml</code> in a previous query. See <span class="q">"<a href="oxh_ref.htm#GUID-61AF5E5C-9F0C-4972-B2D6-1C677E0A3E7D">seq:put-binxml</a>."</span></p>
</div>
</div>
<a id="BDCUG1012"></a><a id="BDCUG1013"></a><a id="BDCUG1014"></a><a id="BDCUG1011"></a>
<div class="sect4"><a id="GUID-CEFA0D28-055F-4B8F-9251-10492A223810"></a>
<h4 id="BDCUG-GUID-CEFA0D28-055F-4B8F-9251-10492A223810" class="sect4"><span class="enumeration_section">6.5.1.4</span> seq:collection-tika</h4>
<div>
<p>Uses Tika to parse the sequence files in the HDFS. The values in the sequence files must be either <code class="codeph">org.apache.hadoop.io.Text</code> or <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. For each value a document node returned produced by Tika.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %seq:collection("tika") function 
   seq:collection-tika($uris as xs:string*) as document-node()* external;
declare %seq:collection("tika") function 
   seq:collection-tika($uris as xs:string*, $contentType as xs:string?) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The sequence file URIs. The values in the sequence files must be either <code class="codeph">org.apache.hadoop.io.Text</code> or <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. Tika library automatically detects character encoding. Alternatively, the encoding can be passed in $contentType parameter as <span class="italic">charset</span> attribute.</p>
<p><code class="codeph">$contentType</code>: Specifies the media type of the content to parse, and may have the <span class="italic">charset</span> attribute.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One document node for each value in each file.</p>
</div>
</div>
<a id="BDCUG845"></a><a id="BDCUG846"></a><a id="BDCUG847"></a><a id="BDCUG848"></a><a id="BDCUG638"></a>
<div class="sect4"><a id="GUID-A5D1D66A-70E8-4DFE-8796-2F421124285F"></a>
<h4 id="BDCUG-GUID-A5D1D66A-70E8-4DFE-8796-2F421124285F" class="sect4"><span class="enumeration_section">6.5.1.5</span> seq:put</h4>
<div>
<p>Writes either the string value or both the key and string value of a key-value pair to a sequence file in the output directory of the query.</p>
<p>This function writes the keys and values as <code class="codeph">org.apache.hadoop.io.Text</code>.</p>
<p>When the function is called without the <code class="codeph">$key</code> parameter, it writes the values as <code class="codeph">org.apache.hadoop.io.Text</code> and sets the key class to <code class="codeph">org.apache.hadoop.io.NullWritable</code>, because there are no key values.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %seq:put("text") function
   seq:put($key as xs:string, $value as xs:string) external;

declare %seq:put("text") function 
   seq:put($value as xs:string) external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$key</code>: The key of a key-value pair</p>
<p><code class="codeph">$value</code>: The value of a key-value pair</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
empty-sequence()
</pre>
<div class="section">
<p class="subhead3">Notes</p>
</div>
<!-- class="section" -->
<p>The values are spread across one or more sequence files. The number of files created depends on how the query is distributed among tasks. Each file has a name that starts with <code class="codeph">part</code>, such as <code class="codeph">part-m-00000</code>. You specify the output directory when the query executes. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>."</span></p>
</div>
</div>
<a id="BDCUG849"></a><a id="BDCUG850"></a><a id="BDCUG851"></a><a id="BDCUG852"></a><a id="BDCUG640"></a>
<div class="sect4"><a id="GUID-4D003FFD-5977-4911-B6DF-2162D5C65A45"></a>
<h4 id="BDCUG-GUID-4D003FFD-5977-4911-B6DF-2162D5C65A45" class="sect4"><span class="enumeration_section">6.5.1.6</span> seq:put-xml</h4>
<div>
<p>Writes either an XML value or a key and XML value to a sequence file in the output directory of the query.</p>
<p>This function writes the keys and values as <code class="codeph">org.apache.hadoop.io.Text</code>.</p>
<p>When the function is called without the <code class="codeph">$key</code> parameter, it writes the values as <code class="codeph">org.apache.hadoop.io.Text</code> and sets the key class to <code class="codeph">org.apache.hadoop.io.NullWritable</code>, because there are no key values.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %seq:put("xml") function
   seq:put-xml($key as xs:string, $xml as node()) external;

declare %seq:put("xml") function 
   seq:put-xml($xml as node()) external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$key</code>: The key of a key-value pair</p>
<p><code class="codeph">$value</code>: The value of a key-value pair</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
empty-sequence()
</pre>
<div class="section">
<p class="subhead3">Notes</p>
</div>
<!-- class="section" -->
<p>The values are spread across one or more sequence files. The number of files created depends on how the query is distributed among tasks. Each file has a name that starts with "part," such as part-m-00000. You specify the output directory when the query executes. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>."</span></p>
</div>
</div>
<a id="BDCUG853"></a><a id="BDCUG854"></a><a id="BDCUG855"></a><a id="BDCUG856"></a><a id="BDCUG857"></a><a id="BDCUG642"></a>
<div class="sect4"><a id="GUID-61AF5E5C-9F0C-4972-B2D6-1C677E0A3E7D"></a>
<h4 id="BDCUG-GUID-61AF5E5C-9F0C-4972-B2D6-1C677E0A3E7D" class="sect4"><span class="enumeration_section">6.5.1.7</span> seq:put-binxml</h4>
<div>
<p>Encodes an XML value as binary XML and writes the resulting bytes to a sequence file in the output directory of the query. The values are spread across one or more sequence files.</p>
<p>This function writes the keys as <code class="codeph">org.apache.hadoop.io.Text</code> and the values as <code class="codeph">org.apache.hadoop.io.BytesWritable</code>.</p>
<p>When the function is called without the <code class="codeph">$key</code> parameter, it writes the values as <code class="codeph">org.apache.hadoop.io.BytesWritable</code> and sets the key class to <code class="codeph">org.apache.hadoop.io.NullWritable</code>, because there are no key values.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %seq:put("binxml") function
   seq:put-binxml($key as xs:string, $xml as node()) external;

declare %seq:put("binxml") function 
   seq:put-binxml($xml as node()) external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$key</code>: The key of a key-value pair</p>
<p><code class="codeph">$value</code>: The value of a key-value pair</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
empty-sequence()
</pre>
<div class="section">
<p class="subhead3">Notes</p>
</div>
<!-- class="section" -->
<p>The number of files created depends on how the query is distributed among tasks. Each file has a name that starts with <code class="codeph">part</code>, such as <code class="codeph">part-m-00000</code>. You specify the output directory when the query executes. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>."</span></p>
<p>You can use the <code class="codeph">seq:collection-binxml</code> function to read the files created by this function. See <span class="q">"<a href="oxh_ref.htm#GUID-6A317849-56F8-4109-95BB-C0AA465813ED">seq:collection-binxml</a>."</span></p>
</div>
</div>
</div>
<a id="BDCUG647"></a>
<div class="sect3"><a id="GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416"></a>
<h3 id="BDCUG-GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416" class="sect3"><span class="enumeration_section">6.5.2</span> Custom Functions for Reading Sequence Files</h3>
<div>
<p>You can use the following annotations to define functions that read collections of <a id="d37476e8099" class="indexterm-anchor"></a><a id="d37476e8103" class="indexterm-anchor"></a><a id="d37476e8107" class="indexterm-anchor"></a><a id="d37476e8111" class="indexterm-anchor"></a><a id="d37476e8115" class="indexterm-anchor"></a>sequence files. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading sequence files must have one of the following signatures:</p>
<pre dir="ltr">
declare %seq:collection("text") [<span class="italic">additional annotations</span>] 
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as xs:string* external;

declare %seq:collection(["xml"|"binxml"|"tika"]) [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as document-node()* external;
declare %seq:collection(["tika"]) [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*, $contentType as xs:string?) as document-node()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416__GUID-246BA0ED-8712-4E09-9CEB-FE2805B89DC7"><!-- --></a>%seq:collection(["<span class="italic">method</span>"])</dt>
<dd>
<p>Declares the sequence file collection function, which reads sequence files. Required.</p>
<p>The optional <span class="italic">method</span> parameter can be one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">text</code>: The values in the sequence files must be either <code class="codeph">org.apache.hadoop.io.Text</code> or <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. Bytes are decoded using the character set specified by the <code class="codeph">%output:encoding</code> annotation. They are returned as <code class="codeph">xs:string</code>. Default.</p>
</li>
<li>
<p><code class="codeph">xml</code>: The values in the sequence files must be either <code class="codeph">org.apache.hadoop.io.Text</code> or <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. The values are parsed as XML and returned by the function.</p>
</li>
<li>
<p><code class="codeph">binxml</code>: The values in the sequence files must be <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. The values are read as XDK binary XML and returned by the function.</p>
</li>
<li>
<p><code class="codeph">tika</code>: The values in the sequence files must be either <code class="codeph">org.apache.hadoop.io.Text</code> or <code class="codeph">org.apache.hadoop.io.BytesWritable</code>. The values are parsed by Tika and returned by the function.</p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416__GUID-2DD389C2-AEA0-4731-B026-CAC6F539D701"><!-- --></a>%output:encoding("charset")</dt>
<dd>
<p>Specifies the character encoding of the input values. The valid encodings are those supported by the JVM. UTF-8 is the default encoding.</p>
<div class="infoboxnotealso" id="GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416__GUID-A13A325B-DE28-442E-A1A0-B9DCB14A65FD">
<p class="notep1">See Also:</p>
<p>"Supported Encodings" in the Oracle Java SE documentation at</p>
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html" target="_blank"><code class="codeph">http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html</code></a></p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416__GUID-FA50731E-9DE7-4CC6-B976-FA061EABBA27"><!-- --></a>%seq:key("true" | "false")</dt>
<dd>
<p>Controls whether the key of a key-value pair is set as the <code class="codeph">document-uri</code> of the returned value. Specify <code class="codeph">true</code> to return the keys. The default setting is <code class="codeph">true</code> when <span class="italic">method</span> is <code class="codeph">binxml</code> or <code class="codeph">xml</code>, and <code class="codeph">false</code> when it is <code class="codeph">text</code>.</p>
<p>Text functions with this annotation set to <code class="codeph">true</code> must return <code class="codeph">text()*</code> instead of <code class="codeph">xs:string*</code> because atomic <code class="codeph">xs:string</code> is not associated with a document.</p>
<p>When the keys are returned, you can obtain their string representations by using <code class="codeph">seq:key</code> function.</p>
<p>This example returns text instead of string values because <code class="codeph">%seq:key</code> is set to <code class="codeph">true</code>.</p>
<div class="p">
<pre dir="ltr">
declare %seq:collection("text") %seq:key("true")
   function local:col($uris as xs:string*) as text()* external;
</pre></div>
<p>The next example uses the <code class="codeph">seq:key</code> function to obtain the string representations of the keys:</p>
<div class="p">
<pre dir="ltr">
for $value in local:col(...)
let $key := $value/seq:key()
return 
   .
   .
   .
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416__GUID-8962DB37-4292-4471-8EA4-4404E9DF4599"><!-- --></a>%seq:split-max("<span class="italic">split-size</span>")</dt>
<dd>
<p>Specifies the maximum split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit). These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%seq:split-max(1024)
%seq:split-max("1024")
%seq:split-max("1K")
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-6D32A2A4-B353-44A7-AFC9-C68635AF1416__GUID-73E9FBB6-84D9-4CE5-8CB9-FB7C2C39F9C1"><!-- --></a>%seq:split-min("<span class="italic">split-size</span>")</dt>
<dd>
<p>Specifies the minimum <a id="d37476e8340" class="indexterm-anchor"></a><a id="d37476e8344" class="indexterm-anchor"></a>split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit). These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%seq:split-min(1024)
%seq:split-min("1024")
%seq:split-min("1K")
</pre></div>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG648"></a>
<div class="sect3"><a id="GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262"></a>
<h3 id="BDCUG-GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262" class="sect3"><span class="enumeration_section">6.5.3</span> Custom Functions for Writing Sequence Files</h3>
<div>
<p>You can use the following annotations to define functions that write collections of sequence files in HDFS.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for writing sequence files must have one of the following signatures. You can omit the <code class="codeph">$key</code> argument when you are not writing a key value.</p>
<pre dir="ltr">
declare %seq:put("text") [<span class="italic">additional annotations</span>] 
   function local:<span class="italic">myFunctionName</span>($key as xs:string, $value as xs:string) external;

declare %seq:put(["xml"|"binxml"]) [<span class="italic">additional annotations</span>] 
   function local:<span class="italic">myFunctionName</span>($key as xs:string, $xml as node()) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262__GUID-97FC71BD-37A2-4911-A3D8-2261D1498283"><!-- --></a>%seq:put("<span class="italic">method</span>")</dt>
<dd>
<p>Declares the sequence file put function, which writes key-value pairs to a sequence file. Required.</p>
<p>If you use the <code class="codeph">$key</code> argument in the signature, then the key is written as <code class="codeph">org.apache.hadoop.io.Text</code>. If you omit the <code class="codeph">$key</code> argument, then the key class is set to <code class="codeph">org.apache.hadoop.io.NullWritable</code>.</p>
<p>Set the <span class="italic">method</span> parameter to <code class="codeph">text</code>, <code class="codeph">xml</code>, or <code class="codeph">binxml</code>. The <span class="italic">method</span> determines the type used to write the value:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">text</code>: String written as <code class="codeph">org.apache.hadoop.io.Text</code></p>
</li>
<li>
<p><code class="codeph">xml</code>: XML written as <code class="codeph">org.apache.hadoop.io.Text</code></p>
</li>
<li>
<p><code class="codeph">binxml</code>: XML encoded as XDK binary XML and written as <code class="codeph">org.apache.hadoop.io.BytesWritable</code></p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262__GUID-28992016-AEBA-4BC5-8DA1-8F54372C58AF"><!-- --></a>%seq:compress("<span class="italic">codec</span>", "<span class="italic">compressionType</span>")</dt>
<dd>
<p>Specifies the compression format used on the output. The default is no compression. Optional.</p>
<p>The <span class="italic">codec</span> parameter identifies a compression codec. The first registered compression codec that matches the value is used. The value matches a codec if it equals one of the following:</p>
<ol>
<li>
<p>The fully qualified class name of the codec</p>
</li>
<li>
<p>The unqualified class name of the codec</p>
</li>
<li>
<p>The prefix of the unqualified class name before <code class="codeph">Codec</code> (case insensitive)</p>
</li>
</ol>
<p>Set the <span class="italic">compressionType</span> parameter to one of these values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">block</code>: Keys and values are collected in groups and compressed together. Block compression is generally more compact, because the compression algorithm can take advantage of similarities among different values.</p>
</li>
<li>
<p><code class="codeph">record</code>: Only the values in the sequence file are compressed.</p>
</li>
</ul>
<p>All of these examples use the default codec and block compression:</p>
<div class="p">
<pre dir="ltr">
%seq:compress("org.apache.hadoop.io.compress.DefaultCodec", "block")
%seq:compress("DefaultCodec", "block")
%seq:compress("default", "block")
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262__GUID-64072198-BBF0-4268-AA71-8826B434FEBD"><!-- --></a>%seq:file("<span class="italic">name</span>")</dt>
<dd>
<p>Specifies the output file name prefix. The default prefix is <code class="codeph">part</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262__GUID-D65A2726-897A-40E7-838B-033D9B13C8D1"><!-- --></a>%output:<span class="italic">parameter</span></dt>
<dd>
<p>A standard XQuery serialization parameter for the output method (text or XML) specified in <code class="codeph">%seq:put</code>. See <span class="q">"<a href="oxh_ref.htm#GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5">Serialization Annotations</a>."</span></p>
<div class="infoboxnotealso" id="GUID-D86489E6-D5AC-4FA6-9542-BE5C17D9E262__GUID-DE42CF55-B050-409E-99D5-8C71399D65AA">
<p class="notep1">See Also:</p>
<p><span><cite>SequenceFile</cite> at <a href="https://wiki.apache.org/hadoop/SequenceFile" target="_blank"><code class="codeph">https://wiki.apache.org/hadoop/SequenceFile</code></a></span></p>
<p>"The Influence of Serialization Parameters" sections for XML and text output methods in<span><cite>XSLT and XQuery Serialization 3.1</cite> at <a href="http://www.w3.org/TR/xslt-xquery-serialization-31/" target="_blank"><code class="codeph">http://www.w3.org/TR/xslt-xquery-serialization-31/</code></a></span></p>
</div>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1068"></a><a id="BDCUG1069"></a><a id="BDCUG1070"></a><a id="BDCUG1071"></a><a id="BDCUG644"></a>
<div class="sect3"><a id="GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972"></a>
<h3 id="BDCUG-GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972" class="sect3"><span class="enumeration_section">6.5.4</span> Examples of Sequence File Adapter Functions</h3>
<div>
<p>These examples queries three XML files in HDFS with the following contents. Each XML file contains comments made by users on a specific day. Each comment can have zero or more "likes" from other users.</p>
<pre dir="ltr">
mydata/comments1.xml
 
&lt;comments date="2013-12-30"&gt;
   &lt;comment id="12345" user="john" text="It is raining :( "/&gt;
   &lt;comment id="56789" user="kelly" text="I won the lottery!"&gt;
      &lt;like user="john"/&gt;
      &lt;like user="mike"/&gt;
   &lt;/comment&gt;
&lt;/comments&gt;
 
mydata/comments2.xml
 
&lt;comments date="2013-12-31"&gt;
   &lt;comment id="54321" user="mike" text="Happy New Year!"&gt;
      &lt;like user="laura"/&gt;
   &lt;/comment&gt;
&lt;/comments&gt;
 
mydata/comments3.xml
  
&lt;comments date="2014-01-01"&gt;
   &lt;comment id="87654" user="mike" text="I don't feel so good."/&gt;
   &lt;comment id="23456" user="john" text="What a beautiful day!"&gt;
      &lt;like user="kelly"/&gt;
      &lt;like user="phil"/&gt;
   &lt;/comment&gt;
&lt;/comments&gt;
</pre>
<div class="example" id="GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972__GUID-3D0AEADD-26F5-4EC1-91AB-23EC5D817B1D">
<p class="titleinexample">Example 6-14</p>
<p>The following query stores the <code class="codeph">comment</code> elements in sequence files.</p>
<pre dir="ltr">
import module "oxh:seq";
import module "oxh:xmlf";
 
for $comment in xmlf:collection("mydata/comments*.xml", "comment")
return 
   seq:put-xml($comment)
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972__GUID-10ACF90F-93B2-47E6-9294-F6E88D9BBE8A">
<p class="titleinexample">Example 6-15</p>
<p>The next query reads the sequence files generated by the previous query, which are stored in an output directory named <code class="codeph">myoutput</code>. The query then writes the names of users who made multiple comments to a text file.</p>
<pre dir="ltr">
import module "oxh:seq";
import module "oxh:text";

for $comment in seq:collection-xml("myoutput/part*")/comment
let $user := $comment/@user
group by $user
let $count := count($comment)
where $count gt 1
return
   text:put($user || " " || $count)
</pre>
<p>The text file created by the previous query contain the following lines:</p>
<pre dir="ltr">
john 2
mike 2
</pre>
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-C8085B84-9570-4F53-BA5E-E7EE13010130">XML File Adapter</a>."</span></p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972__GUID-92FC6F76-5EA0-4C80-B5E3-7E2AD6949629">
<p class="titleinexample">Example 6-16</p>
<p>The following query extracts <code class="codeph">comment</code> elements from XML files and stores them in compressed sequence files. Before storing each comment, it deletes the <code class="codeph">id</code> attribute and uses the value as the key in the sequence files.</p>
<pre dir="ltr">
import module "oxh:xmlf";

declare 
   %seq:put("xml")
   %seq:compress("default", "block") 
   %seq:file("comments")
function local:myPut($key as xs:string, $value as node()) external;    
</pre>
<pre dir="ltr">
for $comment in xmlf:collection("mydata/comments*.xml", "comment")
let $id := $comment/@id
let $newComment := 
   copy $c := $comment 
   modify delete node $c/@id
   return $c
return
   local:myPut($id, $newComment)
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-139B1EDD-993A-4370-A88F-FE66A9E9D972__GUID-C4D4C9D0-E37A-4CA4-90D4-E1DF8CAEA1AC">
<p class="titleinexample">Example 6-17</p>
<p>The next query reads the sequence files that the previous query created in an output directory named <code class="codeph">myoutput</code>. The query automatically decompresses the sequence files.</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:seq";

for $comment in seq:collection-xml("myoutput/comments*")/comment
let $id := $comment/seq:key()
where $id eq "12345"
return 
   text:put-xml($comment)
 
</pre>
<p>The query creates a text file that contains the following line:</p>
<pre dir="ltr">
&lt;comment id="12345" user="john" text="It is raining :( "/&gt;
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="BDCUG860"></a>
<div class="sect2"><a id="GUID-77FBEE8B-F850-4DF2-B618-CBD6B67E73DE"></a>
<h2 id="BDCUG-GUID-77FBEE8B-F850-4DF2-B618-CBD6B67E73DE" class="sect2"><span class="enumeration_section">6.6</span> Solr Adapter</h2>
<div>
<p>This adapter provides functions to create full-text indexes and load them into Apache Solr servers. These functions call the Solr <code class="codeph">org.apache.solr.hadoop.MapReduceIndexerTool</code> at run time to generate a full-text index on HDFS and optionally merge it into Solr servers. You can declare and use multiple custom put functions supplied by this adapter and the built-in put function within a single query. For example, you can load data into different Solr collections or into different Solr clusters.</p>
<p>This adapter is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-7C068633-3FE8-458A-BDE0-08D36645785D">Prerequisites for Using the Solr Adapter</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-4D6A0CF4-EBC3-4C2A-8CD9-EC19C582BCE7">Built-in Functions for Loading Data into Solr Servers</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-C459019F-83EA-430C-8514-E0B4E260EA28">Custom Functions for Loading Data into Solr Servers</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-55D02E17-FEB0-4D31-9C7E-E6A9E11BFF61">Examples of Solr Adapter Functions</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C">Solr Adapter Configuration Properties</a></p>
</li>
</ul>
</div>
<a id="BDCUG861"></a>
<div class="sect3"><a id="GUID-7C068633-3FE8-458A-BDE0-08D36645785D"></a>
<h3 id="BDCUG-GUID-7C068633-3FE8-458A-BDE0-08D36645785D" class="sect3"><span class="enumeration_section">6.6.1</span> Prerequisites for Using the Solr Adapter</h3>
<div>
<p>The first time that you use the Solr adapter, ensure that Solr is installed and configured on your Hadoop cluster as described in <span class="q">"<a href="start.htm#GUID-E5EB1E76-518C-4FF6-9369-AF4C81F7B12D">Installing Oracle XQuery for Hadoop</a>"</span>.</p>
</div>
<a id="BDCUG862"></a>
<div class="sect4"><a id="GUID-7931B445-99E3-4E69-BB61-7626FB52EE4B"></a>
<h4 id="BDCUG-GUID-7931B445-99E3-4E69-BB61-7626FB52EE4B" class="sect4"><span class="enumeration_section">6.6.1.1</span> Configuration Settings</h4>
<div>
<p>Your Oracle XQuery for Hadoop query must use the following configuration properties or the equivalent annotation:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">oracle.hadoop.xquery.solr.loader.zk-host</code></p>
</li>
<li>
<p><code class="codeph">oracle.hadoop.xquery.solr.loader.collection</code></p>
</li>
</ul>
<p>If the index is loaded into a live set of Solr servers, then this configuration property or the equivalent annotation is also required:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">oracle.hadoop.xquery.solr.loader.go-live</code></p>
</li>
</ul>
<p>You can set the configuration properties using either the <code class="codeph">-D</code> or <code class="codeph">-conf</code> options in the <code class="codeph">hadoop</code> command when you run the query. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>"</span> and <span class="q">"<a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C">Solr Adapter Configuration Properties</a>"</span></p>
</div>
</div>
<a id="BDCUG863"></a>
<div class="sect4"><a id="GUID-FDB510B1-9654-45F3-8F33-139F4D404AF3"></a>
<h4 id="BDCUG-GUID-FDB510B1-9654-45F3-8F33-139F4D404AF3" class="sect4"><span class="enumeration_section">6.6.1.2</span> Example Query Using the Solr Adapter</h4>
<div>
<p>This example sets <code class="codeph">OXH_SOLR_MR_HOME</code> and uses the <code class="codeph">hadoop -D</code> option in a query to set the configuration properties:</p>
<pre dir="ltr">
$ export OXH_SOLR_MR_HOME=/usr/lib/solr/contrib/mr 
$ hadoop jar $OXH_HOME/lib/oxh.jar -D oracle.hadoop.xquery.solr.loader.zk-host=/solr -D oracle.hadoop.xquery.solr.loader.collection=collection1 -D oracle.hadoop.xquery.solr.loader.go-live=true  ./myquery.xq -output ./myoutput
</pre></div>
</div>
</div>
<a id="BDCUG864"></a>
<div class="sect3"><a id="GUID-4D6A0CF4-EBC3-4C2A-8CD9-EC19C582BCE7"></a>
<h3 id="BDCUG-GUID-4D6A0CF4-EBC3-4C2A-8CD9-EC19C582BCE7" class="sect3"><span class="enumeration_section">6.6.2</span> Built-in Functions for Loading Data into Solr Servers</h3>
<div>
<p>To use the built-in functions in your query, you must import the Solr module as follows:</p>
<pre dir="ltr">
import module "oxh:solr";
</pre>
<p>The Solr module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-D52742BE-CD13-487D-81B4-F996770F5746">solr:put</a></code></p>
</li>
</ul>
<p>The <code class="codeph">solr</code> prefix is bound to the <code class="codeph">oxh:solr</code> namespace by default.</p>
</div>
<a id="BDCUG866"></a><a id="BDCUG867"></a><a id="BDCUG868"></a><a id="BDCUG865"></a>
<div class="sect4"><a id="GUID-D52742BE-CD13-487D-81B4-F996770F5746"></a>
<h4 id="BDCUG-GUID-D52742BE-CD13-487D-81B4-F996770F5746" class="sect4"><span class="enumeration_section">6.6.2.1</span> solr:put</h4>
<div>
<p>Writes a single document to the Solr index.</p>
<p>This document XML format is specified by Solr at</p>
<p><a href="https://wiki.apache.org/solr/UpdateXmlMessages" target="_blank"><code class="codeph">https://wiki.apache.org/solr/UpdateXmlMessages</code></a></p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %solr:put function
   solr:put($value as element(doc)) external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$value</code>: A single XML element named <code class="codeph">doc</code>, which contains one or more <code class="codeph">field</code> elements, as shown here:</p>
<pre dir="ltr">
&lt;doc&gt;
&lt;field name="field_name_1"&gt;field_value_1&lt;/field&gt;
     .
     .
     .
&lt;field name="field_name_N"&gt;field_value_N&lt;/field&gt;
&lt;/doc&gt;
</pre>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>A generated index that is written into the <span class="italic"><code class="codeph">output_dir</code></span><code class="codeph">/solr-put</code> directory, where <span class="italic">output_dir</span> is the query output directory</p>
</div>
</div>
</div>
<a id="BDCUG869"></a>
<div class="sect3"><a id="GUID-C459019F-83EA-430C-8514-E0B4E260EA28"></a>
<h3 id="BDCUG-GUID-C459019F-83EA-430C-8514-E0B4E260EA28" class="sect3"><span class="enumeration_section">6.6.3</span> Custom Functions for Loading Data into Solr Servers</h3>
<div>
<p>You can use the following annotations to define functions that generate full-text indexes and load them into Solr.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for generating Solr indexes must have the following signature:</p>
<pre dir="ltr">
declare %solr:put [<span class="italic">additional annotations</span>] 
   function local:<span class="italic">myFunctionName</span>($value as node()) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-C459019F-83EA-430C-8514-E0B4E260EA28__GUID-74F561C7-A1FE-4444-B9D5-E9CE8EDD428A"><!-- --></a>%solr:put</dt>
<dd>
<p>Declares the solr put function. Required.</p>
</dd>
<dt class="dlterm"><a id="GUID-C459019F-83EA-430C-8514-E0B4E260EA28__GUID-DF334EE6-77AB-4DF3-87AC-06BE725E9A5B"><!-- --></a>%solr:file(directory_name)</dt>
<dd>
<p>Name of the subdirectory under the query output directory where the index files will be written. Optional, the default value is the function local name.</p>
</dd>
<dt class="dlterm"><a id="GUID-C459019F-83EA-430C-8514-E0B4E260EA28__GUID-17449753-39F5-4DE6-8342-81E79B4DD4BD"><!-- --></a>%solr-property:property_name(value)</dt>
<dd>
<p>Controls various aspects of index generation. You can specify multiple <code class="codeph">%solr-property</code> annotations.</p>
<p>These annotations correspond to the command-line options of <code class="codeph">org.apache.solr.hadoop.MapReduceIndexerTool</code>. Each <code class="codeph">MapReduceIndexerTool?</code> option has an equivalent Oracle XQuery for Hadoop configuration property and a <code class="codeph">%solr-property</code> annotation. Annotations take precedence over configuration properties. See <span class="q">"<a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C">Solr Adapter Configuration Properties</a>"</span> for more information about supported configuration properties and the corresponding annotations.</p>
<div class="infoboxnotealso" id="GUID-C459019F-83EA-430C-8514-E0B4E260EA28__GUID-ED1AE25D-0943-4A6C-BF75-4900CDD3E996">
<p class="notep1">See Also:</p>
<p>For more information about <code class="codeph">MapReduceIndexerTool?</code> command line options, see <span class="italic">Cloudera Search User Guide</span> at</p>
<p><a href="http://www.oracle.com/pls/topic/lookup?ctx=E87334-01&amp;id=cloudera_mapreduceindexertool" target="_blank"><code class="codeph">http://www.cloudera.com/content/cloudera-content/cloudera-docs/Search/latest/Cloudera-Search-User-Guide/csug_mapreduceindexertool.html</code></a></p>
</div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<p><code class="codeph">$value</code>: An element or a document node conforming to the Solr XML syntax. See <span class="q">"<a href="oxh_ref.htm#GUID-D52742BE-CD13-487D-81B4-F996770F5746">solr:put</a>"</span> for details.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1072"></a><a id="BDCUG870"></a>
<div class="sect3"><a id="GUID-55D02E17-FEB0-4D31-9C7E-E6A9E11BFF61"></a>
<h3 id="BDCUG-GUID-55D02E17-FEB0-4D31-9C7E-E6A9E11BFF61" class="sect3"><span class="enumeration_section">6.6.4</span> Examples of Solr Adapter Functions</h3>
<div>
<div class="example" id="GUID-55D02E17-FEB0-4D31-9C7E-E6A9E11BFF61__GUID-5D680EA3-03CC-4433-874D-D967E6B45E72">
<p class="titleinexample">Example 6-18 Using the Built-in solr:put Function</p>
<p>This example uses the following HDFS text file. The file contains user profile information such as user ID, full name, and age, separated by colons (:).</p>
<pre dir="ltr">
mydata/users.txt
john:John Doe:45 
kelly:Kelly Johnson:32
laura:Laura Smith: 
phil:Phil Johnson:27
</pre>
<p>The first query creates a full-text index searchable by name.</p>
<pre dir="ltr">
import module "oxh:text";
import module "oxh:solr";
for $line in text:collection("mydata/users.txt") 
let $split := fn:tokenize($line, ":") 
let $id := $split[1]
let $name := $split[2]
return solr:put(
&lt;doc&gt;
&lt;field name="id"&gt;{ $id }&lt;/field&gt;
&lt;field name="name"&gt;{ $name }&lt;/field&gt;
&lt;/doc&gt;
)
</pre>
<p>The second query accomplishes the same result, but uses a custom put function. It also defines all configuration parameters by using function annotations. Thus, setting configuration properties is not required when running this query.</p>
<pre dir="ltr">
import module "oxh:text";
declare %solr:put %solr-property:go-live %solr-property:zk-host("/solr") %solr-property:collection("collection1") 
function local:my-solr-put($doc as element(doc)) external;
for $line in text:collection("mydata/users.txt") 
let $split := fn:tokenize($line, ":") 
let $id := $split[1]
let $name := $split[2]
return local:my-solr-put(
&lt;doc&gt;
&lt;field name="id"&gt;{ $id }&lt;/field&gt;
&lt;field name="name"&gt;{ $name }&lt;/field&gt;
&lt;/doc&gt;
)
</pre></div>
<!-- class="example" --></div>
</div>
<a id="BDCUG872"></a>
<div class="sect3"><a id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C"></a>
<h3 id="BDCUG-GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C" class="sect3"><span class="enumeration_section">6.6.5</span> Solr Adapter Configuration Properties</h3>
<div>
<p>The Solr adapter configuration properties correspond to the Solr <code class="codeph">MapReduceIndexerTool</code> options.</p>
<p><code class="codeph">MapReduceIndexerTool</code> is a MapReduce batch job driver that creates Solr index shards from input files, and writes the indexes into HDFS. It also supports merging the output shards into live Solr servers, typically a SolrCloud.</p>
<p>You can specify these properties with the generic <code class="codeph">-conf</code> and <code class="codeph">-D</code> <code class="codeph">hadoop</code> command-line options in Oracle XQuery for Hadoop. Properties specified using this method apply to all Solr adapter put functions in your query. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>"</span> and especially <span class="q">"<a href="oxh.htm#GUID-6F7FDEB0-B55F-468A-B103-08C39BB3998C">Generic Options</a>"</span> for more information about the <code class="codeph">hadoop</code> command-line options.</p>
<p>Alternatively, you can specify these properties as Solr adapter put function annotations with the <code class="codeph">%solr-property</code> prefix. These annotations are identified in the property descriptions. Annotations apply only to the particular Solr adapter put function that contains them in its declaration.</p>
<div class="infoboxnotealso" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-1F840CFE-29DA-4F88-85BF-A0135D250324">
<p class="notep1">See Also:</p>
<p>For discussions about how Solr uses the <code class="codeph">MapReduceIndexerTool</code> options, see the <span class="italic">Cloudera Search User Guide</span> at</p>
<p><a href="http://www.cloudera.com/content/cloudera-content/cloudera-docs/Search/latest/Cloudera-Search-User-Guide/csug_mapreduceindexertool.html" target="_blank"><code class="codeph">http://www.cloudera.com/content/cloudera-content/cloudera-docs/Search/latest/Cloudera-Search-User-Guide/csug_mapreduceindexertool.html</code></a></p>
</div>
<div class="tblformalwide" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-4AB4D589-8D60-4958-A651-DFE27A49302D">
<table class="cellalignment23" summary="Provides an overview of each Solr Adapter configuration property, including the Type, Default Value, Equivalent Annotation, and Description of the property.">
<thead>
<tr class="cellalignment2">
<th class="cellalignment40" id="d37476e9179">Property</th>
<th class="cellalignment40" id="d37476e9181">Overview</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEBJDIG">
<td class="cellalignment2" id="d37476e9185" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.collection</span></p>
</td>
<td class="cellalignment2" headers="d37476e9185 d37476e9181">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: Not defined</p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:collection</code></p>
<p><span class="bold">Description</span>: The SolrCloud collection for merging the index, such as <code class="codeph">mycollection</code>. Use this property with <code class="codeph"><a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEFIEIB">oracle.hadoop.xquery.solr.loader.go-live</a></code> and <code class="codeph"><a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEIGFDD">oracle.hadoop.xquery.solr.loader.zk-host</a></code>. Required as either a property or an annotation.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-4DC7375B-A04B-4BCB-83E0-52C93C9CE14A">
<td class="cellalignment2" id="d37476e9222" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.fair-scheduler-pool</span></p>
</td>
<td class="cellalignment2" headers="d37476e9222 d37476e9181">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: Not defined</p>
<p><span class="bold">Equivalent Annotation</span>:<code class="codeph">%solr-property:fair-scheduler-pool</code></p>
<p><span class="bold">Description</span>: The name of the fair scheduler pool for submitting jobs. The job runs using fair scheduling instead of the default Hadoop scheduling method. Optional.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEFIEIB">
<td class="cellalignment2" id="d37476e9246" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.go-live</span></p>
</td>
<td class="cellalignment2" headers="d37476e9246 d37476e9181">
<p><span class="bold">Type</span>: String values <code class="codeph">true</code> or <code class="codeph">false</code></p>
<p><span class="bold">Default Value</span>: <code class="codeph">false</code></p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:go-live</code></p>
<p><span class="bold">Description</span>: Set to <code class="codeph">true</code> to enable the final index to merge into a live Solr cluster. Use this property with <code class="codeph"><a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEBJDIG">oracle.hadoop.xquery.solr.loader.collection</a></code> and <code class="codeph"><a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEIGFDD">oracle.hadoop.xquery.solr.loader.zk-host</a></code>. Optional.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-7FEECF94-ADA0-44EF-B942-F17C9D918A87">
<td class="cellalignment2" id="d37476e9290" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.go-live-threads</span></p>
</td>
<td class="cellalignment2" headers="d37476e9290 d37476e9181">
<p><span class="bold">Type</span>: Integer</p>
<p><span class="bold">Default Value</span>: <code class="codeph">1000</code></p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:go-live-threads</code></p>
<p><span class="bold">Description</span>: The maximum number of live merges that can run in parallel. Optional.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-603B147D-EA35-4F6A-B7CA-7AE41067CBD6">
<td class="cellalignment2" id="d37476e9316" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.log4j</span></p>
</td>
<td class="cellalignment2" headers="d37476e9316 d37476e9181">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>:</p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:log4j</code></p>
<p><span class="bold">Description</span>: The relative or absolute path to the <code class="codeph">log4j.properties</code> configuration file on the local file system For example, <code class="codeph">/path/to/log4j.properties</code>. Optional.</p>
<p>This file is uploaded for each MapReduce task.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-A93CD2E0-527E-4942-99E6-BD1163CE0411">
<td class="cellalignment2" id="d37476e9348" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.mappers</span></p>
</td>
<td class="cellalignment2" headers="d37476e9348 d37476e9181">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: <code class="codeph">-1</code></p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:mappers</code></p>
<p><span class="bold">Description</span>: The maximum number of mapper tasks that Solr uses. A value of <code class="codeph">-1</code> enables the use of all map slots available on the cluster.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-A0620411-A1A9-4707-B811-F238BE7BF9DC">
<td class="cellalignment2" id="d37476e9377" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.max-segments</span></p>
</td>
<td class="cellalignment2" headers="d37476e9377 d37476e9181">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: <code class="codeph">1</code></p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:max-segments</code></p>
<p><span class="bold">Description</span>: The maximum number of segments in the index generated by each reducer.</p>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__GUID-19C0919E-095C-46B3-8E42-C8A2C8BBBCF2">
<td class="cellalignment2" id="d37476e9403" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.reducers</span></p>
</td>
<td class="cellalignment2" headers="d37476e9403 d37476e9181">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: <code class="codeph">-1</code></p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:reducers</code></p>
<p><span class="bold">Description</span>: The number of reducers to use:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">-1</code>: Uses all reduce slots available on the cluster.</p>
</li>
<li>
<p><code class="codeph">-2</code>: Uses one reducer for each Solr output shard. This setting disables the MapReduce M-tree merge algorithm, which typically improves scalability.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment2" id="GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEIGFDD">
<td class="cellalignment2" id="d37476e9440" headers="d37476e9179">
<p><span class="bold">oracle.hadoop.xquery.solr.loader.zk-host</span></p>
</td>
<td class="cellalignment2" headers="d37476e9440 d37476e9181">
<p><span class="bold">Type</span>: String</p>
<p><span class="bold">Default Value</span>: Not defined</p>
<p><span class="bold">Equivalent Annotation</span>: <code class="codeph">%solr-property:zk-host</code></p>
<p><span class="bold">Description</span>: The address of a ZooKeeper ensemble used by the SolrCloud cluster. Specify the address as a list of comma-separated <span class="italic">host:port</span> pairs, each corresponding to a ZooKeeper server. For example, <code class="codeph">127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183/solr</code>. Optional.</p>
<p>If the address starts with a slash (/), such as <code class="codeph">/solr</code>, then Oracle XQuery for Hadoop automatically prefixes the address with the ZooKeeper connection string.</p>
<p>This property enables Solr to determine the number of output shards to create and the Solr URLs in which to merge them. Use this property with <code class="codeph"><a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEBJDIG">oracle.hadoop.xquery.solr.loader.collection</a></code> and <code class="codeph"><a href="oxh_ref.htm#GUID-3EE94912-31A3-4E6A-875F-4D27B5CE6A2C__CHEFIEIB">oracle.hadoop.xquery.solr.loader.golive</a></code>. Required as either a property or an annotation.</p>
</td>
</tr>
</tbody>
</table>
</div>
<!-- class="inftblhruleinformal" --></div>
</div>
</div>
<a id="BDCUG649"></a>
<div class="sect2"><a id="GUID-9E0B8917-D101-49A8-9EC9-00786B01C24C"></a>
<h2 id="BDCUG-GUID-9E0B8917-D101-49A8-9EC9-00786B01C24C" class="sect2"><span class="enumeration_section">6.7</span> Text File Adapter</h2>
<div>
<p>The <a id="d37476e9506" class="indexterm-anchor"></a><a id="d37476e9508" class="indexterm-anchor"></a><a id="d37476e9512" class="indexterm-anchor"></a>text file adapter provides functions to read and write text files stored in HDFS. It is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-9A98C31E-41A5-4165-B2C5-7308A44BDCCE">Built-in Functions for Reading and Writing Text Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482">Custom Functions for Reading Text Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-92F0784E-1912-452F-8A9C-7CE20FFDEB68">Custom Functions for Writing Text Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-9218384E-7511-48B5-A353-AE968DDE477F">Examples of Text File Adapter Functions</a></p>
</li>
</ul>
</div>
<a id="BDCUG650"></a>
<div class="sect3"><a id="GUID-9A98C31E-41A5-4165-B2C5-7308A44BDCCE"></a>
<h3 id="BDCUG-GUID-9A98C31E-41A5-4165-B2C5-7308A44BDCCE" class="sect3"><span class="enumeration_section">6.7.1</span> Built-in Functions for Reading and Writing Text Files</h3>
<div>
<p>To use the built-in functions in your query, you must import the text file module as follows:</p>
<pre dir="ltr">
import module "oxh:text";
</pre>
<p>The text file module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-4434A044-D906-4EF1-B490-D635B59CC900">text:collection</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-1913ED3C-93E9-4EE4-BB4A-D07C669ED463">text:collection-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-CC7F9175-47A2-49C7-816F-97C321C15AE2">text:put</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-1386065B-AEE5-4E2E-A2C2-6F2BDD4CF95A">text:put-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-5928139A-8EB4-4C67-A8F0-A3E964EF46E9">text:trace</a></code></p>
</li>
</ul>
<p>For examples, see <span class="q">"<a href="oxh_ref.htm#GUID-9218384E-7511-48B5-A353-AE968DDE477F">Examples of Text File Adapter Functions</a>."</span></p>
</div>
<a id="BDCUG873"></a><a id="BDCUG874"></a><a id="BDCUG875"></a><a id="BDCUG651"></a>
<div class="sect4"><a id="GUID-4434A044-D906-4EF1-B490-D635B59CC900"></a>
<h4 id="BDCUG-GUID-4434A044-D906-4EF1-B490-D635B59CC900" class="sect4"><span class="enumeration_section">6.7.1.1</span> text:collection</h4>
<div>
<p>Accesses a collection of text files in HDFS. The files can be compressed using a Hadoop-supported compression codec. They are automatically decompressed when read.</p>
<p>The files might be split up and processed in parallel by multiple tasks.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %text:collection("text") function
   text:collection($uris as xs:string*) as xs:string* external;

declare %text:collection("text") function
   function text:collection($uris as xs:string*, $delimiter as xs:string?) as xs:string* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The text file URIs.</p>
<p><code class="codeph">$delimiter</code>: A custom delimiter on which the file is split. The default is the newline character.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One string value for each file segment identified by the delimiter; for the default delimiter, a string value for each line in each file</p>
</div>
</div>
<a id="BDCUG876"></a><a id="BDCUG877"></a><a id="BDCUG878"></a><a id="BDCUG652"></a>
<div class="sect4"><a id="GUID-1913ED3C-93E9-4EE4-BB4A-D07C669ED463"></a>
<h4 id="BDCUG-GUID-1913ED3C-93E9-4EE4-BB4A-D07C669ED463" class="sect4"><span class="enumeration_section">6.7.1.2</span> text:collection-xml</h4>
<div>
<p>Accesses a collection of text files in HDFS. The files can be compressed using a Hadoop-supported compression codec. They are automatically decompressed when read.</p>
<p>The files might be split up and processed in parallel by multiple tasks. Each delimited section of each file is parsed as an XML document and returned by the function. Therefore, each segment must fully contain a single XML document, and any delimit characters in the XML must be escaped with XML character references. By default, the delimiter is a new line.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %text:collection("xml") function 
   text:collection-xml($uris as xs:string*) as document-node()* external;

declare %text:collection("xml") function 
   text:collection-xml($uris as xs:string*, $delimiter as xs:string?) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The text file URIs.</p>
<p><code class="codeph">$delimiter</code>: A custom delimiter on which the file is split. The default is the newline character.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One string value for each file segment identified by the delimiter; for the default delimiter, a string value for each line in each file</p>
</div>
</div>
<a id="BDCUG879"></a><a id="BDCUG880"></a><a id="BDCUG881"></a><a id="BDCUG882"></a><a id="BDCUG653"></a>
<div class="sect4"><a id="GUID-CC7F9175-47A2-49C7-816F-97C321C15AE2"></a>
<h4 id="BDCUG-GUID-CC7F9175-47A2-49C7-816F-97C321C15AE2" class="sect4"><span class="enumeration_section">6.7.1.3</span> text:put</h4>
<div>
<p>Writes a line to a text file in the output directory of the query. The lines are spread across one or more files.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %text:put("text") function
   text:put($value as xs:string) external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$value</code>: The text to write</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
empty-sequence()
</pre>
<div class="section">
<p class="subhead3">Notes</p>
</div>
<!-- class="section" -->
<p>The number of files created depends on how the query is distributed among tasks. Each file has a name that starts with <code class="codeph">part</code>, such as <code class="codeph">part-m-00000</code>. You specify the output directory when the query executes. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>."</span></p>
</div>
</div>
<a id="BDCUG883"></a><a id="BDCUG884"></a><a id="BDCUG885"></a><a id="BDCUG886"></a><a id="BDCUG654"></a>
<div class="sect4"><a id="GUID-1386065B-AEE5-4E2E-A2C2-6F2BDD4CF95A"></a>
<h4 id="BDCUG-GUID-1386065B-AEE5-4E2E-A2C2-6F2BDD4CF95A" class="sect4"><span class="enumeration_section">6.7.1.4</span> text:put-xml</h4>
<div>
<p>Writes XML to a line in a text file. The lines are spread across one or more files in the output directory of the query.</p>
<p>Newline characters in the serialized XML are replaced with character references to ensure that the XML does not span multiple lines. For example, <code class="codeph">&amp;#xA;</code> replaces the linefeed character (<code class="codeph">\n</code>).</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %text:put("xml") function
   text:put-xml($value as node()) external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$value</code>: The XML to write</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
empty-sequence()
</pre>
<div class="section">
<p class="subhead3">Notes</p>
</div>
<!-- class="section" -->
<p>The number of files created depends on how the query is distributed among tasks. Each file has a name that starts with <code class="codeph">part</code>, such as <code class="codeph">part-m-00000</code>. You specify the output directory when the query executes. See <span class="q">"<a href="oxh.htm#GUID-43ECAEB3-176F-413C-BFA5-BE35F2692E54">Running Queries</a>."</span></p>
</div>
</div>
<a id="BDCUG887"></a><a id="BDCUG888"></a><a id="BDCUG889"></a><a id="BDCUG655"></a>
<div class="sect4"><a id="GUID-5928139A-8EB4-4C67-A8F0-A3E964EF46E9"></a>
<h4 id="BDCUG-GUID-5928139A-8EB4-4C67-A8F0-A3E964EF46E9" class="sect4"><span class="enumeration_section">6.7.1.5</span> text:trace</h4>
<div>
<p>Writes a line to a text file named <code class="codeph">trace-*</code> in the output directory of the query. The lines are spread across one or more files.</p>
<p>This function provides you with a quick way to write to an alternate output. For example, you might create a trace file to identify invalid rows within a query, while loading the data into an Oracle database table.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %text:put("text") %text:file("trace") function
   text:trace($value as xs:string) external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$value</code>: The text to write</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
empty-sequence()
</pre></div>
</div>
</div>
<a id="BDCUG657"></a>
<div class="sect3"><a id="GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482"></a>
<h3 id="BDCUG-GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482" class="sect3"><span class="enumeration_section">6.7.2</span> Custom Functions for Reading Text Files</h3>
<div>
<p>You can use the following annotations to define functions that read collections of text files in HDFS. These annotations provide additional functionality that is not available using the built-in functions.</p>
<p>The input files can be compressed with a Hadoop-supported compression codec. They are automatically decompressed when read.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading text files must have one of the following signatures:</p>
<pre dir="ltr">
declare %text:collection("text") [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*, $delimiter as xs:string?) as xs:string* external;
 
declare %text:collection("text") [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as xs:string* external;
 
declare %text:collection("xml") [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*, $delimiter as xs:string?) as document-node()* external

declare %text:collection("xml") [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as document-node()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482__GUID-A4DF5066-5DAB-4EC9-81B6-54A6BA2AFCE3"><!-- --></a>%text:collection(["<span class="italic">method</span>"])</dt>
<dd>
<p>Declares the <code class="codeph">text</code> collection function. Required.</p>
<p>The optional <span class="italic">method</span> parameter can be one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">text</code>: Each line in the text file is returned as <code class="codeph">xs:string</code>. Default.</p>
</li>
<li>
<p><code class="codeph">xml</code>: Each line in the text file is parsed as XML and returned as <code class="codeph">document-node</code>. Each XML document must be fully contained on a single line. Newline characters inside the document must be represented by a numeric character reference.</p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482__GUID-572FCD98-D13E-457B-96A7-C25C187C0855"><!-- --></a>%text:split("<span class="italic">delimiter</span>")</dt>
<dd>
<p>Specifies a custom delimiter for splitting the input files. The default delimiter is the newline character.</p>
<p>Do not combine this annotation with the <code class="codeph">$delimiter</code> parameter. To specify a custom delimiter, use either this annotation or the <code class="codeph">$delimiter</code> parameter.</p>
</dd>
<dt class="dlterm"><a id="GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482__GUID-91A24695-A93B-4213-A5FD-9D25AE89D07F"><!-- --></a>%text:split-max("<span class="italic">split-size</span>")</dt>
<dd>
<p>Specifies the maximum split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit). These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%text:split-max(1024)
%text:split-max("1024")
%text:split-max("1K")
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482__GUID-2150B00D-F916-41B9-8995-4BE0D4E9F8B7"><!-- --></a>%text:split-min("<span class="italic">split-size</span>")</dt>
<dd>
<p>Specifies the minimum split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit). These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%text:split-min(1024)
%text:split-min("1024")
%text:split-min("1K")
</pre></div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<dl>
<dt class="dlterm"><a id="GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482__GUID-72A8D68E-28DD-4746-B351-7F26DFC651F1"><!-- --></a>$uris as xs:string*</dt>
<dd>
<p>Lists the HDFS file URIs. The files can be uncompressed or compressed with a Hadoop-supported codec. Required.</p>
</dd>
<dt class="dlterm"><a id="GUID-E5053CB1-3D56-41FC-982C-92A1B9E1E482__GUID-13D6B0B2-F42C-4D8E-B4CF-74B80FD1CF5E"><!-- --></a>$delimiter as xs:string?</dt>
<dd>
<p>A custom delimiter on which the input text files are split. The default delimiter is a new line. Do not combine this parameter with the <code class="codeph">%text:split</code> annotation.</p>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Returns</p>
<p><code class="codeph">xs:string*</code> for the <code class="codeph">text</code> method</p>
<p><code class="codeph">document-node()*</code> for the <code class="codeph">xml</code> method</p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG658"></a>
<div class="sect3"><a id="GUID-92F0784E-1912-452F-8A9C-7CE20FFDEB68"></a>
<h3 id="BDCUG-GUID-92F0784E-1912-452F-8A9C-7CE20FFDEB68" class="sect3"><span class="enumeration_section">6.7.3</span> Custom Functions for Writing Text Files</h3>
<div>
<p>You can use the following annotations to define functions that write text files in HDFS.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for writing text files must have one of the following signatures:</p>
<pre dir="ltr">
declare %text:put("text") [<span class="italic">additional annotations</span>] function 
   text:<span class="italic">myFunctionName</span>($value as xs:string) external;
 
declare %text:put("xml") [<span class="italic">additional annotations</span>] function 
   text:<span class="italic">myFunctionName</span>($value as node()) external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-92F0784E-1912-452F-8A9C-7CE20FFDEB68__GUID-C0F76DEB-3D32-434C-B126-E00882638DA5"><!-- --></a>%text:put(["<span class="italic">method</span>"])</dt>
<dd>
<p>Declares the <code class="codeph">text</code> put function. Required.</p>
<p>The optional <span class="italic">method</span> parameter can be one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">text</code>: Writes data to a text file. Default.</p>
</li>
<li>
<p><code class="codeph">xml</code>: Writes data to an XML file. The XML is serialized and newline characters are replaced with character references. This process ensures that the resulting XML document is one text line with no line breaks.</p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-92F0784E-1912-452F-8A9C-7CE20FFDEB68__GUID-37B1F646-FDB5-4808-B625-89C6E6FCAB4C"><!-- --></a>%text:compress("<span class="italic">codec</span>")</dt>
<dd>
<p>Specifies the compression format used on the output. The default is no compression. Optional.</p>
<p>The <span class="italic">codec</span> parameter identifies a compression codec. The first registered compression codec that matches the value is used. The value matches a codec if it equals one of the following:</p>
<ol>
<li>
<p>The fully qualified class name of the codec</p>
</li>
<li>
<p>The unqualified class name of the codec</p>
</li>
<li>
<p>The prefix of the unqualified class name before "Codec" (case insensitive)</p>
</li>
</ol>
<p>All of these examples use the default codec and block compression:</p>
<div class="p">
<pre dir="ltr">
%text:compress("org.apache.hadoop.io.compress.DefaultCodec", "block")
%text:compress("DefaultCodec", "block")
%text:compress("default", "block") 
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-92F0784E-1912-452F-8A9C-7CE20FFDEB68__GUID-1CBD8331-7FCA-4C66-A35C-1CCFDBFC54BF"><!-- --></a>%text:file("<span class="italic">name</span>")</dt>
<dd>
<p>Specifies the output file name prefix. The default prefix is <code class="codeph">part</code>.</p>
</dd>
<dt class="dlterm"><a id="GUID-92F0784E-1912-452F-8A9C-7CE20FFDEB68__GUID-2EDB4046-90B7-4826-A7F6-68D3ED2EB194"><!-- --></a>%output:<span class="italic">parameter</span></dt>
<dd>
<p>A standard XQuery <a id="d37476e10331" class="indexterm-anchor"></a>serialization parameter for the output method (text or XML) specified in <code class="codeph">%text:put</code>. See <span class="q">"<a href="oxh_ref.htm#GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5">Serialization Annotations</a>."</span></p>
<p>UTF-8 is currently the only supported character encoding.</p>
</dd>
</dl>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1073"></a><a id="BDCUG1074"></a><a id="BDCUG1075"></a><a id="BDCUG656"></a>
<div class="sect3"><a id="GUID-9218384E-7511-48B5-A353-AE968DDE477F"></a>
<h3 id="BDCUG-GUID-9218384E-7511-48B5-A353-AE968DDE477F" class="sect3"><span class="enumeration_section">6.7.4</span> Examples of Text File Adapter Functions</h3>
<div>
<div class="example" id="GUID-9218384E-7511-48B5-A353-AE968DDE477F__GUID-709DDDFA-55AE-4551-9D96-4C3826873D48">
<p class="titleinexample">Example 6-19 Using Built-in Functions to Query Text Files</p>
<p>This example uses following text files in HDFS. The files contain a log of visits to different web pages. Each line represents a visit to a web page and contains the time, user name, and page visited.</p>
<pre dir="ltr">
mydata/visits1.log  
 
2013-10-28T06:00:00, john, index.html, 200
2013-10-28T08:30:02, kelly, index.html, 200
2013-10-28T08:32:50, kelly, about.html, 200
2013-10-30T10:00:10, mike, index.html, 401

mydata/visits2.log  

2013-10-30T10:00:01, john, index.html, 200
2013-10-30T10:05:20, john, about.html, 200
2013-11-01T08:00:08, laura, index.html, 200
2013-11-04T06:12:51, kelly, index.html, 200
2013-11-04T06:12:40, kelly, contact.html, 200
</pre>
<p>The following query filters out the pages visited by <code class="codeph">john</code> and writes only the date and page visited to a new text file:</p>
<pre dir="ltr">
import module "oxh:text";
 
for $line in text:collection("mydata/visits*.log")
let $split := fn:tokenize($line, "\s*,\s*")
where $split[2] eq "john"
return
   text:put($split[1] || " " || $split[3])
 
</pre>
<p>This query creates a text file that contains the following lines:</p>
<pre dir="ltr">
2013-10-28T06:00:00 index.html
2013-10-30T10:00:01 index.html
2013-10-30T10:05:20 about.html
</pre>
<p>The next query computes the number of page visits per day:</p>
<pre dir="ltr">
import module "oxh:text";
 
for $line in text:collection("mydata/visits*.log")
let $split := fn:tokenize($line, "\s*,\s*")
let $time := xs:dateTime($split[1])
let $day := xs:date($time)
group by $day
return
   text:put($day || " =&gt; " || count($line))
 
</pre>
<p>The query creates text files that contain the following lines:</p>
<pre dir="ltr">
2013-10-28 =&gt; 3
2013-10-30 =&gt; 3
2013-11-01 =&gt; 1
2013-11-04 =&gt; 2
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9218384E-7511-48B5-A353-AE968DDE477F__CHEJIDFC">
<p class="titleinexample">Example 6-20 Querying Simple Delimited Formats</p>
<p>This example uses the <code class="codeph">fn:tokenize</code> function to parse the lines of a text file. This technique works well for simple delimited formats.</p>
<p>The following query declares custom put and collection functions. It computes the number of hits and the number of unique users for each page in the logs.</p>
<pre dir="ltr">
import module "oxh:text";

declare
   %text:collection("text")
   %text:split-max("32m")
function local:col($uris as xs:string*) as xs:string* external;
 
declare
   %text:put("xml")
   %text:compress("gzip") 
   %text:file("pages")
function local:out($arg as node()) external;
 
for $line in local:col("mydata/visits*.log")
let $split := fn:tokenize($line, "\s*,\s*")
let $user := $split[2]
let $page := $split[3]
group by $page
return
   local:out(
      &lt;page&gt;
         &lt;name&gt;{$page}&lt;/name&gt;
         &lt;hits&gt;{count($line)}&lt;/hits&gt;
         &lt;users&gt;{fn:count(fn:distinct-values($user))}&lt;/users&gt;
      &lt;/page&gt;
   )
</pre>
<p>The output directory of the previous query is named <code class="codeph">myoutput</code>. The following lines are written to <code class="codeph">myoutput/pages-r-*.gz</code>.</p>
<pre dir="ltr">
&lt;page&gt;&lt;name&gt;about.html&lt;/name&gt;&lt;hits&gt;2&lt;/hits&gt;&lt;users&gt;2&lt;/users&gt;&lt;/page&gt;
&lt;page&gt;&lt;name&gt;contact.html&lt;/name&gt;&lt;hits&gt;1&lt;/hits&gt;&lt;users&gt;1&lt;/users&gt;&lt;/page&gt;
&lt;page&gt;&lt;name&gt;index.html&lt;/name&gt;&lt;hits&gt;6&lt;/hits&gt;&lt;users&gt;4&lt;/users&gt;&lt;/page&gt;
</pre>
<p>The files are compressed with the <code class="codeph">gzip</code> codec. The following query reads the output files, and writes the page name and total hits as plain text. The collection function automatically decodes the compressed files.</p>
<pre dir="ltr">
import module "oxh:text";

for $page in text:collection-xml("myoutput/page*.gz")/page
return 
   text:put($page/name || "," || $page/hits)
 
</pre>
<p>This query creates text files that contain the following lines:</p>
<pre dir="ltr">
about.html,2
contact.html,1
index.html,6
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-9218384E-7511-48B5-A353-AE968DDE477F__GUID-E12A15A2-B681-4763-8194-B1A3FFCDBCE6">
<p class="titleinexample">Example 6-21 Querying Complex Text Formats</p>
<p>The <code class="codeph">fn:tokenize</code> function might not be adequate for complex formats that contain variety of data types and delimiters. This example uses the <code class="codeph">fn:analyze-string</code> function to process a log file in the Apache Common Log format.</p>
<p>A text file named mydata/access.log in HDFS contains the following lines:</p>
<pre dir="ltr">
192.0.2.0 - - [30/Sep/2013:16:39:38 +0000] "GET /inddex.html HTTP/1.1" 404 284
192.0.2.0 - - [30/Sep/2013:16:40:54 +0000] "GET /index.html HTTP/1.1" 200 12390
192.0.2.4 - - [01/Oct/2013:12:10:54 +0000] "GET /index.html HTTP/1.1" 200 12390
192.0.2.4 - - [01/Oct/2013:12:12:12 +0000] "GET /about.html HTTP/1.1" 200 4567
192.0.2.1 - - [02/Oct/2013:08:39:38 +0000] "GET /indexx.html HTTP/1.1" 404 284
192.0.2.1 - - [02/Oct/2013:08:40:54 +0000] "GET /index.html HTTP/1.1" 200 12390
192.0.2.1 - - [02/Oct/2013:08:42:38 +0000] "GET /aobut.html HTTP/1.1" 404 283
 
</pre>
<p>The following query computes the requests made after September 2013 when the server returned a status code 404 (Not Found) error. It uses a regular expression and <code class="codeph">fn:analyze-string</code> to match the components of the log entries. The time format cannot be cast directly to <code class="codeph">xs:dateTime</code>, as shown in <a href="oxh_ref.htm#GUID-9218384E-7511-48B5-A353-AE968DDE477F__CHEJIDFC">Example 6-20</a>. Instead, the <code class="codeph">ora-fn:dateTime-from-string-with-format</code> function converts the string to an instance of <code class="codeph">xs:dateTime</code>.</p>
<pre dir="ltr">
import module "oxh:text";

declare variable $REGEX :=
   '(\S+) (\S+) (\S+) \[([^\]]+)\] "([^"]+)" (\S+) (\S+)';

for $line in text:collection("mydata/access.log")
let $match := fn:analyze-string($line, $REGEX)/fn:match
let $time := 
   ora-fn:dateTime-from-string-with-format(
      "dd/MMM/yyyy:HH:mm:ss Z",
      $match/fn:group[4]
   )
let $status := $match/fn:group[6]
where 
   $status eq "404" and 
   $time ge xs:dateTime("2013-10-01T00:00:00")
let $host := $match/fn:group[1]
let $request := $match/fn:group[5]
return
   text:put($host || "," || $request)
</pre>
<p>The query creates text files that contain the following lines:</p>
<pre dir="ltr">
192.0.2.1,GET /indexx.html HTTP/1.1
192.0.2.1,GET /aobut.html HTTP/1.1
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso" id="GUID-9218384E-7511-48B5-A353-AE968DDE477F__GUID-C02B04BE-7B8D-4785-9046-7F6164F8C758">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><span class="italic">XPath and XQuery Functions and Operators 3.0</span> specification for information about the <code class="codeph">fn:tokenize</code> and <code class="codeph">fn:analyze-string</code> functions:</p>
<p><span><cite>fn:tokenize</cite> at <a href="http://www.w3.org/TR/xpath-functions-31/#func-tokenize" target="_blank"><code class="codeph">http://www.w3.org/TR/xpath-functions-31/#func-tokenize</code></a></span></p>
<p><span><cite>fn:analyze-string</cite> at <a href="http://www.w3.org/TR/xpath-functions-31/#func-analyze-string" target="_blank"><code class="codeph">http://www.w3.org/TR/xpath-functions-31/#func-analyze-string</code></a></span></p>
</li>
<li>
<p>For information about the Apache Common log format:</p>
<p><a href="http://httpd.apache.org/docs/current/logs.html" target="_blank"><code class="codeph">http://httpd.apache.org/docs/current/logs.html</code></a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="BDCUG1015"></a>
<div class="sect2"><a id="GUID-6B8E60B5-5BBA-410E-B97C-2917C2177014"></a>
<h2 id="BDCUG-GUID-6B8E60B5-5BBA-410E-B97C-2917C2177014" class="sect2"><span class="enumeration_section">6.8</span> Tika File Adapter</h2>
<div>
<p><a id="d37476e10519" class="indexterm-anchor"></a><a id="d37476e10521" class="indexterm-anchor"></a><a id="d37476e10525" class="indexterm-anchor"></a>This adapter provides functions to parse files stored in HDFS in various formats using Apache Tika library. It is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-1A98D28D-CE34-463A-8C26-454636F3D02F">Built-in Library Functions for Parsing Files with Tika</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730">Custom Functions for Parsing Files with Tika</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-4B931558-D4A5-47BE-85CF-B739F0D4BFF1">Tika Parser Output Format</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-BF636B9D-ABAC-4EDC-B35B-88415B399877">Tika Adapter Configuration Properties</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-A4A520D5-980E-4FFA-BB8A-66F82133553A">Examples of Tika File Adapter Functions</a></p>
</li>
</ul>
</div>
<a id="BDCUG1016"></a>
<div class="sect3"><a id="GUID-1A98D28D-CE34-463A-8C26-454636F3D02F"></a>
<h3 id="BDCUG-GUID-1A98D28D-CE34-463A-8C26-454636F3D02F" class="sect3"><span class="enumeration_section">6.8.1</span> Built-in Library Functions for Parsing Files with Tika</h3>
<div>
<p>To use the built-in functions in your query, you must import the Tika file module as follows:</p>
<pre dir="ltr">
import module "oxh:tika";
</pre>
<p>The Tika file module contains the following functions:</p>
<p>For examples, see <span class="q">"<a href="oxh_ref.htm#GUID-A4A520D5-980E-4FFA-BB8A-66F82133553A">Examples of Tika File Adapter Functions</a>."</span></p>
</div>
<a id="BDCUG1018"></a><a id="BDCUG1019"></a><a id="BDCUG1020"></a><a id="BDCUG1017"></a>
<div class="sect4"><a id="GUID-8161EA96-C88A-4EB9-9CA2-BCACEB08C6D4"></a>
<h4 id="BDCUG-GUID-8161EA96-C88A-4EB9-9CA2-BCACEB08C6D4" class="sect4"><span class="enumeration_section">6.8.1.1</span> tika:collection</h4>
<div>
<p>Parses files stored in HDFS in various formats and extracts the content or metadata from them.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %tika:collection function
   tika:collection($uris as xs:string*) as document-node()* external;

declare %tika:collection function
   function tika:collection($uris as xs:string*, $contentType as xs:string?) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The HDFS file URIs.</p>
<p><code class="codeph">$contentType</code>: Specifies the media type of the content to parse, and may have the <span class="italic">charset</span> attribute. When the parameter is specified, then it defines both type and encoding. When not specified, then Tika will attempt to auto-detect values from the file extension. Oracle recommends you to specify the parameter.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>Returns a document node for each value. See <span class="q">"<a href="oxh_ref.htm#GUID-4B931558-D4A5-47BE-85CF-B739F0D4BFF1">Tika Parser Output Format</a>"</span>.</p>
</div>
</div>
<a id="BDCUG1022"></a><a id="BDCUG1023"></a><a id="BDCUG1024"></a><a id="BDCUG1021"></a>
<div class="sect4"><a id="GUID-8E08ADF0-E189-4E06-9E15-EFA215CB3BE4"></a>
<h4 id="BDCUG-GUID-8E08ADF0-E189-4E06-9E15-EFA215CB3BE4" class="sect4"><span class="enumeration_section">6.8.1.2</span> tika:parse</h4>
<div>
<p>Parses the data given to it as an argument.For example, it can parse an html fragment within an XML or JSON document.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare function
   tika:parse($data as xs:string?, $contentType as xs:string?) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$data</code>: The value to be parsed.</p>
<p><code class="codeph">$contentType</code>: Specifies the media type of the content to parse, and may have the <span class="italic">charset</span> attribute. When the parameter is specified, then it defines both type and encoding. When not specified, then Tika will attempt to auto-detect values from the file extension. Oracle recommends you to specify the parameter.</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>Returns a document node for each value. See <span class="q">"<a href="oxh_ref.htm#GUID-4B931558-D4A5-47BE-85CF-B739F0D4BFF1">Tika Parser Output Format</a>"</span>.</p>
</div>
</div>
</div>
<a id="BDCUG1025"></a>
<div class="sect3"><a id="GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730"></a>
<h3 id="BDCUG-GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730" class="sect3"><span class="enumeration_section">6.8.2</span> Custom Functions for Parsing Files with Tika</h3>
<div>
<p>You can use the following annotations to define functions to parse files in HDFS with Tika. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading HDFS files must have one of the following signatures:</p>
<pre dir="ltr">
declare %tika:collection [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*, $contentType as xs:string?) as document-node()* external;
declare %tika:collection [<span class="italic">additional annotations</span>]
   function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as document-node()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730__GUID-348038C0-E10A-490C-BB54-F92CE2F5C268"><!-- --></a>%tika:collection(["<span class="italic">method</span>"])</dt>
<dd>
<p>Identifies an external function to be implemented by Tika file adapter. Required.</p>
<p>The optional <span class="italic">method</span> parameter can be one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">tika</code>: Each line in the tika file is returned as <code class="codeph">document-node()</code>. Default.</p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730__GUID-8558B74D-5A57-4EEF-8401-F3985593DE4F"><!-- --></a>%output:media-type</dt>
<dd>
<p>Declares the file content type. It is a MIME type and must not have the <span class="italic">charset</span> attribute as per XQuery specifications. Optional.</p>
</dd>
<dt class="dlterm"><a id="GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730__GUID-7BB022F7-6B49-430B-AE96-00527B8FB1CC"><!-- --></a>%output:encoding</dt>
<dd>
<p>Declares the file character set. Optional.</p>
<div class="infobox-note" id="GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730__GUID-F258025E-4360-49A3-A85B-EEB0BD6E768E">
<p class="notep1">Note:</p>
<p><code class="codeph">%output:media-type</code> and <code class="codeph">%output:econding</code> annotations specify the content type or encoding when the $contentType parameter is not explicitly provided in the signature.</p>
</div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<dl>
<dt class="dlterm"><a id="GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730__GUID-758F9586-BA9B-487E-9A78-F2CC790CE1DE"><!-- --></a>$uris as xs:string*</dt>
<dd>
<p>Lists the HDFS file URIs. Required.</p>
</dd>
<dt class="dlterm"><a id="GUID-EB552E7D-A593-4C9B-8E0C-FBB08E2EF730__GUID-B7025188-18CC-4F74-869A-220DD3F9EC13"><!-- --></a>$contentType as xs:string?</dt>
<dd>
<p>The file content type. It may have the <span class="italic">charset</span> attribute.</p>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Returns</p>
<p><code class="codeph">document-node()*</code> with two root elements. See <span class="q">"<a href="oxh_ref.htm#GUID-4B931558-D4A5-47BE-85CF-B739F0D4BFF1">Tika Parser Output Format</a>"</span>.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1043"></a><a id="BDCUG1044"></a><a id="BDCUG1042"></a>
<div class="sect3"><a id="GUID-4B931558-D4A5-47BE-85CF-B739F0D4BFF1"></a>
<h3 id="BDCUG-GUID-4B931558-D4A5-47BE-85CF-B739F0D4BFF1" class="sect3"><span class="enumeration_section">6.8.3</span> Tika Parser Output Format</h3>
<div>
<p>The result of Tika parsing is a document node with two root elements:</p>
<ul style="list-style-type: disc;">
<li>
<p>Root element #1 is an XHTML content produced by Tika.</p>
</li>
<li>
<p>Root element #2 is the document metadata extracted by Tika.</p>
</li>
</ul>
<p>The format of the root elements look like these:</p>
<div class="section">
<p class="subhead3">Root element #1</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
...textual content of Tika HTML...
&lt;/html&gt;
</pre>
<div class="section">
<p class="subhead3">Root element #2</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
&lt;tika:metadata xmlns:tika="oxh:tika"&gt;
   &lt;tika:property name="Name_1"&gt;VALUE_1&lt;/tika:property&gt;
   &lt;tika:property name="NAME_2"&gt;VALUE_2&lt;/tika:property&gt;
&lt;/tika:metadata&gt;
</pre></div>
</div>
<a id="BDCUG1045"></a>
<div class="sect3"><a id="GUID-BF636B9D-ABAC-4EDC-B35B-88415B399877"></a>
<h3 id="BDCUG-GUID-BF636B9D-ABAC-4EDC-B35B-88415B399877" class="sect3"><span class="enumeration_section">6.8.4</span> Tika Adapter Configuration Properties</h3>
<div>
<p>The following Hadoop properties control the behavior of Tika adapter:</p>
<dl>
<dt class="dlterm"><a id="GUID-BF636B9D-ABAC-4EDC-B35B-88415B399877__GUID-3DD7F178-C8EB-4E61-BC64-BDB01985C139"><!-- --></a>oracle.hadoop.xquery.tika.html.asis</dt>
<dd>
<p><span class="bold">Type</span>:Boolean</p>
<p><span class="bold">Default Value</span>: false.</p>
<p><span class="bold">Description</span>: When this is set to TRUE, then all the HTML elements are omitted during parsing. When this is set to FALSE, then only the safe elements are omitted during parsing.</p>
</dd>
<dt class="dlterm"><a id="GUID-BF636B9D-ABAC-4EDC-B35B-88415B399877__GUID-299F2842-74AA-4640-A433-061692E2EAAF"><!-- --></a>oracle.hadoop.xquery.tika.locale</dt>
<dd>
<p><span class="bold">Type</span>:Comma-separated list of strings</p>
<p><span class="bold">Default Value</span>:Not Defined.</p>
<p><span class="bold">Description</span>:Defines the locale to be used by some Tika parsers such as Microsoft Office document parser. Only three strings are allowed: language, country, and variant. The strings country and variant are optional. When locale is not defined, then the system locale is used. When the strings are defined it must correspond to the <code class="codeph">java.util.Locale</code> specification format mentioned in <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Locale.html" target="_blank"><code class="codeph">http://docs.oracle.com/javase/7/docs/api/java/util/Locale.html</code></a>and the locale can be constructed as follows:</p>
<ul style="list-style-type: disc;">
<li>
<p>If only language is specified, then the locale is constructed from the language.</p>
</li>
<li>
<p>If the language and country are specified, then the locale is constructed from both language and country</p>
</li>
<li>
<p>If language, country, and variant are specified, then the locale is constructed from language, country, and variant.</p>
</li>
</ul>
</dd>
</dl>
</div>
</div>
<a id="BDCUG1076"></a><a id="BDCUG1077"></a><a id="BDCUG1026"></a>
<div class="sect3"><a id="GUID-A4A520D5-980E-4FFA-BB8A-66F82133553A"></a>
<h3 id="BDCUG-GUID-A4A520D5-980E-4FFA-BB8A-66F82133553A" class="sect3"><span class="enumeration_section">6.8.5</span> Examples of Tika File Adapter Functions</h3>
<div>
<div class="example" id="GUID-A4A520D5-980E-4FFA-BB8A-66F82133553A__GUID-7E31600F-C5DB-458E-A993-C2E4748752AC">
<p class="titleinexample">Example 6-22 Using Built-in Functions to Index PDF documents with Cloudera Search</p>
<p>This example query uses Tika to parse PDF files into HTML form and then add the HTML documents into Solr's full-text index.</p>
<pre dir="ltr">
*bigdata*.pdf
 
</pre>
<p>The following query indexes the HDFS files:</p>
<pre dir="ltr">
import module "oxh:tika";
import module "oxh:solr";
 
for $doc in tika:collection("*bigdata*.pdf")
let $docid := data($doc//*:meta[@name eq "resourceName"]/@content)[1]
let $body := $doc//*:body[1]
return
   solr:put(
        &lt;doc&gt; 
            &lt;field name="id"&gt;{ $docid }&lt;/field&gt;
            &lt;field name="text"&gt;{ string($body) }&lt;/field&gt;
            &lt;field name="content"&gt;{ serialize($doc/*:html) }&lt;/field&gt;
         &lt;/doc&gt; 
   )
 
</pre>
<p>The HTML representation of the documents is added to Solr index and they become searchable. Each document Id in the index is the file name.</p>
</div>
<!-- class="example" -->
<div class="example" id="GUID-A4A520D5-980E-4FFA-BB8A-66F82133553A__GUID-268064AE-D0E0-4974-B79F-24819F6A161E">
<p class="titleinexample">Example 6-23 Using Built-in Functions to Index HTML documents with Cloudera Search</p>
<p>This example query uses sequence files and Tika to parse, where key is an URL and value is a html.</p>
<pre dir="ltr">
import module "oxh:tika";
import module "oxh:solr";
import module "oxh:seq";

for $doc in seq:collection-tika(&ldquo;/path/to/seq/files/*")
let $docid := document-uri($doc)
let $body := $doc//*:body[1]
return
   solr:put(
      &lt;doc&gt;
         &lt;field name="id"&gt;{ $docid }&lt;/field&gt;
         &lt;field name="text"&gt;{ string($body) }&lt;/field&gt;
         &lt;field name="content"&gt;{ serialize($doc/*:html) }&lt;/field&gt;
      &lt;/doc&gt;
   )
</pre>
<p>The HTML representation of the documents is added to Solr index and they become searchable. Each document Id in the index is the file name.</p>
</div>
<!-- class="example" --></div>
</div>
</div>
<a id="BDCUG662"></a>
<div class="sect2"><a id="GUID-C8085B84-9570-4F53-BA5E-E7EE13010130"></a>
<h2 id="BDCUG-GUID-C8085B84-9570-4F53-BA5E-E7EE13010130" class="sect2"><span class="enumeration_section">6.9</span> XML File Adapter</h2>
<div>
<p>The <a id="d37476e11058" class="indexterm-anchor"></a><a id="d37476e11060" class="indexterm-anchor"></a><a id="d37476e11064" class="indexterm-anchor"></a>XML file adapter provides access to XML files stored in HDFS. The adapter optionally splits individual XML files so that a single file can be processed in parallel by multiple tasks.</p>
<p>This adapter is described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-8094FF74-4E6E-45CB-86ED-9FB40EC64204">Built-in Functions for Reading XML Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22">Custom Functions for Reading XML Files</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7">Examples of XML File Adapter Functions</a></p>
</li>
</ul>
</div>
<a id="BDCUG663"></a>
<div class="sect3"><a id="GUID-8094FF74-4E6E-45CB-86ED-9FB40EC64204"></a>
<h3 id="BDCUG-GUID-8094FF74-4E6E-45CB-86ED-9FB40EC64204" class="sect3"><span class="enumeration_section">6.9.1</span> Built-in Functions for Reading XML Files</h3>
<div>
<p><a id="d37476e11103" class="indexterm-anchor"></a><a id="d37476e11107" class="indexterm-anchor"></a>To use the built-in functions in your query, you must import the XML file module as follows:</p>
<pre dir="ltr">
import module "oxh:xmlf";
</pre>
<p>The XML file module contains the following functions:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-8FF0DF11-EC0B-4CCA-BF40-46F450B7A7AB">xmlf:collection (Single Task)</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-C351DA84-2DC3-4716-8654-154C4CDA3756">xmlf:collection-multipart (Single Task)</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-D56CF746-BFFB-4FD0-9C1E-68F3A8DD49DF">xmlf:collection (Multiple Tasks)</a></p>
</li>
</ul>
<p>See <span class="q">"<a href="oxh_ref.htm#GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7">Examples of XML File Adapter Functions</a>."</span></p>
</div>
<a id="BDCUG891"></a><a id="BDCUG892"></a><a id="BDCUG893"></a><a id="BDCUG664"></a>
<div class="sect4"><a id="GUID-8FF0DF11-EC0B-4CCA-BF40-46F450B7A7AB"></a>
<h4 id="BDCUG-GUID-8FF0DF11-EC0B-4CCA-BF40-46F450B7A7AB" class="sect4"><span class="enumeration_section">6.9.1.1</span> xmlf:collection (Single Task)</h4>
<div>
<p>Accesses a collection of XML documents in HDFS. Multiple files can be processed concurrently, but each individual file is parsed by a single task.</p>
<p>This function automatically decompresses files compressed with a Hadoop-supported codec.</p>
<div class="infobox-note" id="GUID-8FF0DF11-EC0B-4CCA-BF40-46F450B7A7AB__GUID-A90365DE-40D3-4E64-A74E-82D85807AF6F">
<p class="notep1">Note:</p>
<p>HDFS does not perform well when data is stored in many small files. For large data sets with many small XML documents, use Hadoop sequence files and the <a href="oxh_ref.htm#GUID-214695C5-3584-4058-BA2B-CC55401DF845">Sequence File Adapter</a>.</p>
</div>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %xmlf:collection function
   xmlf:collection($uris as xs:string*) as document-node()* external;
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$uris</code>: The XML file URIs</p>
<div class="section">
<p class="subhead3">Returns</p>
</div>
<!-- class="section" -->
<p>One XML document for each file</p>
</div>
</div>
<div class="sect4"><a id="GUID-C351DA84-2DC3-4716-8654-154C4CDA3756"></a>
<h4 id="BDCUG-GUID-C351DA84-2DC3-4716-8654-154C4CDA3756" class="sect4"><span class="enumeration_section">6.9.1.2</span> xmlf:collection-multipart (Single Task)</h4>
<div>
<p>Accesses a collection of XML documents in HDFS. Multiple files can be processed concurrently, but each individual file is parsed by a single task. This function is the same as <span class="italic">xmlf:collection</span> except that each file may contain multiple well-formed XML documents concatenated together.</p>
<p>This function automatically decompresses files compressed with a Hadoop-supported codec. For example, a file containing multiple XML documents could be compressed using GZIP and then accessed directly by this function.</p>
<div class="section">
<p class="subhead3">Signature</p>
<pre dir="ltr">
declare %xmlf:collection("multipart")
 function    xmlf:collection($uris as xs:string*) as document-node()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<dl>
<dt class="dlterm"><a id="GUID-C351DA84-2DC3-4716-8654-154C4CDA3756__GUID-E56DBE02-E0F3-4400-8C1F-5D8FFB4B39FA"><!-- --></a>$uris</dt>
<dd>
<p>The XML file URIs.</p>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Returns</p>
<p>One or more XML documents for each file.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG665"></a>
<div class="sect4"><a id="GUID-D56CF746-BFFB-4FD0-9C1E-68F3A8DD49DF"></a>
<h4 id="BDCUG-GUID-D56CF746-BFFB-4FD0-9C1E-68F3A8DD49DF" class="sect4"><span class="enumeration_section">6.9.1.3</span> xmlf:collection (Multiple Tasks)</h4>
<div>
<p>Accesses a collection of XML documents in HDFS. The files might be split and processed by multiple tasks simultaneously, which enables very large XML files to be processed efficiently. The function returns only elements that match a specified name.</p>
<p>This function does not automatically decompress files. It only supports XML files that meet certain requirements. See <span class="q">"<a href="oxh_ref.htm#GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__BABFEGFB">Restrictions on Splitting XML Files</a>."</span></p>
<div class="section">
<p class="subhead3">Signature</p>
<pre dir="ltr">
declare %xmlf:collection function
   xmlf:collection($uris as xs:string*, $names as xs:anyAtomicType+) as element()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Parameters</p>
<dl>
<dt class="dlterm"><a id="GUID-D56CF746-BFFB-4FD0-9C1E-68F3A8DD49DF__GUID-E56DBE02-E0F3-4400-8C1F-5D8FFB4B39FA"><!-- --></a>$uris</dt>
<dd>
<p>The XML file URIs</p>
</dd>
<dt class="dlterm"><a id="GUID-D56CF746-BFFB-4FD0-9C1E-68F3A8DD49DF__GUID-78AE0DC6-2DD0-4BBF-8D94-3B8CF050A92D"><!-- --></a>$names</dt>
<dd>
<p>The names of the elements to be returned by the function. The names can be either strings or QNames. For QNames, the XML parser uses the namespace binding implied by the QName prefix and namespace.</p>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Returns</p>
<p>Each element that matches one of the names specified by the <code class="codeph">$names</code> argument</p>
</div>
<!-- class="section" --></div>
</div>
</div>
<a id="BDCUG669"></a><a id="BDCUG668"></a>
<div class="sect3"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22"></a>
<h3 id="BDCUG-GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22" class="sect3"><span class="enumeration_section">6.9.2</span> Custom Functions for Reading XML Files</h3>
<div>
<p>You can use the following annotations to define functions that read collections of XML files in HDFS. These annotations provide additional functionality that is not available using the built-in functions.</p>
<div class="section">
<p class="subhead3">Signature</p>
<p>Custom functions for reading XML files must have one of the following signatures:</p>
<pre dir="ltr">
declare %xmlf:collection(["xml"|"multipart"]) [<span class="italic">additional annotations</span>]
    function local:<span class="italic">myFunctionName</span>($uris as xs:string*) as node()* external;

declare %xmlf:collection("xml") [<span class="italic">additional annotations</span>]
    function local:<span class="italic">myFunctionName</span>($uris as xs:string*, $names as xs:anyAtomicType+) as element()* external;
</pre></div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Annotations</p>
<dl>
<dt class="dlterm"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-41A68A94-61C3-456E-82B2-B4ACEF16DFDE"><!-- --></a>%xmlf:collection</dt>
<dd>
<p>Declares the collection function. Required.</p>
<p>The method parameter is one of the following values:</p>
<ul style="list-style-type: disc;">
<li>
<p>xml: Each value is parsed as XML</p>
</li>
<li>
<p>multipart: Each value (or, file) may contain a concatenation of multiple well-formed XML documents. This method cannot be used with parallel XML parsing. (See <span class="italic">xmlf:split</span> and the two-argument function signature.)</p>
</li>
</ul>
</dd>
<dt class="dlterm"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-677158B5-E1F5-4959-8FCC-A7ADA6390DD9"><!-- --></a>%xmlf:split("<span class="italic">element-name1</span>"[,... "<span class="italic">element-nameN</span>")</dt>
<dd>
<p>Specifies the element names used for parallel XML parsing. You can use this annotation instead of the <code class="codeph">$names</code> argument.</p>
<p>When this annotation is specified, only the single-argument version of the function is allowed. This restriction enables the element names to be specified statically, so they do not need to be specified when the function is called.</p>
</dd>
<dt class="dlterm"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-B05D5859-67F5-4928-835A-D71473572799"><!-- --></a>%output:encoding("<span class="italic">charset</span>")</dt>
<dd>
<p>Identifies the text encoding of the input documents.</p>
<p>When this encoding is used with the <code class="codeph">%xmlf:split</code> annotation or the <code class="codeph">$names</code> argument, only ISO-8859-1, US-ASCII, and UTF-8 are valid encodings. Otherwise, the valid encodings are those supported by the JVM. UTF-8 is assumed when this annotation is omitted.</p>
<div class="infoboxnotealso" id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-56EBBA3E-C122-4D0C-8CAA-69658503BA80">
<p class="notep1">See Also:</p>
<p>"Supported Encodings" in the Oracle Java SE documentation at</p>
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html" target="_blank"><code class="codeph">http://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html</code></a></p>
</div>
</dd>
<dt class="dlterm"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-01B06F7F-1D03-41B2-8EF4-95118000FC36"><!-- --></a>%xmlf:split-namespace("<span class="italic">prefix</span>", "<span class="italic">namespace</span>")</dt>
<dd>
<p>This annotation provides extra namespace declarations to the parser. You can specify it multiple times to declare one or more namespaces.</p>
<p>Use this annotation to declare the namespaces of ancestor elements. When XML is processed in parallel, only elements that match the specified names are processed by an XML parser. If a matching element depends on the namespace declaration of one of its ancestor elements, then the declaration is not visible to the parser and an error may occur.</p>
<p>These namespace declarations can also be used in element names when specifying the split names. For example:</p>
<div class="p">
<pre dir="ltr">
declare 
    %xmlf:collection 
    %xmlf:split("eg:foo") 
    %xmlf:split-namespace("eg", "http://example.org")
    function local:myFunction($uris as xs:string*) as document-node() external;
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-326B65E2-1194-43DA-9D6F-1C7C485549BB"><!-- --></a>%xmlf:split-entity("<span class="italic">entity-name</span>", "<span class="italic">entity-value</span>")</dt>
<dd>
<p>Provides entity definitions to the XML parser. When XML is processed in parallel, only elements that match the specified split names are processed by an XML parser. The DTD of an input document that is split and processed in parallel is not processed.</p>
<p>In this example, the XML parser expands <code class="codeph">&amp;foo;</code> entity references as "Hello World":</p>
<pre dir="ltr">
%xmlf:split-entity("foo","Hello World")
</pre></dd>
<dt class="dlterm"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-E06F6085-5F5D-4163-A508-6E2274778A25"><!-- --></a>%xmlf:split-max("<span class="italic">split-size</span>")</dt>
<dd>
<p>Specifies the maximum split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit).These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%xmlf:split-max(1024)
%xmlf:split-max("1024")
%xmlf:split-max("1K")
</pre></div>
</dd>
<dt class="dlterm"><a id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__GUID-F50EB031-01F5-44C4-AAFA-36749EF1D00D"><!-- --></a>%xmlf:split-min("<span class="italic">split-size</span>")</dt>
<dd>
<p>Specifies the minimum split size as either an integer or a string value. The split size controls how the input file is divided into tasks. Hadoop calculates the split size as <code class="codeph">max($split-min, min($split-max, $block-size))</code>. Optional.</p>
<p>In a string value, you can append <code class="codeph">K</code>, <code class="codeph">k</code>, <code class="codeph">M</code>, <code class="codeph">m</code>, <code class="codeph">G</code>, or <code class="codeph">g</code> to the value to indicate kilobytes, megabytes, or gigabytes instead of bytes (the default unit). These qualifiers are not case sensitive. The following examples are equivalent:</p>
<div class="p">
<pre dir="ltr">
%xmlf:split-min(1024)
%xmlf:split-min("1024")
%xmlf:split-min("1K")
</pre></div>
</dd>
</dl>
</div>
<!-- class="section" -->
<div class="section">
<p class="subhead3">Notes</p>
<p id="GUID-3EB3872D-66C2-41BC-8BC1-CCA3E2049D22__BABFEGFB"><a id="d37476e11549" class="indexterm-anchor"></a><a id="d37476e11553" class="indexterm-anchor"></a>Restrictions on Splitting XML Files</p>
<p>Individual XML documents can be processed in parallel when the element names are specified using either the <code class="codeph">$names</code> argument or the <code class="codeph">$xmlf:split</code> annotation.</p>
<p>The input documents must meet the following constraints to be processed in parallel:</p>
<ul style="list-style-type: disc;">
<li>
<p>XML cannot contain a comment, <code class="codeph">CDATA</code> section, or processing instruction that contains text that matches one of the specified element names (that is, a <code class="codeph">&lt;</code> character followed by a name that expands to a QName). Otherwise, such content might be parsed incorrectly as an element.</p>
</li>
<li>
<p>An element in the file that matches a specified element name cannot contain a descendant element that also matches a specified name. Otherwise, multiple processors might pick up the matching descendant and cause the function to produce incorrect results.</p>
</li>
<li>
<p>An element that matches one of the specified element names (and all of its descendants) must not depend on the namespace declarations of any of its ancestors. Because the ancestors of a matching element are not parsed, the namespace declarations in these elements are not processed.</p>
<p>You can work around this limitation by manually specifying the namespace declarations with the <code class="codeph">%xmlf:split-namespace</code> annotation.</p>
</li>
</ul>
<p>Oracle recommends that the specified element names do not match elements in the file that are bigger than the split size. If they do, then the adapter functions correctly but not efficiently.</p>
<p>Processing XML in parallel is difficult, because parsing cannot begin in the middle of an XML file. XML constructs like <code class="codeph">CDATA</code> sections, comments, and namespace declarations impose this limitation. A parser starting in the middle of an XML document cannot assume that, for example, the string <code class="codeph">&lt;foo&gt;</code> is a begin element tag, without searching backward to the beginning of the document to ensure that it is not in a <code class="codeph">CDATA</code> section or a comment. However, large XML documents typically contain sequences of similarly structured elements and thus are amenable to parallel processing. If you specify the element names, then each task works by scanning a portion of the document for elements that match one of the specified names. Only elements that match a specified name are given to a true XML parser. Thus, the parallel processor does not perform a true parse of the entire document.</p>
</div>
<!-- class="section" --></div>
</div>
<a id="BDCUG1078"></a><a id="BDCUG1079"></a><a id="BDCUG666"></a>
<div class="sect3"><a id="GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7"></a>
<h3 id="BDCUG-GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7" class="sect3"><span class="enumeration_section">6.9.3</span> Examples of XML File Adapter Functions</h3>
<div>
<div class="example" id="GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7__CHEHFIBB">
<p class="titleinexample">Example 6-24 Using Built-in Functions to Query XML Files</p>
<p>This example queries three XML files in HDFS with the following contents. Each XML file contains comments made by users on a specific day. Each comment can have zero or more "likes" from other users.</p>
<pre dir="ltr">
mydata/comments1.xml
 
&lt;comments date="2013-12-30"&gt;
   &lt;comment id="12345" user="john" text="It is raining :( "/&gt;
   &lt;comment id="56789" user="kelly" text="I won the lottery!"&gt;
      &lt;like user="john"/&gt;
      &lt;like user="mike"/&gt;
   &lt;/comment&gt;
&lt;/comments&gt;
 
mydata/comments2.xml
 
&lt;comments date="2013-12-31"&gt;
   &lt;comment id="54321" user="mike" text="Happy New Year!"&gt;
      &lt;like user="laura"/&gt;
   &lt;/comment&gt;
&lt;/comments&gt;
 
mydata/comments3.xml
  
&lt;comments date="2014-01-01"&gt;
   &lt;comment id="87654" user="mike" text="I don't feel so good."/&gt;
   &lt;comment id="23456" user="john" text="What a beautiful day!"&gt;
      &lt;like user="kelly"/&gt;
      &lt;like user="phil"/&gt;
   &lt;/comment&gt;
&lt;/comments&gt;
 
</pre>
<p>This query writes the number of comments made each year to a text file. No element names are passed to <code class="codeph">xmlf:collection</code>, and so it returns three documents, one for each file. Each file is processed serially by a single task.</p>
<pre dir="ltr">
import module "oxh:xmlf";
import module "oxh:text";

for $comments in xmlf:collection("mydata/comments*.xml")/comments
let $date := xs:date($comments/@date)
group by $year := fn:year-from-date($date)
return 
   text:put($year || ", " || fn:count($comments/comment))
</pre>
<p>The query creates text files that contain the following lines:</p>
<pre dir="ltr">
2013, 3
2014, 2
</pre>
<p>The next query writes the number of comments and the average number of likes for each user. Each input file is split, so that it can be processed in parallel by multiple tasks. The <code class="codeph">xmlf:collection</code> function returns five elements, one for each comment.</p>
<pre dir="ltr">
import module "oxh:xmlf";
import module "oxh:text";

for $comment in xmlf:collection("mydata/comments*.xml", "comment")
let $likeCt := fn:count($comment/like)
group by $user := $comment/@user
return 
   text:put($user || ", " || fn:count($comment) || ", " || fn:avg($likeCt))
 
</pre>
<p>This query creates text files that contain the following lines:</p>
<pre dir="ltr">
john, 2, 1
kelly, 1, 2
mike, 2, 0.5
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7__GUID-B1DAF053-5E09-4F94-98AD-67B3CC9021BB">
<p class="titleinexample">Example 6-25 Writing a Custom Function to Query XML Files</p>
<p>The following example declares a custom function to access XML files:</p>
<pre dir="ltr">
import module "oxh:text";
 
declare 
   %xmlf:collection 
   %xmlf:split("comment")
   %xmlf:split-max("32M")
function local:comments($uris as xs:string*) as element()* external;
 
for $c in local:comments("mydata/comment*.xml")
where $c/@user eq "mike"
return text:put($c/@id)
 
</pre>
<p>The query creates a text file that contains the following lines:</p>
<pre dir="ltr">
54321
87654
</pre></div>
<!-- class="example" -->
<div class="example" id="GUID-41A04A59-4F92-4DE3-A8BF-6EEDA4CCFEB7__ABC7A984">
<p class="titleinexample">Example 6-26 Accessing Compressed, Multipart XML Files</p>
<p>Assume that files comments1.xml, comments2.xml, and comments3.xml from example 5-24 are concatenated together and compressed using GZIP to create a single file named comments.xml.gz. For example:</p>
<pre dir="ltr">
cat comments1.xml comments2.xml comments3.xml | gzip &gt; comments.xml.gz
</pre>
<p>The following query accesses this multipart, compressed XML file:</p>
<pre dir="ltr">
import module "oxh:text"; import module "oxh:xmlf";  
for $comment in xmlf:collection-multipart("comments.xml.gz")/comments/comment 
return
   text:put($comment/@id || "," || $comment/@user)
</pre>
<p>The query creates a text file that contains the following lines:</p>
<pre dir="ltr">
12345,john 
56789,kelly 
54321,mike 
87654,mike 
23456,john
</pre></div>
<!-- class="example" --></div>
</div>
</div>
<a id="BDCUG683"></a>
<div class="sect2"><a id="GUID-7B02969A-1525-4B58-8720-E04ACB1F7B07"></a>
<h2 id="BDCUG-GUID-7B02969A-1525-4B58-8720-E04ACB1F7B07" class="sect2"><span class="enumeration_section">6.10</span> Utility Module</h2>
<div>
<p>The utility module contains <code class="codeph">ora-fn</code> functions for handling strings and dates. These functions are defined in XDK XQuery, whereas the <code class="codeph">oxh</code> functions are specific to Oracle XQuery for Hadoop.</p>
<p>The utility functions are described in the following topics:</p>
<ul style="list-style-type: disc;">
<li>
<p><a href="oxh_ref.htm#GUID-65FBF15D-D1FA-4648-89E4-C613295F2787" title="You can manipulate durations, dates, and times in XQuery using Oracle XQuery functions.">Oracle XQuery Functions for Duration, Date, and Time</a></p>
</li>
<li>
<p><a href="oxh_ref.htm#GUID-F8F59CE8-C172-4C5E-BBC9-208332B96CC2" title="You can manipulate strings in XQuery using Oracle XQuery functions.">Oracle XQuery Functions for Strings</a></p>
</li>
</ul>
</div>
<a id="BDCUG684"></a>
<div class="sect3"><a id="GUID-65FBF15D-D1FA-4648-89E4-C613295F2787"></a>
<h3 id="BDCUG-GUID-65FBF15D-D1FA-4648-89E4-C613295F2787" class="sect3"><span class="enumeration_section">6.10.1</span> Oracle XQuery Functions for Duration, Date, and Time</h3>
<div>
<p>You can manipulate durations, dates, and times in XQuery using Oracle XQuery functions.</p>
<p>The Oracle XQuery functions are in namespace <code class="codeph">http://xmlns.oracle.com/xdk/xquery/function</code>. Namespace prefix<code class="codeph">ora-fn</code> is predeclared, and the module is automatically imported.</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-DCB091E4-0DC4-4F1A-977F-2F3E165C6317">ora-fn:date-from-string-with-format</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-44910E87-C56D-4F83-857F-412A08B0234A">ora-fn:date-to-string-with-format</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-9B138783-D1C1-4635-B5FC-EB8051B9FB39">ora-fn:dateTime-from-string-with-format</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-D70AE8F0-23CA-4B2D-AE40-F2F2C011E30E">ora-fn:dateTime-to-string-with-format</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-2F0C19D0-F2A5-49EF-A5C5-DE29CE26DF0E">ora-fn:time-from-string-with-format</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-8E822A4B-489B-46E1-8DA8-553C31B81F1E">ora-fn:time-to-string-with-format</a></code></p>
</li>
</ul>
</div>
<a id="BDCUG896"></a><a id="BDCUG897"></a><a id="BDCUG898"></a><a id="BDCUG895"></a>
<div class="sect4"><a id="GUID-DCB091E4-0DC4-4F1A-977F-2F3E165C6317"></a>
<h4 id="BDCUG-GUID-DCB091E4-0DC4-4F1A-977F-2F3E165C6317" class="sect4"><span class="enumeration_section">6.10.1.1</span> ora-fn:date-from-string-with-format</h4>
<div>
<p>Returns a new date value from a string according to the specified pattern.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:date-from-string-with-format($format as xs:string?,
                                    $dateString as xs:string?, 
                                    $locale as xs:string*)
                                   as xs:date?

ora-fn:date-from-string-with-format($format as xs:string?,
                                    $dateString as xs:string?)
                                   as xs:date?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$format</code>: The pattern; see <span class="q">"<a href="oxh_ref.htm#GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346" title="The $format argument identifies the various fields that compose a date or time value.">Format Argument</a>"</span></p>
<p><code class="codeph">$dateString</code>: An input string that represents a date</p>
<p><code class="codeph">$locale</code>: A one- to three-field value that represents the locale; see <span class="q">"<a href="oxh_ref.htm#GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B" title="The $locale represents a specific geographic, political, or cultural region.">Locale Argument</a>"</span></p>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>This example returns the specified date in the current time zone:</p>
<pre dir="ltr">
ora-fn:date-from-string-with-format("yyyy-MM-dd G", "2013-06-22 AD")
</pre></div>
</div>
<a id="BDCUG900"></a><a id="BDCUG901"></a><a id="BDCUG902"></a><a id="BDCUG899"></a>
<div class="sect4"><a id="GUID-44910E87-C56D-4F83-857F-412A08B0234A"></a>
<h4 id="BDCUG-GUID-44910E87-C56D-4F83-857F-412A08B0234A" class="sect4"><span class="enumeration_section">6.10.1.2</span> ora-fn:date-to-string-with-format</h4>
<div>
<p>Returns a date string with the specified pattern.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:date-to-string-with-format($format as xs:string?,
                                  $date as xs:date?,
                                  *$locale as xs:string?)
                                 as xs:string?

ora-fn:date-to-string-with-format($format as xs:string?,
                                  $date as xs:date?)
                                 as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$format</code>: The pattern; see <a href="oxh_ref.htm#GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346" title="The $format argument identifies the various fields that compose a date or time value.">Format Argument</a></p>
<p><code class="codeph">$date</code>: The date</p>
<p><code class="codeph">$locale</code>: A one- to three-field value that represents the locale; see <a href="oxh_ref.htm#GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B" title="The $locale represents a specific geographic, political, or cultural region.">Locale Argument</a></p>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>This example returns the string <code class="codeph">2013-07-15</code>:</p>
<pre dir="ltr">
ora-fn:date-to-string-with-format("yyyy-mm-dd", xs:date("2013-07-15"))
</pre></div>
</div>
<a id="BDCUG904"></a><a id="BDCUG905"></a><a id="BDCUG906"></a><a id="BDCUG903"></a>
<div class="sect4"><a id="GUID-9B138783-D1C1-4635-B5FC-EB8051B9FB39"></a>
<h4 id="BDCUG-GUID-9B138783-D1C1-4635-B5FC-EB8051B9FB39" class="sect4"><span class="enumeration_section">6.10.1.3</span> ora-fn:dateTime-from-string-with-format</h4>
<div>
<p>Returns a new date-time value from an input string according to the specified pattern.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:dateTime-from-string-with-format($format as xs:string?, 
                                        $dateTimeString as xs:string?,
                                        $locale as xs:string?)
                                       as xs:dateTime?

ora-fn:dateTime-from-string-with-format($format as xs:string?,
                                        $dateTimeString as xs:string?)
                                       as xs:dateTime?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$format</code>: The pattern; see <a href="oxh_ref.htm#GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346" title="The $format argument identifies the various fields that compose a date or time value.">Format Argument</a></p>
<p><code class="codeph">$dateTimeString</code>: The date and time</p>
<p><code class="codeph">$locale</code>: A one- to three-field value that represents the locale; see <span class="q">"<a href="oxh_ref.htm#GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B" title="The $locale represents a specific geographic, political, or cultural region.">Locale Argument</a>"</span></p>
<div class="section">
<p class="subhead3">Examples</p>
</div>
<!-- class="section" -->
<p>This example returns the specified date and 11:04:00AM in the current time zone:</p>
<pre dir="ltr">
ora-fn:dateTime-from-string-with-format("yyyy-MM-dd 'at' hh:mm", 
                                        "2013-06-22 at 11:04")
</pre>
<p>The next example returns the specified date and 12:00:00AM in the current time zone:</p>
<pre dir="ltr">
ora-fn:dateTime-from-string-with-format("yyyy-MM-dd G",
                                        "2013-06-22 AD") 
</pre></div>
</div>
<a id="BDCUG908"></a><a id="BDCUG909"></a><a id="BDCUG910"></a><a id="BDCUG907"></a>
<div class="sect4"><a id="GUID-D70AE8F0-23CA-4B2D-AE40-F2F2C011E30E"></a>
<h4 id="BDCUG-GUID-D70AE8F0-23CA-4B2D-AE40-F2F2C011E30E" class="sect4"><span class="enumeration_section">6.10.1.4</span> ora-fn:dateTime-to-string-with-format</h4>
<div>
<p>Returns a date and time string with the specified pattern.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:dateTime-to-string-with-format($format as xs:string?,
                                      $dateTime as xs:dateTime?,
                                      $locale as xs:string?)
                                     as xs:string?

ora-fn:dateTime-to-string-with-format($format as xs:string?,
                                      $dateTime as xs:dateTime?)
                                     as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$format</code>: The pattern; see <span class="q">"<a href="oxh_ref.htm#GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346" title="The $format argument identifies the various fields that compose a date or time value.">Format Argument</a>"</span></p>
<p><code class="codeph">$dateTime</code>: The date and time</p>
<p><code class="codeph">$locale</code>: A one- to three-field value that represents the locale; see <span class="q">"<a href="oxh_ref.htm#GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B" title="The $locale represents a specific geographic, political, or cultural region.">Locale Argument</a>"</span></p>
<div class="section">
<p class="subhead3">Examples</p>
</div>
<!-- class="section" -->
<p>This example returns the string <code class="codeph">07 JAN 2013 10:09 PM AD</code>:</p>
<pre dir="ltr">
ora-fn:dateTime-to-string-with-format("dd MMM yyyy hh:mm a G",
                                      xs:dateTime("2013-01-07T22:09:44"))
</pre>
<p>The next example returns the string "01-07-2013":</p>
<pre dir="ltr">
ora-fn:dateTime-to-string-with-format("MM-dd-yyyy",
                                      xs:dateTime("2013-01-07T22:09:44")) 
</pre></div>
</div>
<a id="BDCUG912"></a><a id="BDCUG913"></a><a id="BDCUG914"></a><a id="BDCUG911"></a>
<div class="sect4"><a id="GUID-2F0C19D0-F2A5-49EF-A5C5-DE29CE26DF0E"></a>
<h4 id="BDCUG-GUID-2F0C19D0-F2A5-49EF-A5C5-DE29CE26DF0E" class="sect4"><span class="enumeration_section">6.10.1.5</span> ora-fn:time-from-string-with-format</h4>
<div>
<p>Returns a new time value from an input string according to the specified pattern.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:time-from-string-with-format($format as xs:string?,
                                    $timeString as xs:string?,
                                    $locale as xs:string?)
                                   as xs:time?

ora-fn:time-from-string-with-format($format as xs:string?,
                                    $timeString as xs:string?)
                                   as xs:time?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$format</code>: The pattern; see <span class="q">"<a href="oxh_ref.htm#GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346" title="The $format argument identifies the various fields that compose a date or time value.">Format Argument</a>"</span></p>
<p><code class="codeph">$timeString</code>: The time</p>
<p><code class="codeph">$locale</code>: A one- to three-field value that represents the locale; see <a href="oxh_ref.htm#GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B" title="The $locale represents a specific geographic, political, or cultural region.">Locale Argument</a></p>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>This example returns 9:45:22 PM in the current time zone:</p>
<pre dir="ltr">
ora-fn:time-from-string-with-format("HH.mm.ss", "21.45.22")
</pre>
<p>The next example returns 8:07:22 PM in the current time zone:</p>
<pre dir="ltr">
fn-bea:time-from-string-with-format("hh:mm:ss a", "8:07:22 PM") 
</pre></div>
</div>
<a id="BDCUG916"></a><a id="BDCUG917"></a><a id="BDCUG918"></a><a id="BDCUG915"></a>
<div class="sect4"><a id="GUID-8E822A4B-489B-46E1-8DA8-553C31B81F1E"></a>
<h4 id="BDCUG-GUID-8E822A4B-489B-46E1-8DA8-553C31B81F1E" class="sect4"><span class="enumeration_section">6.10.1.6</span> ora-fn:time-to-string-with-format</h4>
<div>
<p>Returns a time string with the specified pattern.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:time-to-string-with-format($format as xs:string?,
                                  $time as xs:time?,
                                  $locale as xs:string?)
                                 as xs:string?

ora-fn:time-to-string-with-format($format as xs:string?, $time as xs:time?) as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$format</code>: The pattern; see <span class="q">"<a href="oxh_ref.htm#GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346" title="The $format argument identifies the various fields that compose a date or time value.">Format Argument</a>"</span></p>
<p><code class="codeph">$time</code>: The time</p>
<p><code class="codeph">$locale</code>: A one- to three-field value that represents the locale; see <span class="q">"<a href="oxh_ref.htm#GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B" title="The $locale represents a specific geographic, political, or cultural region.">Locale Argument</a>"</span></p>
<div class="section">
<p class="subhead3">Examples</p>
</div>
<!-- class="section" -->
<p>This example returns the string "10:09 PM":</p>
<pre dir="ltr">
ora-fn:time-to-string-with-format("hh:mm a", xs:time("22:09:44"))
</pre>
<p>The next example returns the string "22:09 PM":</p>
<pre dir="ltr">
ora-fn:time-to-string-with-format("HH:mm a", xs:time("22:09:44"))
</pre></div>
</div>
<a id="BDCUG685"></a>
<div class="sect4"><a id="GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346"></a>
<h4 id="BDCUG-GUID-0209668E-BBE9-4ADE-A4BB-ABDA3B4B3346" class="sect4"><span class="enumeration_section">6.10.1.7</span> Format Argument</h4>
<p>The <code class="codeph">$format</code> argument identifies the various fields that compose a date or time value.</p>
</div>
<a id="BDCUG919"></a>
<div class="sect4"><a id="GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B"></a>
<h4 id="BDCUG-GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B" class="sect4"><span class="enumeration_section">6.10.1.8</span> Locale Argument</h4>
<div>
<p>The <code class="codeph">$locale</code> represents a specific geographic, political, or cultural region.</p>
<p>It is defined by up to three fields:</p>
<ol>
<li>
<p><span class="bold">Language code</span>: The ISO 639 alpha-2 or alpha-3 language code, or the registered language subtags of up to eight letters. For example, <code class="codeph">en</code> for English and <code class="codeph">ja</code> for Japanese.</p>
</li>
<li>
<p><span class="bold">Country code</span>: The ISO 3166 alpha-2 country code or the UN M.49 numeric-3 area code. For example, <code class="codeph">US</code> for the United States and <code class="codeph">029</code> for the Caribbean.</p>
</li>
<li>
<p><span class="bold">Variant</span>: Indicates a variation of the locale, such as a particular dialect. Order multiple values in order of importance and separate them with an underscore (_). These values are case sensitive.</p>
</li>
</ol>
<div class="infoboxnotealso" id="GUID-0F2E2FD8-D9BA-4EA8-B452-5BA5B2AC350B__GUID-7FFDC7E5-E939-4F3D-9BAF-8102FEDEB172">
<p class="notep1">See Also:</p>
<ul style="list-style-type: disc;">
<li>
<p><a class="olink javase7_util_locale" target="_blank" href="http://www.oracle.com/pls/topic/lookup?ctx=E92664-01&amp;id=javase7_util_locale">Class Locale</a> in <cite>Java Standard Edition 7 Reference</cite></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<a id="BDCUG688"></a>
<div class="sect3"><a id="GUID-F8F59CE8-C172-4C5E-BBC9-208332B96CC2"></a>
<h3 id="BDCUG-GUID-F8F59CE8-C172-4C5E-BBC9-208332B96CC2" class="sect3"><span class="enumeration_section">6.10.2</span> Oracle XQuery Functions for Strings</h3>
<div>
<p>You can manipulate strings in XQuery using Oracle XQuery functions.</p>
<p>The Oracle XQuery functions are in namespace <code class="codeph">http://xmlns.oracle.com/xdk/xquery/function</code>. Namespace prefix<code class="codeph">ora-fn</code> is predeclared, and the module is automatically imported.</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-7DB5EB9D-A95C-42F4-AED7-3CF6208E8194" title="Adds padding characters to the left of a string to create a fixed-length string. If the input string exceeds the specified size, then it is truncated to return a substring of the specified length. The default padding character is a space (ASCII 32).">ora-fn:pad-left</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-5D2BE1DE-5EA6-4E2D-ADD5-44D028899DC0" title="Adds padding characters to the right of a string to create a fixed-length string. If the input string exceeds the specified size, then it is truncated to return a substring of the specified length. The default padding character is a space (ASCII 32).">ora-fn:pad-right</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-9C664B13-A1C4-4DDA-87E0-720379FF1BD7" title="Removes any leading or trailing white space from a string.">ora-fn:trim</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-09B54A7A-F2D1-4717-BEE7-C6E4BD852F80" title="Removes any leading white space.">ora-fn:trim-left</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-99D161E3-CDBE-489C-8AD2-93370FD0DD92" title="Removes any trailing white space.">ora-fn:trim-right</a></code></p>
</li>
</ul>
</div>
<a id="BDCUG921"></a><a id="BDCUG922"></a><a id="BDCUG923"></a><a id="BDCUG920"></a>
<div class="sect4"><a id="GUID-7DB5EB9D-A95C-42F4-AED7-3CF6208E8194"></a>
<h4 id="BDCUG-GUID-7DB5EB9D-A95C-42F4-AED7-3CF6208E8194" class="sect4"><span class="enumeration_section">6.10.2.1</span> ora-fn:pad-left</h4>
<div>
<p>Adds padding characters to the left of a string to create a fixed-length string. If the input string exceeds the specified size, then it is truncated to return a substring of the specified length. The default padding character is a space (ASCII 32).</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:pad-left($str as xs:string?,
                $size as xs:integer?,
                $pad as xs:string?)
               as xs:string?

ora-fn:pad-left($str as xs:string?,
                $size as xs:integer?)
               as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$str</code>: The input string</p>
<p><code class="codeph">$size</code>: The desired fixed length, which is obtained by adding padding characters to <code class="codeph">$str</code></p>
<p><code class="codeph">$pad</code>: The padding character</p>
<p>If either argument is an empty sequence, then the function returns an empty sequence.</p>
<div class="section">
<p class="subhead3">Examples</p>
</div>
<!-- class="section" -->
<p>This example prefixes <code class="codeph">"01</code>" to the input string up to the maximum of six characters. The returned string is "<code class="codeph">010abc</code>". The function returns one complete and one partial pad character.</p>
<pre dir="ltr">
ora-fn:pad-left("abc", 6, "01")
</pre>
<p>The example returns only "<code class="codeph">ab</code>" because the input string exceeds the specified fixed length:</p>
<pre dir="ltr">
ora-fn:pad-left("abcd", 2, "01")
</pre>
<p>This example prefixes spaces to the string up to the specified maximum of six characters. The returned string has a prefix of two spaces: " <code class="codeph">abcd</code>":</p>
<pre dir="ltr">
ora-fn:pad-left("abcd", 6)
</pre>
<p>The next example returns only "<code class="codeph">ab</code>" because the input string exceeds the specified fixed length:</p>
<pre dir="ltr">
ora-fn:pad-left("abcd", 2)
</pre></div>
</div>
<a id="BDCUG925"></a><a id="BDCUG926"></a><a id="BDCUG927"></a><a id="BDCUG924"></a>
<div class="sect4"><a id="GUID-5D2BE1DE-5EA6-4E2D-ADD5-44D028899DC0"></a>
<h4 id="BDCUG-GUID-5D2BE1DE-5EA6-4E2D-ADD5-44D028899DC0" class="sect4"><span class="enumeration_section">6.10.2.2</span> ora-fn:pad-right</h4>
<div>
<p>Adds padding characters to the right of a string to create a fixed-length string. If the input string exceeds the specified size, then it is truncated to return a substring of the specified length. The default padding character is a space (ASCII 32).</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:pad-right($str as xs:string?,
                 $size as xs:integer?,
                 $pad as xs:string?)
                as xs:string?

ora-fn:pad-right($str as xs:string?,
                 $size as xs:integer?)
                as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$str</code>: The input string</p>
<p><code class="codeph">$size</code>: The desired fixed length, which is obtained by adding padding characters to <code class="codeph">$str</code></p>
<p><code class="codeph">$pad</code>: The padding character</p>
<p>If either argument is an empty sequence, then the function returns an empty sequence.</p>
<div class="section">
<p class="subhead3">Examples</p>
</div>
<!-- class="section" -->
<p>This example appends "<code class="codeph">01</code>" to the input string up to the maximum of six characters. The returned string is "<code class="codeph">abc010</code>". The function returns one complete and one partial pad character.</p>
<pre dir="ltr">
ora-fn:pad-right("abc", 6, "01")
</pre>
<p>This example returns only "<code class="codeph">ab</code>" because the input string exceeds the specified fixed length:</p>
<pre dir="ltr">
ora-fn:pad-right("abcd", 2, "01")
</pre>
<p>This example appends spaces to the string up to the specified maximum of six characters. The returned string has a suffix of two spaces: "<code class="codeph">abcd</code> ":</p>
<pre dir="ltr">
ora-fn:pad-right("abcd", 6)
</pre>
<p>The next example returns only "<code class="codeph">ab</code>" because the input string exceeds the specified fixed length:</p>
<pre dir="ltr">
ora-fn:pad-right("abcd", 2)
</pre></div>
</div>
<a id="BDCUG929"></a><a id="BDCUG930"></a><a id="BDCUG931"></a><a id="BDCUG928"></a>
<div class="sect4"><a id="GUID-9C664B13-A1C4-4DDA-87E0-720379FF1BD7"></a>
<h4 id="BDCUG-GUID-9C664B13-A1C4-4DDA-87E0-720379FF1BD7" class="sect4"><span class="enumeration_section">6.10.2.3</span> ora-fn:trim</h4>
<div>
<p>Removes any leading or trailing white space from a string.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:trim($input as xs:string?) as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$input</code>: The string to trim. If <code class="codeph">$input</code> is an empty sequence, then the function returns an empty sequence. Other data types trigger an error.</p>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>This example returns the string "<code class="codeph">abc</code>":</p>
<pre dir="ltr">
ora-fn:trim("  abc  ")
</pre></div>
</div>
<a id="BDCUG933"></a><a id="BDCUG934"></a><a id="BDCUG935"></a><a id="BDCUG932"></a>
<div class="sect4"><a id="GUID-09B54A7A-F2D1-4717-BEE7-C6E4BD852F80"></a>
<h4 id="BDCUG-GUID-09B54A7A-F2D1-4717-BEE7-C6E4BD852F80" class="sect4"><span class="enumeration_section">6.10.2.4</span> ora-fn:trim-left</h4>
<div>
<p>Removes any leading white space.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:trim-left($input as xs:string?) as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$input</code>: The string to trim. If <code class="codeph">$input</code> is an empty sequence, then the function returns an empty sequence. Other data types trigger an error.</p>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>This example removes the leading spaces and returns the string "<code class="codeph">abc&nbsp;&nbsp;&nbsp;&nbsp;</code>":</p>
<pre dir="ltr">
ora-fn:trim-left("    abc    ")
</pre></div>
</div>
<a id="BDCUG937"></a><a id="BDCUG938"></a><a id="BDCUG939"></a><a id="BDCUG936"></a>
<div class="sect4"><a id="GUID-99D161E3-CDBE-489C-8AD2-93370FD0DD92"></a>
<h4 id="BDCUG-GUID-99D161E3-CDBE-489C-8AD2-93370FD0DD92" class="sect4"><span class="enumeration_section">6.10.2.5</span> ora-fn:trim-right</h4>
<div>
<p>Removes any trailing white space.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
ora-fn:trim-right($input as xs:string?) as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$input</code>: The string to trim. If <code class="codeph">$input</code> is an empty sequence, then the function returns an empty sequence. Other data types trigger an error.</p>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>This example removes the trailing spaces and returns the string "<code class="codeph">&nbsp;&nbsp;&nbsp;&nbsp;abc</code>":</p>
<pre dir="ltr">
ora-fn:trim-left("    abc    ")
</pre></div>
</div>
</div>
</div>
<a id="BDCUG689"></a>
<div class="sect2"><a id="GUID-969E3FF3-02E9-410E-80C6-746F5BBA7173"></a>
<h2 id="BDCUG-GUID-969E3FF3-02E9-410E-80C6-746F5BBA7173" class="sect2"><span class="enumeration_section">6.11</span> Hadoop Module</h2>
<div>
<p>These functions are in the <code class="codeph">http://xmlns.oracle.com/hadoop/xquery</code> namespace. The <code class="codeph">oxh</code> prefix is predeclared and the module is automatically imported.</p>
<p>The Hadoop module is described in the following topic:</p>
<ul style="list-style-type: disc;">
<li>
<p>Hadoop Functions</p>
</li>
</ul>
</div>
<a id="BDCUG940"></a>
<div class="sect3"><a id="GUID-5F32DBC5-CF7F-4375-AF15-F953A6EC11BB"></a>
<h3 id="BDCUG-GUID-5F32DBC5-CF7F-4375-AF15-F953A6EC11BB" class="sect3"><span class="enumeration_section">6.11.1</span> Built-in Functions for Using Hadoop</h3>
<div>
<p>The following functions are built in to Oracle XQuery for Hadoop:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-3F3F1094-5465-42BB-AD59-6D5A8B17887B">oxh:find</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-6B7476E2-E086-4099-BFA3-6493AD117018">oxh:increment-counter</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-67940DD5-66E2-40F3-9708-36BCF67929BF">oxh:println</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-A2D7F034-8145-4539-96C2-B139DF06E1C4">oxh:println-xml</a></code></p>
</li>
<li>
<p><code class="codeph"><a href="oxh_ref.htm#GUID-07E74E57-E4D6-4D1F-B691-5939E235C35C">oxh:property</a></code></p>
</li>
</ul>
</div>
<a id="BDCUG942"></a><a id="BDCUG943"></a><a id="BDCUG941"></a>
<div class="sect4"><a id="GUID-3F3F1094-5465-42BB-AD59-6D5A8B17887B"></a>
<h4 id="BDCUG-GUID-3F3F1094-5465-42BB-AD59-6D5A8B17887B" class="sect4"><span class="enumeration_section">6.11.1.1</span> oxh:find</h4>
<div>
<p>Returns a sequence of file paths that match a pattern.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
oxh:find($pattern as xs:string?) as xs:string*
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$pattern</code>: The file pattern to search for</p>
<div class="infoboxnotealso" id="GUID-3F3F1094-5465-42BB-AD59-6D5A8B17887B__GUID-8E59812D-2923-4FD5-92AD-812FE24FEE48">
<p class="notep1">See Also:</p>
<p>For the file pattern, the <code class="codeph">globStatus</code> method in the Apache Hadoop API at</p>
<p><a href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/fs/FileSystem.html#globStatus(org.apache.hadoop.fs.Path)" target="_blank"><code class="codeph">http://hadoop.apache.org/docs/current/api/org/apache/hadoop/fs/FileSystem.html#globStatus(org.apache.hadoop.fs.Path)</code></a></p>
</div>
</div>
</div>
<a id="BDCUG945"></a><a id="BDCUG946"></a><a id="BDCUG944"></a>
<div class="sect4"><a id="GUID-6B7476E2-E086-4099-BFA3-6493AD117018"></a>
<h4 id="BDCUG-GUID-6B7476E2-E086-4099-BFA3-6493AD117018" class="sect4"><span class="enumeration_section">6.11.1.2</span> oxh:increment-counter</h4>
<div>
<p>Increments a user-defined MapReduce job counter. The default increment is one (1).</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
oxh:increment-counter($groupName as xs:string, $counterName as xs:string, $value as xs:integer

oxh:increment-counter($groupName as xs:string, $counterName as xs:string
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$groupName</code>: The group of counters that this counter belongs to.</p>
<p><code class="codeph">$counterName</code>: The name of a user-defined counter</p>
<p><code class="codeph">$value</code>: The amount to increment the counter</p>
</div>
</div>
<a id="BDCUG987"></a><a id="BDCUG988"></a><a id="BDCUG989"></a><a id="BDCUG986"></a>
<div class="sect4"><a id="GUID-67940DD5-66E2-40F3-9708-36BCF67929BF"></a>
<h4 id="BDCUG-GUID-67940DD5-66E2-40F3-9708-36BCF67929BF" class="sect4"><span class="enumeration_section">6.11.1.3</span> oxh:println</h4>
<div>
<p>Prints a line of text to <code class="codeph">stdout</code> of the Oracle XQuery for Hadoop client process. Use this function when developing queries.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %updating function oxh:println($arg as xs:anyAtomicType?)
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$arg</code>: A value to add to the output. A <code class="codeph">cast</code> operation first converts it to <code class="codeph">string</code>. An empty sequence is handled the same way as an empty string.</p>
<div class="section">
<p class="subhead3">Example</p>
</div>
<!-- class="section" -->
<p>This example prints the values of <code class="codeph">data.txt</code> to <code class="codeph">stdout</code>:</p>
<pre dir="ltr">
for $i in text:collection("data.txt") 
return oxh:println($i)
</pre></div>
</div>
<a id="BDCUG991"></a><a id="BDCUG992"></a><a id="BDCUG990"></a>
<div class="sect4"><a id="GUID-A2D7F034-8145-4539-96C2-B139DF06E1C4"></a>
<h4 id="BDCUG-GUID-A2D7F034-8145-4539-96C2-B139DF06E1C4" class="sect4"><span class="enumeration_section">6.11.1.4</span> oxh:println-xml</h4>
<div>
<p>Prints a line of text or XML to <code class="codeph">stdout</code> of the Oracle XQuery for Hadoop client process. Use this function when developing queries and printing nodes of an XML document.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
declare %updating function oxh:println-xml($arg as item()?)
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$arg</code>: A value to add to the output. The input item is converted into a text as defined by XSLT 2.0 and XQuery 1.0 Serialization specifications. An empty sequence is handled the same way as an empty string.</p>
</div>
</div>
<a id="BDCUG948"></a><a id="BDCUG949"></a><a id="BDCUG947"></a>
<div class="sect4"><a id="GUID-07E74E57-E4D6-4D1F-B691-5939E235C35C"></a>
<h4 id="BDCUG-GUID-07E74E57-E4D6-4D1F-B691-5939E235C35C" class="sect4"><span class="enumeration_section">6.11.1.5</span> oxh:property</h4>
<div>
<p>Returns the value of a Hadoop configuration property.</p>
<div class="section">
<p class="subhead3">Signature</p>
</div>
<!-- class="section" -->
<pre dir="ltr">
oxh:property($name as xs:string?) as xs:string?
</pre>
<div class="section">
<p class="subhead3">Parameters</p>
</div>
<!-- class="section" -->
<p><code class="codeph">$name</code>: The configuration property</p>
</div>
</div>
</div>
</div>
<a id="BDCUG690"></a>
<div class="sect2"><a id="GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5"></a>
<h2 id="BDCUG-GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5" class="sect2"><span class="enumeration_section">6.12</span> Serialization Annotations</h2>
<div>
<p>Several adapters have <a id="d37476e13030" class="indexterm-anchor"></a>serialization annotations (<code class="codeph">%output:*</code>). The following lists identify the serialization parameters that Oracle XQuery for Hadoop supports.</p>
<p>Serialization parameters supported for the <code class="codeph">text</code> output method:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">encoding</code>: Any encoding supported by the JVM</p>
</li>
<li>
<p><code class="codeph">normalization-form</code>: none, NFC, NFD, NFKC, NFKD</p>
</li>
</ul>
<p>Serialization parameters supported for the <code class="codeph">xml</code> output method, using any values permitted by the XQuery specification:</p>
<ul style="list-style-type: disc;">
<li>
<p><code class="codeph">cdata-section-elements</code></p>
</li>
<li>
<p><code class="codeph">doctype-public</code></p>
</li>
<li>
<p><code class="codeph">doctype-system</code></p>
</li>
<li>
<p><code class="codeph">encoding</code></p>
</li>
<li>
<p><code class="codeph">indent</code></p>
</li>
<li>
<p><code class="codeph">normalization-form</code></p>
</li>
<li>
<p><code class="codeph">omit-xml-declaration</code></p>
</li>
<li>
<p><code class="codeph">standalone</code></p>
</li>
</ul>
<div class="infoboxnotealso" id="GUID-73E21786-FA93-44A1-9A87-BE33061BF4C5__GUID-D1378F3E-DE5C-4C4F-A1B2-82C14EA38D40">
<p class="notep1">See Also:</p>
<p>"The Influence of Serialization Parameters" sections for XML and text output methods in <span class="italic">XSLT and XQuery Serialization</span>, at locations like the following:</p>
<p><a href="http://www.w3.org/TR/xslt-xquery-serialization/#XML_DOCTYPE" target="_blank"><code class="codeph">http://www.w3.org/TR/xslt-xquery-serialization/#XML_DOCTYPE</code></a></p>
<p><a href="http://www.w3.org/TR/xslt-xquery-serialization/#XML_CDATA-SECTION-ELEMENTS" target="_blank"><code class="codeph">http://www.w3.org/TR/xslt-xquery-serialization/#XML_CDATA-SECTION-ELEMENTS</code></a></p>
</div>
</div>
</div>
</div>
<!-- class="ind" --><!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1">
<tr>
<td class="cellalignment42">
<table class="cellalignment6">
<tr>
<td class="cellalignment5"><a href="oxh.htm"><img width="24" height="24" src="../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5"><a href="oxh_hive.htm"><img width="24" height="24" src="../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2011, 2017, Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment44">
<table class="cellalignment4">
<tr>
<td class="cellalignment5"><a href="http://www.docs.oracle.com/bigdata/411/index.html"><img width="24" height="24" src="../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5"><a href="toc.htm"><img width="24" height="24" src="../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5"><a href="index.htm"><img width="24" height="24" src="../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5"><a href="../dcommon/html/feedback.htm"><img width="24" height="24" src="../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
